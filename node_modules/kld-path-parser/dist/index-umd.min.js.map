{"version":3,"file":"index-umd.min.js","sources":["../lib/PathLexeme.js","../lib/PathLexer.js","../lib/PathParser.js","../lib/SampleHandler.js"],"sourcesContent":["/**\n *  PathLexeme.js\n *\n *  @copyright 2002, 2013 Kevin Lindsey\n *  @module PathLexeme\n */\n\n/**\n *  PathLexeme\n */\nclass PathLexeme {\n    /**\n     *  PathLexeme\n     *\n     *  @param {number} type\n     *  @param {string} text\n     */\n    constructor(type, text) {\n        this.type = type;\n        this.text = text;\n    }\n\n    /**\n     *  Determine if this lexeme is of the given type\n     *\n     *  @param {number} type\n     *  @returns {boolean}\n     */\n    typeis(type) {\n        return this.type === type;\n    }\n}\n\n/*\n * token type enumerations\n */\nPathLexeme.UNDEFINED = 0;\nPathLexeme.COMMAND = 1;\nPathLexeme.NUMBER = 2;\nPathLexeme.EOD = 3;\n\nexport default PathLexeme;\n","/**\n *  PathLexer.js\n *\n *  @copyright 2003, 2013 Kevin Lindsey\n *  @module PathLexer\n */\n\nimport PathLexeme from \"./PathLexeme.js\";\n\n/**\n *  Create a new instance of PathLexer\n */\nclass PathLexer {\n    /**\n     *  @param {string} [pathData]\n     */\n    constructor(pathData) {\n        if (pathData === null || pathData === undefined) {\n            pathData = \"\";\n        }\n\n        this.setPathData(pathData);\n    }\n\n    /**\n     *  setPathData\n     *\n     *  @param {string} pathData\n     */\n    setPathData(pathData) {\n        if (typeof pathData !== \"string\") {\n            throw new TypeError(\"The first parameter must be a string\");\n        }\n\n        this._pathData = pathData;\n    }\n\n    /**\n     *  getNextToken\n     *\n     *  @returns {PathLexeme}\n     */\n    getNextToken() {\n        let result = null;\n        let d = this._pathData;\n\n        while (result === null) {\n            if (d === null || d === \"\") {\n                result = new PathLexeme(PathLexeme.EOD, \"\");\n            }\n            else if (d.match(/^([ \\t\\r\\n,]+)/)) {\n                d = d.substr(RegExp.$1.length);\n            }\n            else if (d.match(/^([AaCcHhLlMmQqSsTtVvZz])/)) {\n                result = new PathLexeme(PathLexeme.COMMAND, RegExp.$1);\n                d = d.substr(RegExp.$1.length);\n            }\n            /* eslint-disable-next-line unicorn/no-unsafe-regex */\n            else if (d.match(/^(([-+]?\\d+(\\.\\d*)?|[-+]?\\.\\d+)([eE][-+]?\\d+)?)/)) {\n                result = new PathLexeme(PathLexeme.NUMBER, RegExp.$1);\n                d = d.substr(RegExp.$1.length);\n            }\n            else {\n                throw new SyntaxError(`Unrecognized path data: ${d}`);\n            }\n        }\n\n        this._pathData = d;\n\n        return result;\n    }\n}\n\nexport default PathLexer;\n","/**\n *  PathParser.js\n *\n *  @copyright 2003, 2017 Kevin Lindsey\n *  @module PathParser\n */\n\nimport PathLexer from \"./PathLexer.js\";\nimport PathLexeme from \"./PathLexeme.js\";\n\nconst BOP = \"BOP\";\n\n/**\n *  PathParser\n */\nclass PathParser {\n    /**\n     * constructor\n     */\n    constructor() {\n        this._lexer = new PathLexer();\n        this._handler = null;\n    }\n\n    /**\n     *  parseData\n     *\n     *  @param {string} pathData\n     *  @throws {Error}\n     */\n    parseData(pathData) {\n        if (typeof pathData !== \"string\") {\n            throw new TypeError(`The first parameter must be a string: ${pathData}`);\n        }\n\n        // begin parse\n        if (this._handler !== null && typeof this._handler.beginParse === \"function\") {\n            this._handler.beginParse();\n        }\n\n        // pass the pathData to the lexer\n        const lexer = this._lexer;\n\n        lexer.setPathData(pathData);\n\n        // set mode to signify new path - Beginning Of Path\n        let mode = BOP;\n\n        // Process all tokens\n        let lastToken = null;\n        let token = lexer.getNextToken();\n\n        while (token.typeis(PathLexeme.EOD) === false) {\n            let parameterCount;\n            const params = [];\n\n            // process current token\n            switch (token.type) {\n                case PathLexeme.COMMAND:\n                    if (mode === BOP && token.text !== \"M\" && token.text !== \"m\") {\n                        throw new SyntaxError(`New paths must begin with a moveto command. Found '${token.text}'`);\n                    }\n\n                    // Set new parsing mode\n                    mode = token.text;\n\n                    // Get count of numbers that must follow this command\n                    parameterCount = PathParser.PARAMCOUNT[token.text.toUpperCase()];\n\n                    // Advance past command token\n                    token = lexer.getNextToken();\n                    break;\n\n                case PathLexeme.NUMBER:\n                    // Most commands allow you to keep repeating parameters\n                    // without specifying the command again.  We just assume\n                    // that is the case and do nothing since the mode remains\n                    // the same\n\n                    if (mode === BOP) {\n                        throw new SyntaxError(`New paths must begin with a moveto command. Found '${token.text}'`);\n                    }\n                    else {\n                        parameterCount = PathParser.PARAMCOUNT[mode.toUpperCase()];\n                    }\n                    break;\n\n                default:\n                    throw new SyntaxError(`Unrecognized command type: ${token.type}`);\n            }\n\n            // Get parameters\n            for (let i = 0; i < parameterCount; i++) {\n                switch (token.type) {\n                    case PathLexeme.COMMAND:\n                        throw new SyntaxError(`Parameter must be a number. Found '${token.text}'`);\n\n                    case PathLexeme.NUMBER:\n                        // convert current parameter to a float and add to\n                        // parameter list\n                        params[i] = parseFloat(token.text);\n                        break;\n\n                    case PathLexeme.EOD:\n                        throw new SyntaxError(\"Unexpected end of string\");\n\n                    default:\n                        throw new SyntaxError(`Unrecognized parameter type. Found type '${token.type}'`);\n                }\n\n                token = lexer.getNextToken();\n            }\n\n            // fire handler\n            if (this._handler !== null) {\n                const handler = this._handler;\n                const methodName = PathParser.METHODNAME[mode];\n\n                // convert types for arcs\n                if (mode === \"a\" || mode === \"A\") {\n                    params[3] = params[3] !== 0;\n                    params[4] = params[4] !== 0;\n                }\n\n                if (handler !== null && typeof handler[methodName] === \"function\") {\n                    handler[methodName](...params);\n                }\n            }\n\n            // Lineto's follow moveto when no command follows moveto params.  Go\n            // ahead and set the mode just in case no command follows the moveto\n            // command\n            switch (mode) {\n                case \"M\":\n                    mode = \"L\";\n                    break;\n                case \"m\":\n                    mode = \"l\";\n                    break;\n                case \"Z\":\n                case \"z\":\n                    mode = \"BOP\";\n                    break;\n                default:\n                    // ignore for now\n            }\n\n            if (token === lastToken) {\n                throw new SyntaxError(`Parser stalled on '${token.text}'`);\n            }\n            else {\n                lastToken = token;\n            }\n        }\n\n        // end parse\n        if (this._handler !== null && typeof this._handler.endParse === \"function\") {\n            this._handler.endParse();\n        }\n    }\n\n    /**\n     *  setHandler\n     *\n     *  @param {Object} handler\n     */\n    setHandler(handler) {\n        this._handler = handler;\n    }\n}\n\n/*\n * class constants\n */\nPathParser.PARAMCOUNT = {\n    A: 7,\n    C: 6,\n    H: 1,\n    L: 2,\n    M: 2,\n    Q: 4,\n    S: 4,\n    T: 2,\n    V: 1,\n    Z: 0\n};\nPathParser.METHODNAME = {\n    A: \"arcAbs\",\n    a: \"arcRel\",\n    C: \"curvetoCubicAbs\",\n    c: \"curvetoCubicRel\",\n    H: \"linetoHorizontalAbs\",\n    h: \"linetoHorizontalRel\",\n    L: \"linetoAbs\",\n    l: \"linetoRel\",\n    M: \"movetoAbs\",\n    m: \"movetoRel\",\n    Q: \"curvetoQuadraticAbs\",\n    q: \"curvetoQuadraticRel\",\n    S: \"curvetoCubicSmoothAbs\",\n    s: \"curvetoCubicSmoothRel\",\n    T: \"curvetoQuadraticSmoothAbs\",\n    t: \"curvetoQuadraticSmoothRel\",\n    V: \"linetoVerticalAbs\",\n    v: \"linetoVerticalRel\",\n    Z: \"closePath\",\n    z: \"closePath\"\n};\n\nexport default PathParser;\n","/* eslint-disable prefer-rest-params */\n/**\n *  SampleHandler.js\n *\n *  @copyright 2003, 2013 Kevin Lindsey\n *  @module SampleHandler\n */\n\n/**\n *  SampleHandler\n */\nclass SampleHandler {\n    constructor() {\n        this.logs = [];\n    }\n\n    /**\n     *  log\n     *\n     *  @param {string} name\n     *  @param {Array<string>} params\n     */\n    log(name, ...params) {\n        this.logs.push(`${name}(${params.join(\",\")})`);\n    }\n\n    /**\n     *  arcAbs - A\n     *\n     *  @param {number} rx\n     *  @param {number} ry\n     *  @param {number} xAxisRotation\n     *  @param {boolean} largeArcFlag\n     *  @param {boolean} sweepFlag\n     *  @param {number} x\n     *  @param {number} y\n     */\n    arcAbs(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n        this.log(\"arcAbs\", ...arguments);\n    }\n\n    /**\n     *  arcRel - a\n     *\n     *  @param {number} rx\n     *  @param {number} ry\n     *  @param {number} xAxisRotation\n     *  @param {boolean} largeArcFlag\n     *  @param {boolean} sweepFlag\n     *  @param {number} x\n     *  @param {number} y\n     */\n    arcRel(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n        this.log(\"arcRel\", ...arguments);\n    }\n\n    /**\n     *  curvetoCubicAbs - C\n     *\n     *  @param {number} x1\n     *  @param {number} y1\n     *  @param {number} x2\n     *  @param {number} y2\n     *  @param {number} x\n     *  @param {number} y\n     */\n    curvetoCubicAbs(x1, y1, x2, y2, x, y) {\n        this.log(\"curvetoCubicAbs\", ...arguments);\n    }\n\n    /**\n     *  curvetoCubicRel - c\n     *\n     *  @param {number} x1\n     *  @param {number} y1\n     *  @param {number} x2\n     *  @param {number} y2\n     *  @param {number} x\n     *  @param {number} y\n     */\n    curvetoCubicRel(x1, y1, x2, y2, x, y) {\n        this.log(\"curvetoCubicRel\", ...arguments);\n    }\n\n    /**\n     *  linetoHorizontalAbs - H\n     *\n     *  @param {number} x\n     */\n    linetoHorizontalAbs(x) {\n        this.log(\"linetoHorizontalAbs\", ...arguments);\n    }\n\n    /**\n     *  linetoHorizontalRel - h\n     *\n     *  @param {number} x\n     */\n    linetoHorizontalRel(x) {\n        this.log(\"linetoHorizontalRel\", ...arguments);\n    }\n\n    /**\n     *  linetoAbs - L\n     *\n     *  @param {number} x\n     *  @param {number} y\n     */\n    linetoAbs(x, y) {\n        this.log(\"linetoAbs\", ...arguments);\n    }\n\n    /**\n     *  linetoRel - l\n     *\n     *  @param {number} x\n     *  @param {number} y\n     */\n    linetoRel(x, y) {\n        this.log(\"linetoRel\", ...arguments);\n    }\n\n    /**\n     *  movetoAbs - M\n     *\n     *  @param {number} x\n     *  @param {number} y\n     */\n    movetoAbs(x, y) {\n        this.log(\"movetoAbs\", ...arguments);\n    }\n\n    /**\n     *  movetoRel - m\n     *\n     *  @param {number} x\n     *  @param {number} y\n     */\n    movetoRel(x, y) {\n        this.log(\"movetoRel\", ...arguments);\n    }\n\n    /**\n     *  curvetoQuadraticAbs - Q\n     *\n     *  @param {number} x1\n     *  @param {number} y1\n     *  @param {number} x\n     *  @param {number} y\n     */\n    curvetoQuadraticAbs(x1, y1, x, y) {\n        this.log(\"curvetoQuadraticAbs\", ...arguments);\n    }\n\n    /**\n     *  curvetoQuadraticRel - q\n     *\n     *  @param {number} x1\n     *  @param {number} y1\n     *  @param {number} x\n     *  @param {number} y\n     */\n    curvetoQuadraticRel(x1, y1, x, y) {\n        this.log(\"curvetoQuadraticRel\", ...arguments);\n    }\n\n    /**\n     *  curvetoCubicSmoothAbs - S\n     *\n     *  @param {number} x2\n     *  @param {number} y2\n     *  @param {number} x\n     *  @param {number} y\n     */\n    curvetoCubicSmoothAbs(x2, y2, x, y) {\n        this.log(\"curvetoCubicSmoothAbs\", ...arguments);\n    }\n\n    /**\n     *  curvetoCubicSmoothRel - s\n     *\n     *  @param {number} x2\n     *  @param {number} y2\n     *  @param {number} x\n     *  @param {number} y\n     */\n    curvetoCubicSmoothRel(x2, y2, x, y) {\n        this.log(\"curvetoCubicSmoothRel\", ...arguments);\n    }\n\n    /**\n     *  curvetoQuadraticSmoothAbs - T\n     *\n     *  @param {number} x\n     *  @param {number} y\n     */\n    curvetoQuadraticSmoothAbs(x, y) {\n        this.log(\"curvetoQuadraticSmoothAbs\", ...arguments);\n    }\n\n    /**\n     *  curvetoQuadraticSmoothRel - t\n     *\n     *  @param {number} x\n     *  @param {number} y\n     */\n    curvetoQuadraticSmoothRel(x, y) {\n        this.log(\"curvetoQuadraticSmoothRel\", ...arguments);\n    }\n\n    /**\n     *  linetoVerticalAbs - V\n     *\n     *  @param {number} y\n     */\n    linetoVerticalAbs(y) {\n        this.log(\"linetoVerticalAbs\", ...arguments);\n    }\n\n    /**\n     *  linetoVerticalRel - v\n     *\n     *  @param {number} y\n     */\n    linetoVerticalRel(y) {\n        this.log(\"linetoVerticalRel\", ...arguments);\n    }\n\n    /**\n     *  closePath - z or Z\n     */\n    closePath() {\n        this.log(\"closePath\", ...arguments);\n    }\n}\n\nexport default SampleHandler;\n"],"names":["PathLexeme","type","text","this","UNDEFINED","COMMAND","NUMBER","EOD","PathLexer","pathData","setPathData","TypeError","_pathData","result","d","match","substr","RegExp","$1","length","SyntaxError","PathParser","_lexer","_handler","beginParse","lexer","mode","lastToken","token","getNextToken","typeis","parameterCount","params","PARAMCOUNT","toUpperCase","i","parseFloat","handler","methodName","METHODNAME","endParse","A","C","H","L","M","Q","S","T","V","Z","a","c","h","l","m","q","s","t","v","z","SampleHandler","logs","name","push","join","rx","ry","xAxisRotation","largeArcFlag","sweepFlag","x","y","log","arguments","x1","y1","x2","y2"],"mappings":"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"}