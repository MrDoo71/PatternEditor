{"version":3,"file":"index-umd.min.js","sources":["../lib/Polynomial.js","../lib/SqrtPolynomial.js"],"sourcesContent":["/* eslint-disable camelcase */\n/**\n *  Polynomial.js\n *\n *  @module Polynomial\n *  @copyright 2002-2019 Kevin Lindsey<br>\n *  -<br>\n *  Contribution {@link http://github.com/Quazistax/kld-polynomial}<br>\n *  copyright 2015 Robert Benko (Quazistax) <quazistax@gmail.com><br>\n *  MIT license\n */\n\n/**\n *  Sign of a number (+1, -1, +0, -0).\n *\n *  @param {number} x\n *  @returns {number}\n */\nfunction sign(x) {\n    // eslint-disable-next-line no-self-compare\n    return typeof x === \"number\" ? x ? x < 0 ? -1 : 1 : x === x ? x : NaN : NaN;\n}\n\n/**\n *  Polynomial\n *\n *  @memberof module:kld-polynomial\n */\nclass Polynomial {\n    /**\n     *  Polynomial\n     *\n     *  @param {Array<number>} coefs\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    constructor(...coefs) {\n        this.coefs = [];\n\n        for (let i = coefs.length - 1; i >= 0; i--) {\n            this.coefs.push(coefs[i]);\n        }\n\n        this._variable = \"t\";\n        this._s = 0;\n    }\n\n    /**\n     *  Based on polint in \"Numerical Recipes in C, 2nd Edition\", pages 109-110\n     *\n     *  @param {Array<number>} xs\n     *  @param {Array<number>} ys\n     *  @param {number} n\n     *  @param {number} offset\n     *  @param {number} x\n     *\n     *  @returns {{y: number, dy: number}}\n     */\n    static interpolate(xs, ys, n, offset, x) {\n        if (xs.constructor !== Array || ys.constructor !== Array) {\n            throw new TypeError(\"xs and ys must be arrays\");\n        }\n        if (isNaN(n) || isNaN(offset) || isNaN(x)) {\n            throw new TypeError(\"n, offset, and x must be numbers\");\n        }\n\n        let i, y;\n        let dy = 0;\n        const c = new Array(n);\n        const d = new Array(n);\n        let ns = 0;\n\n        let diff = Math.abs(x - xs[offset]);\n\n        for (i = 0; i < n; i++) {\n            const dift = Math.abs(x - xs[offset + i]);\n\n            if (dift < diff) {\n                ns = i;\n                diff = dift;\n            }\n            c[i] = d[i] = ys[offset + i];\n        }\n\n        y = ys[offset + ns];\n        ns--;\n\n        for (let m = 1; m < n; m++) {\n            for (i = 0; i < n - m; i++) {\n                const ho = xs[offset + i] - x;\n                const hp = xs[offset + i + m] - x;\n                const w = c[i + 1] - d[i];\n                let den = ho - hp;\n\n                if (den === 0.0) {\n                    throw new RangeError(\"Unable to interpolate polynomial. Two numbers in n were identical (to within roundoff)\");\n                }\n\n                den = w / den;\n                d[i] = hp * den;\n                c[i] = ho * den;\n            }\n\n            dy = (2 * (ns + 1) < (n - m)) ? c[ns + 1] : d[ns--];\n            y += dy;\n        }\n\n        return {y, dy};\n    }\n\n    /**\n     *  Newton's (Newton-Raphson) method for finding Real roots on univariate function. <br/>\n     *  When using bounds, algorithm falls back to secant if newton goes out of range.\n     *  Bisection is fallback for secant when determined secant is not efficient enough.\n     *  @see {@link http://en.wikipedia.org/wiki/Newton%27s_method}\n     *  @see {@link http://en.wikipedia.org/wiki/Secant_method}\n     *  @see {@link http://en.wikipedia.org/wiki/Bisection_method}\n     *\n     *  @param {number} x0 - Initial root guess\n     *  @param {Function} f - Function which root we are trying to find\n     *  @param {Function} df - Derivative of function f\n     *  @param {number} max_iterations - Maximum number of algorithm iterations\n     *  @param {number} [min] - Left bound value\n     *  @param {number} [max] - Right bound value\n     *  @returns {number} root\n     */\n    static newtonSecantBisection(x0, f, df, max_iterations, min, max) {\n        let x, prev_dfx = 0, dfx, prev_x_ef_correction = 0, x_correction, x_new;\n        let y, y_atmin, y_atmax;\n\n        x = x0;\n\n        const ACCURACY = 14;\n        const min_correction_factor = Math.pow(10, -ACCURACY);\n        const isBounded = (typeof min === \"number\" && typeof max === \"number\");\n\n        if (isBounded) {\n            if (min > max) {\n                throw new RangeError(\"Min must be greater than max\");\n            }\n\n            y_atmin = f(min);\n            y_atmax = f(max);\n\n            if (sign(y_atmin) === sign(y_atmax)) {\n                throw new RangeError(\"Y values of bounds must be of opposite sign\");\n            }\n        }\n\n        const isEnoughCorrection = function() {\n            // stop if correction is too small or if correction is in simple loop\n            return (Math.abs(x_correction) <= min_correction_factor * Math.abs(x)) ||\n                (prev_x_ef_correction === (x - x_correction) - x);\n        };\n\n        for (let i = 0; i < max_iterations; i++) {\n            dfx = df(x);\n\n            if (dfx === 0) {\n                if (prev_dfx === 0) {\n                    // error\n                    throw new RangeError(\"df(x) is zero\");\n                }\n                else {\n                    // use previous derivation value\n                    dfx = prev_dfx;\n                }\n                // or move x a little?\n                // dfx = df(x != 0 ? x + x * 1e-15 : 1e-15);\n            }\n\n            prev_dfx = dfx;\n            y = f(x);\n            x_correction = y / dfx;\n            x_new = x - x_correction;\n\n            if (isEnoughCorrection()) {\n                break;\n            }\n\n            if (isBounded) {\n                if (sign(y) === sign(y_atmax)) {\n                    max = x;\n                    y_atmax = y;\n                }\n                else if (sign(y) === sign(y_atmin)) {\n                    min = x;\n                    y_atmin = y;\n                }\n                else {\n                    x = x_new;\n                    break;\n                }\n\n                if ((x_new < min) || (x_new > max)) {\n                    if (sign(y_atmin) === sign(y_atmax)) {\n                        break;\n                    }\n\n                    const RATIO_LIMIT = 50;\n                    const AIMED_BISECT_OFFSET = 0.25; // [0, 0.5)\n                    const dy = y_atmax - y_atmin;\n                    const dx = max - min;\n\n                    if (dy === 0) {\n                        x_correction = x - (min + dx * 0.5);\n                    }\n                    else if (Math.abs(dy / Math.min(y_atmin, y_atmax)) > RATIO_LIMIT) {\n                        x_correction = x - (min + dx * (0.5 + (Math.abs(y_atmin) < Math.abs(y_atmax) ? -AIMED_BISECT_OFFSET : AIMED_BISECT_OFFSET)));\n                    }\n                    else {\n                        x_correction = x - (min - y_atmin / dy * dx);\n                    }\n                    x_new = x - x_correction;\n\n                    if (isEnoughCorrection()) {\n                        break;\n                    }\n                }\n            }\n\n            prev_x_ef_correction = x - x_new;\n            x = x_new;\n        }\n\n        return x;\n    }\n\n    /**\n     *  Clones this polynomial and return the clone.\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    clone() {\n        const poly = new Polynomial();\n\n        poly.coefs = this.coefs.slice();\n\n        return poly;\n    }\n\n    /**\n     *  eval\n     *\n     *  @param {number} x\n     */\n    eval(x) {\n        if (isNaN(x)) {\n            throw new TypeError(`Parameter must be a number. Found '${x}'`);\n        }\n\n        let result = 0;\n\n        for (let i = this.coefs.length - 1; i >= 0; i--) {\n            result = result * x + this.coefs[i];\n        }\n\n        return result;\n    }\n\n    /**\n     *  add\n     *\n     *  @param {module:kld-polynomial.Polynomial} that\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    add(that) {\n        const result = new Polynomial();\n        const d1 = this.getDegree();\n        const d2 = that.getDegree();\n        const dmax = Math.max(d1, d2);\n\n        for (let i = 0; i <= dmax; i++) {\n            const v1 = (i <= d1) ? this.coefs[i] : 0;\n            const v2 = (i <= d2) ? that.coefs[i] : 0;\n\n            result.coefs[i] = v1 + v2;\n        }\n\n        return result;\n    }\n\n    /**\n     *  multiply\n     *\n     *  @param {module:kld-polynomial.Polynomial} that\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    multiply(that) {\n        const result = new Polynomial();\n\n        for (let i = 0; i <= this.getDegree() + that.getDegree(); i++) {\n            result.coefs.push(0);\n        }\n\n        for (let i = 0; i <= this.getDegree(); i++) {\n            for (let j = 0; j <= that.getDegree(); j++) {\n                result.coefs[i + j] += this.coefs[i] * that.coefs[j];\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  divideEqualsScalar\n     *\n     *  @deprecated To be replaced by divideScalar\n     *  @param {number} scalar\n     */\n    divideEqualsScalar(scalar) {\n        for (let i = 0; i < this.coefs.length; i++) {\n            this.coefs[i] /= scalar;\n        }\n    }\n\n    /**\n     *  simplifyEquals\n     *\n     *  @deprecated To be replaced by simplify\n     *  @param {number} TOLERANCE\n     */\n    simplifyEquals(TOLERANCE = 1e-12) {\n        for (let i = this.getDegree(); i >= 0; i--) {\n            if (Math.abs(this.coefs[i]) <= TOLERANCE) {\n                this.coefs.pop();\n            }\n            else {\n                break;\n            }\n        }\n    }\n\n    /**\n     *  Sets small coefficients to zero.\n     *\n     *  @deprecated To be replaced by removeZeros\n     *  @param {number} TOLERANCE\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    removeZerosEquals(TOLERANCE = 1e-15) {\n        const c = this.coefs;\n        const err = 10 * TOLERANCE * Math.abs(\n            c.reduce((pv, cv) => {\n                return Math.abs(cv) > Math.abs(pv) ? cv : pv;\n            })\n        );\n\n        for (let i = 0; i < c.length - 1; i++) {\n            if (Math.abs(c[i]) < err) {\n                c[i] = 0;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     *  Scales polynomial so that leading coefficient becomes 1.\n     *\n     *  @deprecated To be replaced by getMonic\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    monicEquals() {\n        const c = this.coefs;\n\n        if (c[c.length - 1] !== 1) {\n            this.divideEqualsScalar(c[c.length - 1]);\n        }\n\n        return this;\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        const coefs = [];\n        const signs = [];\n\n        for (let i = this.coefs.length - 1; i >= 0; i--) {\n            let value = Math.round(this.coefs[i] * 1000) / 1000;\n\n            if (value !== 0) {\n                const signString = (value < 0) ? \" - \" : \" + \";\n\n                value = Math.abs(value);\n\n                if (i > 0) {\n                    if (value === 1) {\n                        value = this._variable;\n                    }\n                    else {\n                        value += this._variable;\n                    }\n                }\n\n                if (i > 1) {\n                    value += \"^\" + i;\n                }\n\n                signs.push(signString);\n                coefs.push(value);\n            }\n        }\n\n        signs[0] = (signs[0] === \" + \") ? \"\" : \"-\";\n\n        let result = \"\";\n\n        for (let i = 0; i < coefs.length; i++) {\n            result += signs[i] + coefs[i];\n        }\n\n        return result;\n    }\n\n    /**\n     *  bisection\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @param {number} [TOLERANCE]\n     *  @param {number} [ACCURACY]\n     *  @returns {number}\n     */\n    bisection(min, max, TOLERANCE = 1e-6, ACCURACY = 15) {\n        let minValue = this.eval(min);\n        let maxValue = this.eval(max);\n        let result;\n\n        if (Math.abs(minValue) <= TOLERANCE) {\n            result = min;\n        }\n        else if (Math.abs(maxValue) <= TOLERANCE) {\n            result = max;\n        }\n        else if (minValue * maxValue <= 0) {\n            const tmp1 = Math.log(max - min);\n            const tmp2 = Math.LN10 * ACCURACY;\n            const maxIterations = Math.ceil((tmp1 + tmp2) / Math.LN2);\n\n            for (let i = 0; i < maxIterations; i++) {\n                result = 0.5 * (min + max);\n                const value = this.eval(result);\n\n                if (Math.abs(value) <= TOLERANCE) {\n                    break;\n                }\n\n                if (value * minValue < 0) {\n                    max = result;\n                    maxValue = value;\n                }\n                else {\n                    min = result;\n                    minValue = value;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  Based on trapzd in \"Numerical Recipes in C, 2nd Edition\", page 137\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @param {number} n\n     *  @returns {number}\n     */\n    trapezoid(min, max, n) {\n        if (isNaN(min) || isNaN(max) || isNaN(n)) {\n            throw new TypeError(\"Parameters must be numbers\");\n        }\n\n        const range = max - min;\n\n        if (n === 1) {\n            const minValue = this.eval(min);\n            const maxValue = this.eval(max);\n\n            this._s = 0.5 * range * (minValue + maxValue);\n        }\n        else {\n            const iter = 1 << (n - 2);\n            const delta = range / iter;\n            let x = min + 0.5 * delta;\n            let sum = 0;\n\n            for (let i = 0; i < iter; i++) {\n                sum += this.eval(x);\n                x += delta;\n            }\n\n            this._s = 0.5 * (this._s + range * sum / iter);\n        }\n\n        if (isNaN(this._s)) {\n            throw new TypeError(\"this._s is NaN\");\n        }\n\n        return this._s;\n    }\n\n    /**\n     *  Based on trapzd in \"Numerical Recipes in C, 2nd Edition\", page 139\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {number}\n     */\n    simpson(min, max) {\n        if (isNaN(min) || isNaN(max)) {\n            throw new TypeError(\"Parameters must be numbers\");\n        }\n\n        const range = max - min;\n        let st = 0.5 * range * (this.eval(min) + this.eval(max));\n        let t = st;\n        let s = 4.0 * st / 3.0;\n        let os = s;\n        let ost = st;\n        const TOLERANCE = 1e-7;\n\n        let iter = 1;\n\n        for (let n = 2; n <= 20; n++) {\n            const delta = range / iter;\n            let x = min + 0.5 * delta;\n            let sum = 0;\n\n            for (let i = 1; i <= iter; i++) {\n                sum += this.eval(x);\n                x += delta;\n            }\n\n            t = 0.5 * (t + range * sum / iter);\n            st = t;\n            s = (4.0 * st - ost) / 3.0;\n\n            if (Math.abs(s - os) < TOLERANCE * Math.abs(os)) {\n                break;\n            }\n\n            os = s;\n            ost = st;\n            iter <<= 1;\n        }\n\n        return s;\n    }\n\n    /**\n     *  romberg\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {number}\n     */\n    romberg(min, max) {\n        if (isNaN(min) || isNaN(max)) {\n            throw new TypeError(\"Parameters must be numbers\");\n        }\n\n        const MAX = 20;\n        const K = 3;\n        const TOLERANCE = 1e-6;\n        const s = new Array(MAX + 1);\n        const h = new Array(MAX + 1);\n        let result = {y: 0, dy: 0};\n\n        h[0] = 1.0;\n\n        for (let j = 1; j <= MAX; j++) {\n            s[j - 1] = this.trapezoid(min, max, j);\n\n            if (j >= K) {\n                result = Polynomial.interpolate(h, s, K, j - K, 0.0);\n                if (Math.abs(result.dy) <= TOLERANCE * result.y) {\n                    break;\n                }\n            }\n\n            s[j] = s[j - 1];\n            h[j] = 0.25 * h[j - 1];\n        }\n\n        return result.y;\n    }\n\n    /**\n     *  Estimate what is the maximum polynomial evaluation error value under which polynomial evaluation could be in fact 0.\n     *\n     *  @param {number} maxAbsX\n     *  @returns {number}\n     */\n    zeroErrorEstimate(maxAbsX) {\n        const poly = this;\n        const ERRF = 1e-15;\n\n        if (typeof maxAbsX === \"undefined\") {\n            const rb = poly.bounds();\n\n            maxAbsX = Math.max(Math.abs(rb.minX), Math.abs(rb.maxX));\n        }\n\n        if (maxAbsX < 0.001) {\n            return 2 * Math.abs(poly.eval(ERRF));\n        }\n\n        const n = poly.coefs.length - 1;\n        const an = poly.coefs[n];\n\n        return 10 * ERRF * poly.coefs.reduce((m, v, i) => {\n            const nm = v / an * Math.pow(maxAbsX, i);\n            return nm > m ? nm : m;\n        }, 0);\n    }\n\n    /**\n     *  Calculates upper Real roots bounds. <br/>\n     *  Real roots are in interval [negX, posX]. Determined by Fujiwara method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ negX: number, posX: number }}\n     */\n    boundsUpperRealFujiwara() {\n        let a = this.coefs;\n        const n = a.length - 1;\n        const an = a[n];\n\n        if (an !== 1) {\n            a = this.coefs.map(v => v / an);\n        }\n\n        const b = a.map((v, i) => {\n            return (i < n)\n                ? Math.pow(Math.abs((i === 0) ? v / 2 : v), 1 / (n - i))\n                : v;\n        });\n\n        let coefSelectionFunc;\n        const find2Max = function(acc, bi, i) {\n            if (coefSelectionFunc(i)) {\n                if (acc.max < bi) {\n                    acc.nearmax = acc.max;\n                    acc.max = bi;\n                }\n                else if (acc.nearmax < bi) {\n                    acc.nearmax = bi;\n                }\n            }\n            return acc;\n        };\n\n        coefSelectionFunc = function(i) {\n            return i < n && a[i] < 0;\n        };\n\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        const max_nearmax_pos = b.reduce(find2Max, {max: 0, nearmax: 0});\n\n        coefSelectionFunc = function(i) {\n            return i < n && ((n % 2 === i % 2) ? a[i] < 0 : a[i] > 0);\n        };\n\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        const max_nearmax_neg = b.reduce(find2Max, {max: 0, nearmax: 0});\n\n        return {\n            negX: -2 * max_nearmax_neg.max,\n            posX: 2 * max_nearmax_pos.max\n        };\n    }\n\n    /**\n     *  Calculates lower Real roots bounds. <br/>\n     *  There are no Real roots in interval <negX, posX>. Determined by Fujiwara method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ negX: number, posX: number }}\n     */\n    boundsLowerRealFujiwara() {\n        const poly = new Polynomial();\n\n        poly.coefs = this.coefs.slice().reverse();\n\n        const res = poly.boundsUpperRealFujiwara();\n\n        res.negX = 1 / res.negX;\n        res.posX = 1 / res.posX;\n\n        return res;\n    }\n\n    /**\n     *  Calculates left and right Real roots bounds. <br/>\n     *  Real roots are in interval [minX, maxX]. Combines Fujiwara lower and upper bounds to get minimal interval.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ minX: number, maxX: number }}\n    */\n    bounds() {\n        const urb = this.boundsUpperRealFujiwara();\n        const rb = {minX: urb.negX, maxX: urb.posX};\n\n        if (urb.negX === 0 && urb.posX === 0) {\n            return rb;\n        }\n\n        if (urb.negX === 0) {\n            rb.minX = this.boundsLowerRealFujiwara().posX;\n        }\n        else if (urb.posX === 0) {\n            rb.maxX = this.boundsLowerRealFujiwara().negX;\n        }\n\n        if (rb.minX > rb.maxX) {\n            rb.minX = rb.maxX = 0;\n        }\n\n        return rb;\n        // TODO: if sure that there are no complex roots\n        // (maybe by using Sturm's theorem) use:\n        // return this.boundsRealLaguerre();\n    }\n\n    /**\n     *  Calculates absolute upper roots bound. <br/>\n     *  All (Complex and Real) roots magnitudes are &lt;= result. Determined by Rouche method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {number}\n     */\n    boundUpperAbsRouche() {\n        const a = this.coefs;\n        const n = a.length - 1;\n        const max = a.reduce((prev, curr, i) => {\n            if (i !== n) {\n                curr = Math.abs(curr);\n                return (prev < curr) ? curr : prev;\n            }\n            return prev;\n        }, 0);\n\n        return 1 + max / Math.abs(a[n]);\n    }\n\n    /**\n     *  Calculates absolute lower roots bound. <br/>\n     *  All (Complex and Real) roots magnitudes are &gt;= result. Determined by Rouche method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {number}\n     */\n    boundLowerAbsRouche() {\n        const a = this.coefs;\n        const max = a.reduce((prev, curr, i) => {\n            if (i !== 0) {\n                curr = Math.abs(curr);\n                return (prev < curr) ? curr : prev;\n            }\n            return prev;\n        }, 0);\n\n        return Math.abs(a[0]) / (Math.abs(a[0]) + max);\n    }\n\n    /**\n     *  Calculates left and right Real roots bounds.<br/>\n     *  WORKS ONLY if all polynomial roots are Real.\n     *  Real roots are in interval [minX, maxX]. Determined by Laguerre method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ minX: number, maxX: number }}\n     */\n    boundsRealLaguerre() {\n        const a = this.coefs;\n        const n = a.length - 1;\n        const p1 = -a[n - 1] / (n * a[n]);\n        const undersqrt = a[n - 1] * a[n - 1] - 2 * n / (n - 1) * a[n] * a[n - 2];\n        let p2 = (n - 1) / (n * a[n]) * Math.sqrt(undersqrt);\n\n        if (p2 < 0) {\n            p2 = -p2;\n        }\n\n        return {\n            minX: p1 - p2,\n            maxX: p1 + p2\n        };\n    }\n\n    /**\n     *  Root count by Descartes rule of signs. <br/>\n     *  Returns maximum number of positive and negative real roots and minimum number of complex roots.\n     *  @see {@link http://en.wikipedia.org/wiki/Descartes%27_rule_of_signs}\n     *\n     *  @returns {{maxRealPos: number, maxRealNeg: number, minComplex: number}}\n     */\n    countRootsDescartes() {\n        const a = this.coefs;\n        const n = a.length - 1;\n        const accum = a.reduce((acc, ai, i) => {\n            if (acc.prev_a !== 0 && ai !== 0) {\n                if ((acc.prev_a < 0) === (ai > 0)) {\n                    acc.pos++;\n                }\n                if (((i % 2 === 0) !== (acc.prev_a < 0)) === ((i % 2 === 1) !== (ai > 0))) {\n                    acc.neg++;\n                }\n            }\n            acc.prev_a = ai;\n            return acc;\n        }, {pos: 0, neg: 0, prev_a: 0});\n\n        return {\n            maxRealPos: accum.pos,\n            maxRealNeg: accum.neg,\n            minComplex: n - (accum.pos + accum.neg)\n        };\n    }\n\n    // getters and setters\n\n    /**\n     *  get degree\n     *\n     *  @returns {number}\n     */\n    getDegree() {\n        return this.coefs.length - 1;\n    }\n\n    /**\n     *  getDerivative\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    getDerivative() {\n        const derivative = new Polynomial();\n\n        for (let i = 1; i < this.coefs.length; i++) {\n            derivative.coefs.push(i * this.coefs[i]);\n        }\n\n        return derivative;\n    }\n\n    /**\n     *  getRoots\n     *\n     *  @returns {Array<number>}\n     */\n    getRoots() {\n        let result;\n\n        this.simplifyEquals();\n\n        switch (this.getDegree()) {\n            case 0: result = []; break;\n            case 1: result = this.getLinearRoot(); break;\n            case 2: result = this.getQuadraticRoots(); break;\n            case 3: result = this.getCubicRoots(); break;\n            case 4: result = this.getQuarticRoots(); break;\n            default:\n                result = [];\n        }\n\n        return result;\n    }\n\n    /**\n     *  getRootsInInterval\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {Array<number>}\n     */\n    getRootsInInterval(min, max) {\n        const roots = [];\n\n        /**\n         *  @param {number} value\n         */\n        function push(value) {\n            if (typeof value === \"number\") {\n                roots.push(value);\n            }\n        }\n\n        if (this.getDegree() === 0) {\n            throw new RangeError(\"Unexpected empty polynomial\");\n        }\n        else if (this.getDegree() === 1) {\n            push(this.bisection(min, max));\n        }\n        else {\n            // get roots of derivative\n            const deriv = this.getDerivative();\n            const droots = deriv.getRootsInInterval(min, max);\n\n            if (droots.length > 0) {\n                // find root on [min, droots[0]]\n                push(this.bisection(min, droots[0]));\n\n                // find root on [droots[i],droots[i+1]] for 0 <= i <= count-2\n                for (let i = 0; i <= droots.length - 2; i++) {\n                    push(this.bisection(droots[i], droots[i + 1]));\n                }\n\n                // find root on [droots[count-1],xmax]\n                push(this.bisection(droots[droots.length - 1], max));\n            }\n            else {\n                // polynomial is monotone on [min,max], has at most one root\n                push(this.bisection(min, max));\n            }\n        }\n\n        return roots;\n    }\n\n    /**\n     *  getLinearRoot\n     *\n     *  @returns {number}\n     */\n    getLinearRoot() {\n        const result = [];\n        const a = this.coefs[1];\n\n        if (a !== 0) {\n            result.push(-this.coefs[0] / a);\n        }\n\n        return result;\n    }\n\n    /**\n     *  getQuadraticRoots\n     *\n     *  @returns {Array<number>}\n     */\n    getQuadraticRoots() {\n        const results = [];\n\n        if (this.getDegree() === 2) {\n            const a = this.coefs[2];\n            const b = this.coefs[1] / a;\n            const c = this.coefs[0] / a;\n            const d = b * b - 4 * c;\n\n            if (d > 0) {\n                const e = Math.sqrt(d);\n\n                results.push(0.5 * (-b + e));\n                results.push(0.5 * (-b - e));\n            }\n            else if (d === 0) {\n                // really two roots with same value, but we only return one\n                results.push(0.5 * -b);\n            }\n            // else imaginary results\n        }\n\n        return results;\n    }\n\n    /**\n     *  getCubicRoots\n     *\n     *  This code is based on MgcPolynomial.cpp written by David Eberly.  His\n     *  code along with many other excellent examples are avaiable at his site:\n     *  http://www.geometrictools.com\n     *\n     *  @returns {Array<number>}\n     */\n    getCubicRoots() {\n        const results = [];\n\n        if (this.getDegree() === 3) {\n            const c3 = this.coefs[3];\n            const c2 = this.coefs[2] / c3;\n            const c1 = this.coefs[1] / c3;\n            const c0 = this.coefs[0] / c3;\n\n            const a = (3 * c1 - c2 * c2) / 3;\n            const b = (2 * c2 * c2 * c2 - 9 * c1 * c2 + 27 * c0) / 27;\n            const offset = c2 / 3;\n            let discrim = b * b / 4 + a * a * a / 27;\n            const halfB = b / 2;\n\n            const ZEROepsilon = this.zeroErrorEstimate();\n\n            if (Math.abs(discrim) <= ZEROepsilon) {\n                discrim = 0;\n            }\n\n            if (discrim > 0) {\n                const e = Math.sqrt(discrim);\n                let root; // eslint-disable-line no-shadow\n\n                let tmp = -halfB + e;\n\n                if (tmp >= 0) {\n                    root = Math.pow(tmp, 1 / 3);\n                }\n                else {\n                    root = -Math.pow(-tmp, 1 / 3);\n                }\n\n                tmp = -halfB - e;\n\n                if (tmp >= 0) {\n                    root += Math.pow(tmp, 1 / 3);\n                }\n                else {\n                    root -= Math.pow(-tmp, 1 / 3);\n                }\n\n                results.push(root - offset);\n            }\n            else if (discrim < 0) {\n                const distance = Math.sqrt(-a / 3);\n                const angle = Math.atan2(Math.sqrt(-discrim), -halfB) / 3;\n                const cos = Math.cos(angle);\n                const sin = Math.sin(angle);\n                const sqrt3 = Math.sqrt(3);\n\n                results.push(2 * distance * cos - offset);\n                results.push(-distance * (cos + sqrt3 * sin) - offset);\n                results.push(-distance * (cos - sqrt3 * sin) - offset);\n            }\n            else {\n                let tmp;\n\n                if (halfB >= 0) {\n                    tmp = -Math.pow(halfB, 1 / 3);\n                }\n                else {\n                    tmp = Math.pow(-halfB, 1 / 3);\n                }\n\n                results.push(2 * tmp - offset);\n                // really should return next root twice, but we return only one\n                results.push(-tmp - offset);\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     *  Calculates roots of quartic polynomial. <br/>\n     *  First, derivative roots are found, then used to split quartic polynomial\n     *  into segments, each containing one root of quartic polynomial.\n     *  Segments are then passed to newton's method to find roots.\n     *\n     *  @returns {Array<number>} roots\n     */\n    getQuarticRoots() {\n        let results = [];\n        const n = this.getDegree();\n\n        if (n === 4) {\n            const poly = new Polynomial();\n\n            poly.coefs = this.coefs.slice();\n            poly.divideEqualsScalar(poly.coefs[n]);\n\n            const ERRF = 1e-15;\n\n            if (Math.abs(poly.coefs[0]) < 10 * ERRF * Math.abs(poly.coefs[3])) {\n                poly.coefs[0] = 0;\n            }\n\n            const poly_d = poly.getDerivative();\n            const derrt = poly_d.getRoots().sort((a, b) => a - b);\n            const dery = [];\n            const nr = derrt.length - 1;\n            const rb = this.bounds();\n\n            const maxabsX = Math.max(Math.abs(rb.minX), Math.abs(rb.maxX));\n            const ZEROepsilon = this.zeroErrorEstimate(maxabsX);\n\n            for (let i = 0; i <= nr; i++) {\n                dery.push(poly.eval(derrt[i]));\n            }\n\n            for (let i = 0; i <= nr; i++) {\n                if (Math.abs(dery[i]) < ZEROepsilon) {\n                    dery[i] = 0;\n                }\n            }\n\n            let i = 0;\n            const dx = Math.max(0.1 * (rb.maxX - rb.minX) / n, ERRF);\n            const guesses = [];\n            const minmax = [];\n\n            if (nr > -1) {\n                if (dery[0] !== 0) {\n                    if (sign(dery[0]) !== sign(poly.eval(derrt[0] - dx) - dery[0])) {\n                        guesses.push(derrt[0] - dx);\n                        minmax.push([rb.minX, derrt[0]]);\n                    }\n                }\n                else {\n                    results.push(derrt[0], derrt[0]);\n                    i++;\n                }\n\n                for (; i < nr; i++) {\n                    if (dery[i + 1] === 0) {\n                        results.push(derrt[i + 1], derrt[i + 1]);\n                        i++;\n                    }\n                    else if (sign(dery[i]) !== sign(dery[i + 1])) {\n                        guesses.push((derrt[i] + derrt[i + 1]) / 2);\n                        minmax.push([derrt[i], derrt[i + 1]]);\n                    }\n                }\n                if (dery[nr] !== 0 && sign(dery[nr]) !== sign(poly.eval(derrt[nr] + dx) - dery[nr])) {\n                    guesses.push(derrt[nr] + dx);\n                    minmax.push([derrt[nr], rb.maxX]);\n                }\n            }\n\n            /**\n             *  @param {number} x\n             *  @returns {number}\n             */\n            const f = function(x) {\n                return poly.eval(x);\n            };\n\n            /**\n             *  @param {number} x\n             *  @returns {number}\n             */\n            const df = function(x) {\n                return poly_d.eval(x);\n            };\n\n            if (guesses.length > 0) {\n                for (i = 0; i < guesses.length; i++) {\n                    guesses[i] = Polynomial.newtonSecantBisection(guesses[i], f, df, 32, minmax[i][0], minmax[i][1]);\n                }\n            }\n\n            results = results.concat(guesses);\n        }\n\n        return results;\n    }\n}\n\nexport default Polynomial;\n","/**\n *  SqrtPolynomial.js\n *\n *  @module SqrtPolynomial\n *  @copyright 2002-2019 Kevin Lindsey\n */\n\nimport Polynomial from \"./Polynomial.js\";\n\n/**\n *  SqrtPolynomial\n *\n *  @deprecated\n *  @memberof module:kld-polynomial\n */\nclass SqrtPolynomial extends Polynomial {\n    /**\n     *  eval\n     *\n     *  @param {number} x\n     *  @returns {number}\n     */\n    eval(x) {\n        const TOLERANCE = 1e-7;\n\n        let result = super.eval(x);\n\n        // NOTE: May need to change the following.  I added these to capture\n        // some really small negative values that were being generated by one\n        // of my Bezier arcLength functions\n        if (Math.abs(result) < TOLERANCE) {\n            result = 0;\n        }\n\n        if (result < 0) {\n            throw new RangeError(\"Cannot take square root of negative number\");\n        }\n\n        return Math.sqrt(result);\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        const result = super.toString();\n\n        return \"sqrt(\" + result + \")\";\n    }\n}\n\nexport default SqrtPolynomial;\n"],"names":["sign","x","NaN","Polynomial","coefs","i","arguments","length","push","_variable","_s","poly","this","slice","isNaN","TypeError","result","that","d1","getDegree","d2","dmax","Math","max","v1","v2","j","scalar","TOLERANCE","abs","pop","c","err","reduce","pv","cv","divideEqualsScalar","signs","value","round","signString","min","ACCURACY","minValue","eval","maxValue","tmp1","log","tmp2","LN10","maxIterations","ceil","LN2","n","range","iter","delta","sum","st","t","s","os","ost","Array","MAX","h","y","dy","trapezoid","interpolate","maxAbsX","rb","bounds","minX","maxX","an","m","v","nm","pow","a","map","coefSelectionFunc","b","find2Max","acc","bi","nearmax","max_nearmax_pos","negX","posX","reverse","res","boundsUpperRealFujiwara","urb","boundsLowerRealFujiwara","prev","curr","p1","undersqrt","p2","sqrt","accum","ai","prev_a","pos","neg","maxRealPos","maxRealNeg","minComplex","derivative","simplifyEquals","getLinearRoot","getQuadraticRoots","getCubicRoots","getQuarticRoots","roots","RangeError","bisection","droots","getDerivative","getRootsInInterval","results","d","e","c3","c2","c1","offset","discrim","halfB","ZEROepsilon","zeroErrorEstimate","root","tmp","distance","angle","atan2","cos","sin","sqrt3","poly_d","derrt","getRoots","sort","dery","nr","maxabsX","dx","guesses","minmax","f","df","newtonSecantBisection","concat","xs","ys","constructor","ns","diff","dift","ho","hp","w","den","x0","max_iterations","dfx","x_correction","x_new","y_atmin","y_atmax","prev_dfx","prev_x_ef_correction","min_correction_factor","isBounded","isEnoughCorrection","SqrtPolynomial"],"mappings":"6sCAkBA,SAASA,EAAKC,SAEU,iBAANA,EAAiBA,EAAIA,EAAI,GAAK,EAAI,EAAIA,GAAMA,EAAIA,EAAIC,IAAMA,QAQtEC,yCAQOC,MAAQ,OAER,IAAIC,EAAIC,UAAMC,OAAS,EAAGF,GAAK,EAAGA,SAC9BD,MAAMI,KAAWH,uBAAAA,mBAAAA,SAGrBI,UAAY,SACZC,GAAK,gDA8LJC,EAAO,IAAIR,SAEjBQ,EAAKP,MAAQQ,KAAKR,MAAMS,QAEjBF,+BAQNV,MACGa,MAAMb,SACA,IAAIc,uDAAgDd,gBAG1De,EAAS,EAEJX,EAAIO,KAAKR,MAAMG,OAAS,EAAGF,GAAK,EAAGA,IACxCW,EAASA,EAASf,EAAIW,KAAKR,MAAMC,UAG9BW,8BASPC,WACMD,EAAS,IAAIb,EACbe,EAAKN,KAAKO,YACVC,EAAKH,EAAKE,YACVE,EAAOC,KAAKC,IAAIL,EAAIE,GAEjBf,EAAI,EAAGA,GAAKgB,EAAMhB,IAAK,KACtBmB,EAAMnB,GAAKa,EAAMN,KAAKR,MAAMC,GAAK,EACjCoB,EAAMpB,GAAKe,EAAMH,EAAKb,MAAMC,GAAK,EAEvCW,EAAOZ,MAAMC,GAAKmB,EAAKC,SAGpBT,mCASFC,WACCD,EAAS,IAAIb,EAEVE,EAAI,EAAGA,GAAKO,KAAKO,YAAcF,EAAKE,YAAad,IACtDW,EAAOZ,MAAMI,KAAK,OAGjB,IAAIH,EAAI,EAAGA,GAAKO,KAAKO,YAAad,QAC9B,IAAIqB,EAAI,EAAGA,GAAKT,EAAKE,YAAaO,IACnCV,EAAOZ,MAAMC,EAAIqB,IAAMd,KAAKR,MAAMC,GAAKY,EAAKb,MAAMsB,UAInDV,6CASQW,OACV,IAAItB,EAAI,EAAGA,EAAIO,KAAKR,MAAMG,OAAQF,SAC9BD,MAAMC,IAAMsB,mDAUVC,yDAAY,MACdvB,EAAIO,KAAKO,YAAad,GAAK,GAC5BiB,KAAKO,IAAIjB,KAAKR,MAAMC,KAAOuB,EADIvB,SAE1BD,MAAM0B,0DAeLF,yDAAY,MACpBG,EAAInB,KAAKR,MACT4B,EAAM,GAAKJ,EAAYN,KAAKO,IAC9BE,EAAEE,OAAO,SAACC,EAAIC,UACHb,KAAKO,IAAIM,GAAMb,KAAKO,IAAIK,GAAMC,EAAKD,KAIzC7B,EAAI,EAAGA,EAAI0B,EAAExB,OAAS,EAAGF,IAC1BiB,KAAKO,IAAIE,EAAE1B,IAAM2B,IACjBD,EAAE1B,GAAK,UAIRO,+CAUDmB,EAAInB,KAAKR,aAES,IAApB2B,EAAEA,EAAExB,OAAS,SACR6B,mBAAmBL,EAAEA,EAAExB,OAAS,IAGlCK,gDASDR,EAAQ,GACRiC,EAAQ,GAELhC,EAAIO,KAAKR,MAAMG,OAAS,EAAGF,GAAK,EAAGA,IAAK,KACzCiC,EAAQhB,KAAKiB,MAAsB,IAAhB3B,KAAKR,MAAMC,IAAa,OAEjC,IAAViC,EAAa,KACPE,EAAcF,EAAQ,EAAK,MAAQ,MAEzCA,EAAQhB,KAAKO,IAAIS,GAEbjC,EAAI,IACU,IAAViC,EACAA,EAAQ1B,KAAKH,UAGb6B,GAAS1B,KAAKH,WAIlBJ,EAAI,IACJiC,GAAS,IAAMjC,GAGnBgC,EAAM7B,KAAKgC,GACXpC,EAAMI,KAAK8B,IAInBD,EAAM,GAAmB,QAAbA,EAAM,GAAgB,GAAK,YAEnCrB,EAAS,GAEJX,EAAI,EAAGA,EAAID,EAAMG,OAAQF,IAC9BW,GAAUqB,EAAMhC,GAAKD,EAAMC,UAGxBW,oCAYDyB,EAAKlB,OAGPP,EAHYY,yDAAY,KAAMc,yDAAW,GACzCC,EAAW/B,KAAKgC,KAAKH,GACrBI,EAAWjC,KAAKgC,KAAKrB,MAGrBD,KAAKO,IAAIc,IAAaf,EACtBZ,EAASyB,OAER,GAAInB,KAAKO,IAAIgB,IAAajB,EAC3BZ,EAASO,OAER,GAAIoB,EAAWE,GAAY,UACtBC,EAAOxB,KAAKyB,IAAIxB,EAAMkB,GACtBO,EAAO1B,KAAK2B,KAAOP,EACnBQ,EAAgB5B,KAAK6B,MAAML,EAAOE,GAAQ1B,KAAK8B,KAE5C/C,EAAI,EAAGA,EAAI6C,EAAe7C,IAAK,CACpCW,EAAS,IAAOyB,EAAMlB,OAChBe,EAAQ1B,KAAKgC,KAAK5B,MAEpBM,KAAKO,IAAIS,IAAUV,QAInBU,EAAQK,EAAW,GACnBpB,EAAMP,EACN6B,EAAWP,IAGXG,EAAMzB,EACN2B,EAAWL,UAKhBtB,oCAWDyB,EAAKlB,EAAK8B,MACZvC,MAAM2B,IAAQ3B,MAAMS,IAAQT,MAAMuC,SAC5B,IAAItC,UAAU,kCAGlBuC,EAAQ/B,EAAMkB,KAEV,IAANY,EAAS,KACHV,EAAW/B,KAAKgC,KAAKH,GACrBI,EAAWjC,KAAKgC,KAAKrB,QAEtBb,GAAK,GAAM4C,GAASX,EAAWE,OAEnC,SACKU,EAAO,GAAMF,EAAI,EACjBG,EAAQF,EAAQC,EAClBtD,EAAIwC,EAAM,GAAMe,EAChBC,EAAM,EAEDpD,EAAI,EAAGA,EAAIkD,EAAMlD,IACtBoD,GAAO7C,KAAKgC,KAAK3C,GACjBA,GAAKuD,OAGJ9C,GAAK,IAAOE,KAAKF,GAAK4C,EAAQG,EAAMF,MAGzCzC,MAAMF,KAAKF,UACL,IAAIK,UAAU,yBAGjBH,KAAKF,mCAUR+B,EAAKlB,MACLT,MAAM2B,IAAQ3B,MAAMS,SACd,IAAIR,UAAU,sCAGlBuC,EAAQ/B,EAAMkB,EAChBiB,EAAK,GAAMJ,GAAS1C,KAAKgC,KAAKH,GAAO7B,KAAKgC,KAAKrB,IAC/CoC,EAAID,EACJE,EAAI,EAAMF,EAAK,EACfG,EAAKD,EACLE,EAAMJ,EAGNH,EAAO,EAEFF,EAAI,EAAGA,GAAK,GAAIA,IAAK,SACpBG,EAAQF,EAAQC,EAClBtD,EAAIwC,EAAM,GAAMe,EAChBC,EAAM,EAEDpD,EAAI,EAAGA,GAAKkD,EAAMlD,IACvBoD,GAAO7C,KAAKgC,KAAK3C,GACjBA,GAAKuD,KAKTI,GAAK,GADLF,EADAC,EAAI,IAAOA,EAAIL,EAAQG,EAAMF,IAEbO,GAAO,EAEnBxC,KAAKO,IAAI+B,EAAIC,GAlBH,KAkBqBvC,KAAKO,IAAIgC,SAI5CA,EAAKD,EACLE,EAAMJ,EACNH,IAAS,SAGNK,kCAUHnB,EAAKlB,MACLT,MAAM2B,IAAQ3B,MAAMS,SACd,IAAIR,UAAU,kCAMlB6C,EAAI,IAAIG,MAAMC,IACdC,EAAI,IAAIF,MAAMC,IAChBhD,EAAS,CAACkD,EAAG,EAAGC,GAAI,GAExBF,EAAE,GAAK,MAEF,IAAIvC,EAAI,EAAGA,GATJ,KAURkC,EAAElC,EAAI,GAAKd,KAAKwD,UAAU3B,EAAKlB,EAAKG,KAEhCA,GAXE,IAYFV,EAASb,EAAWkE,YAAYJ,EAAGL,EAZjC,EAYuClC,EAZvC,EAY8C,GAC5CJ,KAAKO,IAAIb,EAAOmD,KAZV,KAY6BnD,EAAOkD,KAL5BxC,IAUtBkC,EAAElC,GAAKkC,EAAElC,EAAI,GACbuC,EAAEvC,GAAK,IAAOuC,EAAEvC,EAAI,UAGjBV,EAAOkD,4CASAI,WAIS,IAAZA,EAAyB,KAC1BC,EAJG3D,KAIO4D,SAEhBF,EAAUhD,KAAKC,IAAID,KAAKO,IAAI0C,EAAGE,MAAOnD,KAAKO,IAAI0C,EAAGG,UAGlDJ,EAAU,YACH,EAAIhD,KAAKO,IAVPjB,KAUgBgC,KAThB,YAYPS,EAbOzC,KAaER,MAAMG,OAAS,EACxBoE,EAdO/D,KAcGR,MAAMiD,UAEf,GAfM,MADAzC,KAgBWR,MAAM6B,OAAO,SAAC2C,EAAGC,EAAGxE,OAClCyE,EAAKD,EAAIF,EAAKrD,KAAKyD,IAAIT,EAASjE,UAC/ByE,EAAKF,EAAIE,EAAKF,GACtB,yDAWCI,EAAIpE,KAAKR,MACPiD,EAAI2B,EAAEzE,OAAS,EACfoE,EAAKK,EAAE3B,GAEF,IAAPsB,IACAK,EAAIpE,KAAKR,MAAM6E,IAAI,SAAAJ,UAAKA,EAAIF,SAS5BO,EANEC,EAAIH,EAAEC,IAAI,SAACJ,EAAGxE,UACRA,EAAIgD,EACN/B,KAAKyD,IAAIzD,KAAKO,IAAW,IAANxB,EAAWwE,EAAI,EAAIA,GAAI,GAAKxB,EAAIhD,IACnDwE,IAIJO,EAAW,SAASC,EAAKC,EAAIjF,UAC3B6E,EAAkB7E,KACdgF,EAAI9D,IAAM+D,GACVD,EAAIE,QAAUF,EAAI9D,IAClB8D,EAAI9D,IAAM+D,GAELD,EAAIE,QAAUD,IACnBD,EAAIE,QAAUD,IAGfD,GAGXH,EAAoB,SAAS7E,UAClBA,EAAIgD,GAAK2B,EAAE3E,GAAK,OAIrBmF,EAAkBL,EAAElD,OAAOmD,EAAU,CAAC7D,IAAK,EAAGgE,QAAS,WAE7DL,EAAoB,SAAS7E,UAClBA,EAAIgD,IAAOA,EAAI,GAAMhD,EAAI,EAAK2E,EAAE3E,GAAK,EAAI2E,EAAE3E,GAAK,IAMpD,CACHoF,MAAO,EAHaN,EAAElD,OAAOmD,EAAU,CAAC7D,IAAK,EAAGgE,QAAS,IAG9BhE,IAC3BmE,KAAM,EAAIF,EAAgBjE,2DAYxBZ,EAAO,IAAIR,EAEjBQ,EAAKP,MAAQQ,KAAKR,MAAMS,QAAQ8E,cAE1BC,EAAMjF,EAAKkF,iCAEjBD,EAAIH,KAAO,EAAIG,EAAIH,KACnBG,EAAIF,KAAO,EAAIE,EAAIF,KAEZE,uCAWDE,EAAMlF,KAAKiF,0BACXtB,EAAK,CAACE,KAAMqB,EAAIL,KAAMf,KAAMoB,EAAIJ,aAErB,IAAbI,EAAIL,MAA2B,IAAbK,EAAIJ,KACfnB,GAGM,IAAbuB,EAAIL,KACJlB,EAAGE,KAAO7D,KAAKmF,0BAA0BL,KAEvB,IAAbI,EAAIJ,OACTnB,EAAGG,KAAO9D,KAAKmF,0BAA0BN,MAGzClB,EAAGE,KAAOF,EAAGG,OACbH,EAAGE,KAAOF,EAAGG,KAAO,GAGjBH,qDAcDS,EAAIpE,KAAKR,MACTiD,EAAI2B,EAAEzE,OAAS,SASd,EARKyE,EAAE/C,OAAO,SAAC+D,EAAMC,EAAM5F,UAC1BA,IAAMgD,GAEE2C,GADRC,EAAO3E,KAAKO,IAAIoE,IACOA,EAEpBD,GACR,GAEc1E,KAAKO,IAAImD,EAAE3B,sDAWtB2B,EAAIpE,KAAKR,MACTmB,EAAMyD,EAAE/C,OAAO,SAAC+D,EAAMC,EAAM5F,UACpB,IAANA,GAEQ2F,GADRC,EAAO3E,KAAKO,IAAIoE,IACOA,EAEpBD,GACR,UAEI1E,KAAKO,IAAImD,EAAE,KAAO1D,KAAKO,IAAImD,EAAE,IAAMzD,oDAYpCyD,EAAIpE,KAAKR,MACTiD,EAAI2B,EAAEzE,OAAS,EACf2F,GAAMlB,EAAE3B,EAAI,IAAMA,EAAI2B,EAAE3B,IACxB8C,EAAYnB,EAAE3B,EAAI,GAAK2B,EAAE3B,EAAI,GAAK,EAAIA,GAAKA,EAAI,GAAK2B,EAAE3B,GAAK2B,EAAE3B,EAAI,GACnE+C,GAAM/C,EAAI,IAAMA,EAAI2B,EAAE3B,IAAM/B,KAAK+E,KAAKF,UAEtCC,EAAK,IACLA,GAAMA,GAGH,CACH3B,KAAMyB,EAAKE,EACX1B,KAAMwB,EAAKE,qDAYTpB,EAAIpE,KAAKR,MACTiD,EAAI2B,EAAEzE,OAAS,EACf+F,EAAQtB,EAAE/C,OAAO,SAACoD,EAAKkB,EAAIlG,UACV,IAAfgF,EAAImB,QAAuB,IAAPD,IACflB,EAAImB,OAAS,GAAQD,EAAK,GAC3BlB,EAAIoB,MAEFpG,EAAI,GAAM,GAAQgF,EAAImB,OAAS,IAAUnG,EAAI,GAAM,GAAQkG,EAAK,IAClElB,EAAIqB,OAGZrB,EAAImB,OAASD,EACNlB,GACR,CAACoB,IAAK,EAAGC,IAAK,EAAGF,OAAQ,UAErB,CACHG,WAAYL,EAAMG,IAClBG,WAAYN,EAAMI,IAClBG,WAAYxD,GAAKiD,EAAMG,IAAMH,EAAMI,iDAYhC9F,KAAKR,MAAMG,OAAS,kDASrBuG,EAAa,IAAI3G,EAEdE,EAAI,EAAGA,EAAIO,KAAKR,MAAMG,OAAQF,IACnCyG,EAAW1G,MAAMI,KAAKH,EAAIO,KAAKR,MAAMC,WAGlCyG,yCASH9F,cAEC+F,iBAEGnG,KAAKO,kBACJ,EAAGH,EAAS,cACZ,EAAGA,EAASJ,KAAKoG,2BACjB,EAAGhG,EAASJ,KAAKqG,+BACjB,EAAGjG,EAASJ,KAAKsG,2BACjB,EAAGlG,EAASJ,KAAKuG,gCAElBnG,EAAS,UAGVA,6CAUQyB,EAAKlB,OACd6F,EAAQ,YAKL5G,EAAK8B,GACW,iBAAVA,GACP8E,EAAM5G,KAAK8B,MAIM,IAArB1B,KAAKO,kBACC,IAAIkG,WAAW,+BAEpB,GAAyB,IAArBzG,KAAKO,YACVX,EAAKI,KAAK0G,UAAU7E,EAAKlB,QAExB,KAGKgG,EADQ3G,KAAK4G,gBACEC,mBAAmBhF,EAAKlB,MAEzCgG,EAAOhH,OAAS,EAAG,CAEnBC,EAAKI,KAAK0G,UAAU7E,EAAK8E,EAAO,SAG3B,IAAIlH,EAAI,EAAGA,GAAKkH,EAAOhH,OAAS,EAAGF,IACpCG,EAAKI,KAAK0G,UAAUC,EAAOlH,GAAIkH,EAAOlH,EAAI,KAI9CG,EAAKI,KAAK0G,UAAUC,EAAOA,EAAOhH,OAAS,GAAIgB,SAI/Cf,EAAKI,KAAK0G,UAAU7E,EAAKlB,WAI1B6F,8CASDpG,EAAS,GACTgE,EAAIpE,KAAKR,MAAM,UAEX,IAAN4E,GACAhE,EAAOR,MAAMI,KAAKR,MAAM,GAAK4E,GAG1BhE,kDASD0G,EAAU,MAES,IAArB9G,KAAKO,YAAmB,KAClB6D,EAAIpE,KAAKR,MAAM,GACf+E,EAAIvE,KAAKR,MAAM,GAAK4E,EAEpB2C,EAAIxC,EAAIA,EAAI,GADRvE,KAAKR,MAAM,GAAK4E,MAGtB2C,EAAI,EAAG,KACDC,EAAItG,KAAK+E,KAAKsB,GAEpBD,EAAQlH,KAAK,KAAQ2E,EAAIyC,IACzBF,EAAQlH,KAAK,KAAQ2E,EAAIyC,SAEd,IAAND,GAELD,EAAQlH,KAAK,IAAO2E,UAKrBuC,8CAaDA,EAAU,MAES,IAArB9G,KAAKO,YAAmB,KAClB0G,EAAKjH,KAAKR,MAAM,GAChB0H,EAAKlH,KAAKR,MAAM,GAAKyH,EACrBE,EAAKnH,KAAKR,MAAM,GAAKyH,EAGrB7C,GAAK,EAAI+C,EAAKD,EAAKA,GAAM,EACzB3C,GAAK,EAAI2C,EAAKA,EAAKA,EAAK,EAAIC,EAAKD,EAAK,IAHjClH,KAAKR,MAAM,GAAKyH,IAG4B,GACjDG,EAASF,EAAK,EAChBG,EAAU9C,EAAIA,EAAI,EAAIH,EAAIA,EAAIA,EAAI,GAChCkD,EAAQ/C,EAAI,EAEZgD,EAAcvH,KAAKwH,uBAErB9G,KAAKO,IAAIoG,IAAYE,IACrBF,EAAU,GAGVA,EAAU,EAAG,KAETI,EADET,EAAItG,KAAK+E,KAAK4B,GAGhBK,GAAOJ,EAAQN,EAGfS,EADAC,GAAO,EACAhH,KAAKyD,IAAIuD,EAAK,EAAI,IAGjBhH,KAAKyD,KAAKuD,EAAK,EAAI,IAG/BA,GAAOJ,EAAQN,IAEJ,EACPS,GAAQ/G,KAAKyD,IAAIuD,EAAK,EAAI,GAG1BD,GAAQ/G,KAAKyD,KAAKuD,EAAK,EAAI,GAG/BZ,EAAQlH,KAAK6H,EAAOL,QAEnB,GAAIC,EAAU,EAAG,KACZM,EAAWjH,KAAK+E,MAAMrB,EAAI,GAC1BwD,EAAQlH,KAAKmH,MAAMnH,KAAK+E,MAAM4B,IAAWC,GAAS,EAClDQ,EAAMpH,KAAKoH,IAAIF,GACfG,EAAMrH,KAAKqH,IAAIH,GACfI,EAAQtH,KAAK+E,KAAK,GAExBqB,EAAQlH,KAAK,EAAI+H,EAAWG,EAAMV,GAClCN,EAAQlH,MAAM+H,GAAYG,EAAME,EAAQD,GAAOX,GAC/CN,EAAQlH,MAAM+H,GAAYG,EAAME,EAAQD,GAAOX,OAE9C,KACGM,EAGAA,EADAJ,GAAS,GACF5G,KAAKyD,IAAImD,EAAO,EAAI,GAGrB5G,KAAKyD,KAAKmD,EAAO,EAAI,GAG/BR,EAAQlH,KAAK,EAAI8H,EAAMN,GAEvBN,EAAQlH,MAAM8H,EAAMN,WAIrBN,gDAYHA,EAAU,GACRrE,EAAIzC,KAAKO,eAEL,IAANkC,EAAS,KACH1C,EAAO,IAAIR,EAEjBQ,EAAKP,MAAQQ,KAAKR,MAAMS,QACxBF,EAAKyB,mBAAmBzB,EAAKP,MAAMiD,IAI/B/B,KAAKO,IAAIlB,EAAKP,MAAM,IAAM,GAFjB,MAE6BkB,KAAKO,IAAIlB,EAAKP,MAAM,MAC1DO,EAAKP,MAAM,GAAK,WAGdyI,EAASlI,EAAK6G,gBACdsB,EAAQD,EAAOE,WAAWC,KAAK,SAAChE,EAAGG,UAAMH,EAAIG,IAC7C8D,EAAO,GACPC,EAAKJ,EAAMvI,OAAS,EACpBgE,EAAK3D,KAAK4D,SAEV2E,EAAU7H,KAAKC,IAAID,KAAKO,IAAI0C,EAAGE,MAAOnD,KAAKO,IAAI0C,EAAGG,OAClDyD,EAAcvH,KAAKwH,kBAAkBe,GAElC9I,EAAI,EAAGA,GAAK6I,EAAI7I,IACrB4I,EAAKzI,KAAKG,EAAKiC,KAAKkG,EAAMzI,SAGzB,IAAIA,EAAI,EAAGA,GAAK6I,EAAI7I,IACjBiB,KAAKO,IAAIoH,EAAK5I,IAAM8H,IACpBc,EAAK5I,GAAK,OAIdA,EAAI,EACF+I,EAAK9H,KAAKC,IAAI,IAAOgD,EAAGG,KAAOH,EAAGE,MAAQpB,EA1BnC,OA2BPgG,EAAU,GACVC,EAAS,MAEXJ,GAAM,EAAG,KACO,IAAZD,EAAK,GACDjJ,EAAKiJ,EAAK,MAAQjJ,EAAKW,EAAKiC,KAAKkG,EAAM,GAAKM,GAAMH,EAAK,MACvDI,EAAQ7I,KAAKsI,EAAM,GAAKM,GACxBE,EAAO9I,KAAK,CAAC+D,EAAGE,KAAMqE,EAAM,OAIhCpB,EAAQlH,KAAKsI,EAAM,GAAIA,EAAM,IAC7BzI,KAGGA,EAAI6I,EAAI7I,IACS,IAAhB4I,EAAK5I,EAAI,IACTqH,EAAQlH,KAAKsI,EAAMzI,EAAI,GAAIyI,EAAMzI,EAAI,IACrCA,KAEKL,EAAKiJ,EAAK5I,MAAQL,EAAKiJ,EAAK5I,EAAI,MACrCgJ,EAAQ7I,MAAMsI,EAAMzI,GAAKyI,EAAMzI,EAAI,IAAM,GACzCiJ,EAAO9I,KAAK,CAACsI,EAAMzI,GAAIyI,EAAMzI,EAAI,MAGxB,IAAb4I,EAAKC,IAAalJ,EAAKiJ,EAAKC,MAASlJ,EAAKW,EAAKiC,KAAKkG,EAAMI,GAAME,GAAMH,EAAKC,MAC3EG,EAAQ7I,KAAKsI,EAAMI,GAAME,GACzBE,EAAO9I,KAAK,CAACsI,EAAMI,GAAK3E,EAAGG,YAQ7B6E,EAAI,SAAStJ,UACRU,EAAKiC,KAAK3C,IAOfuJ,EAAK,SAASvJ,UACT4I,EAAOjG,KAAK3C,OAGnBoJ,EAAQ9I,OAAS,MACZF,EAAI,EAAGA,EAAIgJ,EAAQ9I,OAAQF,IAC5BgJ,EAAQhJ,GAAKF,EAAWsJ,sBAAsBJ,EAAQhJ,GAAIkJ,EAAGC,EAAI,GAAIF,EAAOjJ,GAAG,GAAIiJ,EAAOjJ,GAAG,IAIrGqH,EAAUA,EAAQgC,OAAOL,UAGtB3B,wCA5kCQiC,EAAIC,EAAIvG,EAAG2E,EAAQ/H,MAC9B0J,EAAGE,cAAgB9F,OAAS6F,EAAGC,cAAgB9F,YACzC,IAAIhD,UAAU,+BAEpBD,MAAMuC,IAAMvC,MAAMkH,IAAWlH,MAAMb,SAC7B,IAAIc,UAAU,wCAGpBV,EAAG6D,EACHC,EAAK,EACHpC,EAAI,IAAIgC,MAAMV,GACdsE,EAAI,IAAI5D,MAAMV,GAChByG,EAAK,EAELC,EAAOzI,KAAKO,IAAI5B,EAAI0J,EAAG3B,QAEtB3H,EAAI,EAAGA,EAAIgD,EAAGhD,IAAK,KACd2J,EAAO1I,KAAKO,IAAI5B,EAAI0J,EAAG3B,EAAS3H,IAElC2J,EAAOD,IACPD,EAAKzJ,EACL0J,EAAOC,GAEXjI,EAAE1B,GAAKsH,EAAEtH,GAAKuJ,EAAG5B,EAAS3H,GAG9B6D,EAAI0F,EAAG5B,EAAS8B,GAChBA,QAEK,IAAIlF,EAAI,EAAGA,EAAIvB,EAAGuB,IAAK,KACnBvE,EAAI,EAAGA,EAAIgD,EAAIuB,EAAGvE,IAAK,KAClB4J,EAAKN,EAAG3B,EAAS3H,GAAKJ,EACtBiK,EAAKP,EAAG3B,EAAS3H,EAAIuE,GAAK3E,EAC1BkK,EAAIpI,EAAE1B,EAAI,GAAKsH,EAAEtH,GACnB+J,EAAMH,EAAKC,KAEH,IAARE,QACM,IAAI/C,WAAW,0FAGzB+C,EAAMD,EAAIC,EACVzC,EAAEtH,GAAK6J,EAAKE,EACZrI,EAAE1B,GAAK4J,EAAKG,EAIhBlG,GADAC,EAAM,GAAK2F,EAAK,GAAMzG,EAAIuB,EAAM7C,EAAE+H,EAAK,GAAKnC,EAAEmC,WAI3C,CAAC5F,EAAAA,EAAGC,GAAAA,iDAmBckG,EAAId,EAAGC,EAAIc,EAAgB7H,EAAKlB,OACrDtB,EAAiBsK,EAA+BC,EAAcC,EAC9DvG,EAAGwG,EAASC,EADTC,EAAW,EAAQC,EAAuB,EAGjD5K,EAAIoK,MAGES,EAAwBxJ,KAAKyD,IAAI,IADtB,IAEXgG,EAA4B,iBAARtI,GAAmC,iBAARlB,KAEjDwJ,EAAW,IACPtI,EAAMlB,QACA,IAAI8F,WAAW,mCAGzBqD,EAAUnB,EAAE9G,GACZkI,EAAUpB,EAAEhI,GAERvB,EAAK0K,KAAa1K,EAAK2K,SACjB,IAAItD,WAAW,uDAIvB2D,EAAqB,kBAEf1J,KAAKO,IAAI2I,IAAiBM,EAAwBxJ,KAAKO,IAAI5B,IAC9D4K,IAA0B5K,EAAIuK,EAAgBvK,GAG9CI,EAAI,EAAGA,EAAIiK,EAAgBjK,IAAK,IAGzB,KAFZkK,EAAMf,EAAGvJ,IAEM,IACM,IAAb2K,QAEM,IAAIvD,WAAW,iBAIrBkD,EAAMK,KAMdA,EAAWL,EACXrG,EAAIqF,EAAEtJ,GAENwK,EAAQxK,GADRuK,EAAetG,EAAIqG,GAGfS,aAIAD,EAAW,IACP/K,EAAKkE,KAAOlE,EAAK2K,GACjBpJ,EAAMtB,EACN0K,EAAUzG,MAET,CAAA,GAAIlE,EAAKkE,KAAOlE,EAAK0K,GAIrB,CACDzK,EAAIwK,QAJJhI,EAAMxC,EACNyK,EAAUxG,KAOTuG,EAAQhI,GAASgI,EAAQlJ,EAAM,IAC5BvB,EAAK0K,KAAa1K,EAAK2K,aAMrBxG,EAAKwG,EAAUD,EACftB,EAAK7H,EAAMkB,KAGb+H,EADO,IAAPrG,EACelE,GAAKwC,EAAW,GAAL2G,GAErB9H,KAAKO,IAAIsC,EAAK7C,KAAKmB,IAAIiI,EAASC,IARrB,GASD1K,GAAKwC,EAAM2G,GAAM,IAAO9H,KAAKO,IAAI6I,GAAWpJ,KAAKO,IAAI8I,IAR5C,IAAA,OAWT1K,GAAKwC,EAAMiI,EAAUvG,EAAKiF,GAE7CqB,EAAQxK,EAAIuK,EAERQ,WAMZH,EAAuB5K,EAAIwK,EAC3BxK,EAAIwK,SAGDxK,WCjNTgL,2TAAuB9K,mCAOpBF,OAGGe,0CAAoBf,MAKpBqB,KAAKO,IAAIb,GAPK,OAQdA,EAAS,GAGTA,EAAS,QACH,IAAIqG,WAAW,qDAGlB/F,KAAK+E,KAAKrF,4CAWV,qDAAmB"}