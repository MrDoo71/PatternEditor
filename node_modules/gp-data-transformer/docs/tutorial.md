# Tutorial

- [Simple Validation](#simple-validation)
- [Introduce another type](#introduce-another-type)
- [Mixing definitions](#mixing-definitions)
- [Shortcuts](#shortcuts)
- [Primitive types](#primitive-types)
    - [Booleans](#booleans)
    - [Numbers](#numbers)
    - [Strings](#strings)
    - [Null](#null)
    - [Undefined](#undefined)
    - [Enumerations](#enumerations)
    - [BigInt](#bigint)
- [Type Patterns](#type-patterns)
- [Object Patterns](#object-patterns)
- [Array Patterns](#array-patterns)
    - [Repetition](#repetition)
- [Naming](#naming)
    - [Properties of Objects](#properties-of-objects)
    - [Elements of Arrays](#elements-of-arrays)
- [Regular Expressions](#regular-expressions)
- [Transformation](#transformation)

---

# Simple Validation

Verify properties exist, regardless of type

```
type Ellipse = { cx cy rx ry }
```

Verify properties exist with associated types

```
type Ellipse = {
    cx: number
    cy: number
    rx: number
    ry: number
}
```

# Introduce another type

When validation encounters the `Point` type, it will search for its definition within the validation type declarations.

Note that if a type is not found in the type declarations, then a user-specified can be called to allow user-defined code to determine if a given value conforms to the given type.

```
type Ellipse = {
    center: Point
    rx: number
    ry: number
}

type Point = {
    x: number
    y: number
}
```

# Mixing definitions

The top-level properties (center, rx, ry) can be thought of as an idealized (or normalized) structure for the type being defined. These normalized properties most likely will match different structures; hence different underlying types. This means we cannot associate a type with `center`; however, once we begin discussion about transformation, we will be able to associate a target type for `center`, a type that must be generated by the normalized property's transformation.

Note that since we don't have a type for `center`, the types for all normalized properties have been removed. This is not a requirement. It is completely feasible to type check some properties while not checking others.

```
type Ellipse = {
    center {
        group {
            match center {
                { x, y }
            }
        }
        group {
            match cx { }
            match cy { }
        }
        group {
            match centerX { }
            match centerY { }
        }
    }
    rx
    ry
}
```

# Shortcuts

The snippets above represent the full internal representation of types in the validator. This can get a bit wordy and tedious to type, so a number of syntactic sugars have been added.

If a `group` has only a single item, you can replace it with its body. For example, the first group in `center` matches a `center` property. Since the two following groups have more than one item, we leave them surrounded by group blocks.

```
type Ellipse = {
    center {
        match center {
            { x, y }
        }
        group {
            match cx { }
            match cy { }
        }
        group {
            match centerX { }
            match centerY { }
        }
    }
    rx
    ry
}
```

`match` is used to match a property's value with a type and/or structure. If there is only a single type/structure to match against, we can drop the match block and place a colon after the property name. Note that we can apply this same sugar to the items in the other two groups.

```
type Ellipse = {
    center {
        center: { x, y }
        group {
            cx: { }
            cy: { }
        }
        group {
            centerX: { }
            centerY: { }
        }
    }
    rx
    ry
}
```

In these examples, we haven't been concerned with the types within the `center` normalized property. This results in empty type-clauses for the last two groups. When these clauses are empty, we can remove them

```
type Ellipse = {
    center {
        center: { x, y }
        group { cx  cy }
        group { centerX  centerY }
    }
    rx
    ry
}
```

It may be unlikely that a user will want to check the structure of data without checking property types. A more realistic example would include types like the following:

```
type Ellipse = {
    center {
        center: { x: number, y: number }
        group {
            cx: number
            cy: number
        }
        group {
            centerX: number
            centerY: number
        }
    }
    rx: number
    ry: number
}
```

Note that shortcuts are being used for the type matching in all three groups. A full version with `match` would look like:

```
type Ellipse = {
    center {
        match center {
            { x: number, y: number }
        }
        group {
            match cx { number }
            match cy { number }
        }
        group {
            match centerX { number }
            match centerY { number }
        }
    }
    rx: number
    ry: number
}
```

Just for thoroughness, here's a complete un-sugared version of Ellipse using types where possible. Notice that even `rx` and `ry` were using sugar in all of our previous typed examples.

```
type Ellipse = {
    center {
        group {
            match center {
                { x: number, y: number }
            }
        }
        group {
            match cx { number }
            match cy { number }
        }
        group {
            match centerX { number }
            match centerY { number }
        }
    }
    rx {
        group {
            match rx { number }
        }
    } 
    ry {
        group {
            match ry { number }
        }
    }
}
```

# Primitive types

## Booleans

`boolean` matches `true` and `false` only.

```
type MyType = boolean
```

You may match `true` or `false` directly. These can serve as named aliases for those values.

```
type Yes = true
type No = false
```

## Numbers

`number` matches any valid JS number

```
type MyType = number
```

You may match a specific number. This could be useful for matching named version numbers, for example.

```
type VERSION = 2
```

## Strings

`string` matches any JS string

```
type MyType = string
```

You may match a specific string.

```
type Name = "root"
```

## Null

```
type MyType = null
```

## Undefined

```
type MyType = undefined
```

## Enumerations

An enumeration can be used to define a list of string values. When the enumeration type is used as a type pattern, the value of the property being tested must exist within the enumeration in order for it to match. Note that only string values can be matched.

```
type TagNames = enumeration { one two three "multiple words" "type" }
```

Note that you can used double-quotes to add values with spaces to the enumeration. Double-quotes may also be used when you need to include a reserved word in the list.

## BigInt

TODO

# Type Patterns

Type patterns are used to match the structure and/or values of a property within a `match` block. Patterns can be used to extract specific values from a structure, which in turn can be used to construct a new value for a canonical property.

## Object Patterns

TODO

## Array Patterns

Empty array

```
[]
```

Array of any size with any content

```
array
```

Array of a single number

```
[number]
```

Array of two numbers

```
[number, number]
```

Array of mixed types

```
[number, string]
```

### Repetition

Repetitions allow you to specify a continuous range of integers. The following defines the range from 0 to 5, inclusive (fully closed interval)

```
0..5
```

Zero or more

```
0..
```

Up to 5 (same as 0..5)

```
..5
```

Exactly 5

```
5
```

### Ranges in Arrays

An array of 5 numbers

```
[number;5]
```

An array of number and string pairs repeated 5 times

```
[(number, string);5]
```

An array with 4 numbers followed by 3 strings

```
[number; 4, string; 3]
```

## Naming

In order to transform data, you will need to extract parts to be used to construct new types. The following section shows examples of naming.

### Properties of Objects

Extract an 'x' number property and a 'y' number property from an object. Save those values in a local dictionary using the same names.

```
{ x: number, y: number }
```

Note that if you don't care about their values, you can drop the type

```
{ x, y }
```

If you need to store the value with a different name, you can use the 'as' keyword.

```
{ x: number as cx, y: number as cy }
```

### Elements of Arrays

Extract the first element as 'x'. Note that this defines the array has having a single number element.

```
[ number as 'x' ]
```

Five or more numbers into an array named 'x'

```
[ number;5.. as xs ]
```

Five or more pairs of numbers and strings into an array named 'x'. Note that this array will be flat; not an array of pairs.

```
[ (number, string);5.. as x ]
```

Five numbers stored in an array named 'x' and four strings stored in an array named y.

```
[ number;5 as x, string;4 as y ]
```

## Regular Expressions

TODO: These will allow a user to match a string against a regular expression. It seems most useful to allow the user to grab group values from the match and apply names to those results.

# Transformation

NOTE: This is the current target I'm working towards

## Full version

```
type Ellipse = {
    center <= Point(x, y) {
        group {
            match center {
                { x: number, y: number }
            }
        }
        group {
            match cx {
                number as x
            }
            match cy {
                number as y
            }
        }
        group {
            match centerX {
                number as x
            }
            match centerY {
                number as y
            }
        }
    }
    rx: number
    ry: number
}
```

## Shortcut version

```
type Ellipse = {
    center <= Point(x, y) {
        center: { x: number, y: number }
        group {
            cx: number as x
            cy: number as y
        }
        group {
            centerX: number as x
            centerY: number as y
        }
    }
    rx: number
    ry: number
}
```
