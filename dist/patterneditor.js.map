{"version":3,"sources":["Geometry.js","drawing/DrawingObject.js","drawing/ArcElliptical.js","drawing/ArcSimple.js","drawing/CutSpline.js","drawing/Drawing.js","drawing/Line.js","drawing/OperationFlipByAxis.js","drawing/OperationMove.js","drawing/OperationResult.js","drawing/OperationRotate.js","drawing/PerpendicularPointAlongLine.js","drawing/PointAlongBisector.js","drawing/PointAlongLine.js","drawing/PointAlongPerpendicular.js","drawing/PointCutArc.js","drawing/PointCutSplinePath.js","drawing/PointEndLine.js","drawing/PointFromArcAndTangent.js","drawing/PointFromCircleAndTangent.js","drawing/PointFromXandYOfTwoOtherPoints.js","drawing/PointIntersectArcAndAxis.js","drawing/PointIntersectArcAndLine.js","drawing/PointIntersectArcs.js","drawing/PointIntersectCircles.js","drawing/PointIntersectCurveAndAxis.js","drawing/PointIntersectCurves.js","drawing/PointIntersectLineAndAxis.js","drawing/PointLineIntersect.js","drawing/PointOfTriangle.js","drawing/PointShoulder.js","drawing/PointSingle.js","drawing/SplinePathInteractive.js","drawing/SplinePathUsingPoints.js","drawing/SplineSimple.js","drawing/SplineUsingControlPoints.js","drawing/TrueDart.js","drawing/TrueDartResult.js","Pattern.js","PatternPiece.js","PatternEditor.js","expression.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7CA;AACA;AACA;AACA;AACA;AACA;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChlCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"patterneditor.js","sourcesContent":["//(c) Copyright 2019 Jason Dore\n//\n//This library collates the various geometric calclulation requirements\n//of the drawing objects into a small number of primitives. \n//\n//This library then generally uses other libraries to perform those \n//geometric calculations where they are non trivial\n//(e.g. intersection of lines with splines).\n//\n//Source maintained at: https://github.com/MrDoo71/PatternEditor\n\nimport { Intersection, Point2D, ShapeInfo } from '../node_modules/kld-intersections/dist/index-esm.js';\n\n//A point\nclass GeoPoint {\n\n    //x;\n    //y;\n\n    constructor( x, y ) {\n        this.x = x;\n        this.y = y;\n\n        if ( isNaN( this.x ) )\n            throw \"GeoPoint x not a number.\";\n            \n        if ( isNaN( this.y ) )\n            throw \"GeoPoint y not a number.\";\n    }\n\n    line( point2 ) {    \n        throw \"this looks broken, two params, not four\";\n        return new GeoLine( this.x, this.y, point2.x, point2.y );\n    }\n\n\n    pointAtDistanceAndAngleRad( length, angle /*radians anti-clockwise from east*/ ) {        \n        var x = this.x + length * Math.cos( -1 * angle ); //TODO this is a guess!\n        var y = this.y + length * Math.sin( -1 * angle );   \n        return new GeoPoint( x, y );\n    }\n\n\n    pointAtDistanceAndAngleDeg( length, angle /*deg anti-clockwise from east*/ ) {        \n        return this.pointAtDistanceAndAngleRad( length, angle * Math.PI / 180 );\n    }\n\n\n    rotate( center, rotateAngleDeg )\n    {\n        //Convert degrees to radians\n        \n        var centerToSourceLine = new GeoLine( center, this );\n        var distance = centerToSourceLine.getLength();\n        var angle = centerToSourceLine.angleDeg() + rotateAngleDeg;\n\n        var result = center.pointAtDistanceAndAngleDeg( distance, angle );\n        return result;\n    }\n\n\n    asPoint2D()\n    {\n        return new Point2D( this.x, this.y );\n    }\n}\n\n\n//A line\nclass GeoLine {\n\n    //p1;\n    //p2;\n\n    constructor( p1, p2 ) {\n\n        if ( ! p1 )\n            throw \"GeoLine p1 not defined.\";\n\n        if ( ! p2 )\n            throw \"GeoLine p2 not defined.\";\n\n        this.p1 = p1;//new GeoPoint( x1, y1 );\n        this.p2 = p2;//new GeoPoint( x2, y2 );\n    \n        this.deltaX = ( this.p2.x - this.p1.x ); //nb. +ve to the east from p1 to p2\n        this.deltaY = ( this.p2.y - this.p1.y ); //nb +ve to the south from p1 to p2\n    \n        this.length = Math.sqrt( Math.pow(this.deltaX,2) + Math.pow(this.deltaY,2) );\n\n        //angle is anti-clockwise starting east in radians\n        this.angle = Math.atan2( -this.deltaY, this.deltaX );\n\n        if ( this.angle < 0 )\n            this.angle = this.angle + (2 * Math.PI);          \n    \n        //alert( \"Line angle:\" + this.angle + \" (\" + ( this.angle / (2*Math.PI) * 360) + \"deg anti clockwise from east\" );\n    \n        this.slope  = ( this.deltaY / this.deltaX );\n        this.offset = this.p1.y - ( this.p1.x * this.slope ); //the y values where x = 0; the intersection of the line with the y-axis\n        //this line is generically: y = offset + ( x * slope )\n    }\n\n    intersect( line2 ) {    \n        //intersection\n        //  // offset - line2.offset / ( line2.slope - slope ) = x\n\n        var swap = Math.abs( this.deltaX ) > Math.abs( line2.deltaX );\n        var line1s = swap ? this : line2; //this.p1.x < this.p2.x ? this : new GeoLine( this.p2, this.p1 );\n        var line2s = swap ? line2 : this; //line2.p1.x < line2.p2.x ? line2 : new GeoLine( line2.p2, line2.p1 );\n\n\n        var x, y;\n\n        if (    ( line2s.slope === Infinity ) \n             || ( line2s.slope === -Infinity )  )\n            x = line2s.p1.x;\n        else\n            x = ( line1s.offset - line2s.offset ) / ( line2s.slope - line1s.slope );\n\n        if ( line1s.slope === 0 )\n            y = line1s.p1.y;\n        else\n            y = line1s.p1.y + ( line1s.slope * ( x - line1s.p1.x ) );\n\n        return new GeoPoint(x,y);\n\n        //Using the Intersection libary requires that the finite lines intersect, rather than\n        //their infinite versions. \n        //var line1SI = this.asShapeInfo();\n        //var line2SI = line2.asShapeInfo();\n        //var intersections = Intersection.intersect(line1SI, line2SI);        \n        //intersections.points.forEach(console.log);    \n        //return new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n    }    \n\n    intersectArc( arc ) //nb. arc can be GeoArc, GeoEllipticalArc, or GeoSpline\n    {\n        //work around a bug where the arc spans 0 deg\n        if (    ( arc.angle1 < 0 ) \n             && ( arc.angle2 > 0 ) \n             && ( arc instanceof GeoArc ) ) //not an elliptical\n        {\n            if ( arc instanceof GeoArc )\n            {\n                try { \n                    var arc1 = new GeoArc( arc.center, arc.radius, 0, arc.angle2 );\n                    return this.intersectArc( arc1 );\n                } catch ( e ) {\n                    var arc2 = new GeoArc( arc.center, arc.radius, arc.angle1 + 360, 360 );\n                    return this.intersectArc( arc2 );\n                }\n            }\n        }\n\n        var arcSI,lineSI;\n\n        //nb there is a special case for GeoEllipticalArc where this.p1 == arc.center in \n        //which case a simple formula gives the intersect.\n        if (( arc instanceof GeoEllipticalArc ) && ( arc.rotationAngle !== 0 ))\n        {            \n            //console.log(\"elliptical arc \");\n            \n            //create an equivalent arc that is not rotated.\n            //create a new line, rotate the startpoint by -rotationAngle, the new lines angle should also be less by -rotationAngle\n            //finally rotate the intersect point back\n            var nrArc = new GeoEllipticalArc( arc.center,\n                                              arc.radius1,\n                                              arc.radius2, \n                                              arc.angle1, \n                                              arc.angle2,\n                                              0 );\n            var p1rotated = this.p1.rotate( arc.center, -arc.rotationAngle );\n            var lineRotated = new GeoLine( p1rotated, p1rotated.pointAtDistanceAndAngleDeg( 1000, (this.angleDeg() - arc.rotationAngle) ) );\n\n            arcSI = nrArc.asShapeInfo();\n            \n            var extendedLine = new GeoLine( lineRotated.p1.pointAtDistanceAndAngleRad( -1000/*infinite*/, lineRotated.angle ), lineRotated.p2 );\n            lineSI = extendedLine.asShapeInfo();    \n        }\n        else\n        {\n            arcSI = arc.asShapeInfo();\n\n            var extendedLine = new GeoLine( this.p1.pointAtDistanceAndAngleRad( -1000/*infinite*/, this.angle ), this.p2 );\n            lineSI = extendedLine.asShapeInfo();    \n        }\n\n        //var path = ShapeInfo.path(\"M40,70 Q50,150 90,90 T135,130 L160,70 C180,180 280,55 280,140 S400,110 290,100\");\n    \n        var intersections = Intersection.intersect(arcSI, lineSI);\n        \n        //console.log( \"Intersections:\" );\n        //intersections.points.forEach(console.log);    \n\n        if ( intersections.points.length === 0 )\n            throw \"No intersection with arc. \";\n\n        var whichPoint = 0;\n        if ( intersections.points.length > 1 )//-1;//0; //0 for G1 in headpattern. //intersections.points.length -1; //TODO do this properly\n        {            \n            if ( false )\n            {\n                //choose the point with the smallest angle. \n                var smallestAngle = 361;\n                for (var i = 0; i < intersections.points.length; i++) \n                {\n                    var pi = intersections.points[i];\n                    var p1pi = new GeoLine( arc.center, pi );\n                    console.log( i + \" \" + p1pi.angleDeg() );\n                    if ( p1pi.angleDeg() < smallestAngle )\n                    {\n                        smallestAngle = p1pi.angleDeg();\n                        whichPoint = i;\n                    }\n                }\n            }\n            else\n            {\n                //choose the first point we get to along the line. \n                var smallestDistance = undefined;\n                for (var i = 0; i < intersections.points.length; i++) \n                {\n                    var pi = intersections.points[i];\n                    var p1pi = new GeoLine( this.p1, pi );\n                    //console.log( i + \" \" + p1pi.length );\n                    if (    ( smallestDistance === undefined ) \n                         || (    ( Math.abs( p1pi.angle - this.angle ) < 0.0001 ) //rather than 180 deg the other way (allowing for rounding errors)\n                              && ( p1pi.length < smallestDistance ) ) )\n                    {\n                        smallestDistance = p1pi.length;\n                        whichPoint = i;\n                    }\n                }            \n            }\n        }\n\n        var intersect = new GeoPoint( intersections.points[whichPoint].x, intersections.points[whichPoint].y );\n\n        if (( arc instanceof GeoEllipticalArc ) && ( arc.rotationAngle !== 0 ))\n        {\n            intersect = intersect.rotate( arc.center, +arc.rotationAngle );\n        }\n\n        return intersect;\n    }\n\n    applyOperation( pointTransformer ) \n    {\n        var p1Transformed = pointTransformer( this.p1 );\n        var p2Transformed =  pointTransformer( this.p2 );\n        return new GeoLine( p1Transformed, p2Transformed );\n    }    \n\n    asShapeInfo()\n    {\n        return ShapeInfo.line( this.p1.x, this.p1.y, this.p2.x, this.p2.y );\n    }\n\n    angleDeg() \n    {\n        /*\n        var deltaX = (this.p2.x - this.p1.x);\n        var deltaY = -1 * (this.p2.y - this.p1.y); //-1 because SVG has y going downwards\n\n        //if ( deltaX === 0 )\n        //    return deltaY > 0 ? 90 : 270;\n\n        return Math.atan2( deltaY, deltaX ) * 180 / Math.PI;\n        */\n       return this.angle * 180 / Math.PI;\n    }\n\n    angleRad() \n    {\n        return this.angle;\n    }\n\n\n    getLength() \n    {\n        return this.length;\n    }\n}\n\n\n//An arc of a circle\nclass GeoArc {\n\n    //center\n    //radius\n    //angle1 - degrees!\n    //angle2 - degrees!\n\n    constructor( center, radius, angle1, angle2 ) {\n        this.center = center;\n        this.radius = radius;\n        this.angle1 = angle1;\n        this.angle2 = angle2;\n\n        //Correct 180-0 to 180-360\n        if ( this.angle2 < this.angle1 )\n            this.angle2+=360;\n    }\n\n\n    /**\n     * Get the points on this arc where the tangents that go through\n     * the specified point touch this arc.\n     * \n     * @param {*} pointOnTangent \n     */\n    getPointsOfTangent( pointOnTangent )\n    {\n        //There is a right angle triangle where\n        //hypotenous is the line tangent-arc.center - known length\n        //lines tangent-p and p-center form a right angle.   p-center has length arc.radius\n        //cos(i) = arc.radius / tangent-arc.center\n        var radius  = this.radius;\n        var h       = new GeoLine( this.center, pointOnTangent );\n        var hLength = h.length;\n        var angle   = Math.acos( radius/hLength ); //Would be an error if hLength < radius, as this means pointOnTangent is within the circle. \n        var totalAngleR;\n\n        var tangentTouchPoints = [ this.center.pointAtDistanceAndAngleRad( radius, h.angle - angle ),\n                                   this.center.pointAtDistanceAndAngleRad( radius, h.angle + angle ) ];        \n        \n        return tangentTouchPoints;\n    }\n\n\n    svgPath()\n    {\n        var arcPath = d3.path();\n        arcPath.arc( this.center.x, this.center.y, \n                     this.radius, \n                     -this.angle1 * Math.PI / 180, -this.angle2 * Math.PI / 180, true );        \n        //console.log( \"Could have used d3:\", arcPath.toString() );\n        return arcPath.toString();\n\n        //var a2 = this.angle2;\n        //if ( this.angle2 < this.angle1 )\n        //    a2 = a2 + 360;\n\n        //THIS NOT WORKING\n        //var svgParams = this.centeredToSVG( this.center.x, this.center.y, this.radius, this.radius, -this.angle1, a2-this.angle1, 0 );\n        //var path = \"M\" + svgParams.x + \",\" + svgParams.y \n        //     + \"A\" + svgParams.rx + \",\" + svgParams.ry \n        //     + \",\" + svgParams.xAxisAngle + \",\" + svgParams.largeArc + \",\" + svgParams.sweep + \",\"\n        //     + svgParams.x1 + \",\" + svgParams.y1 \n        //\n        //console.log( \"svgPath() - \", path );\n\n        //return path;\n    }    \n\n    \n    pointAlongPath( length ) {\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        if ( length > path.getTotalLength() )\n            length = path.getTotalLength();\n        var p = path.getPointAtLength( length );\n        //console.log(p);      \n        return new GeoPoint( p.x, p.y );\n    }        \n\n    \n    pointAlongPathFraction( fraction ) {\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        var l = path.getTotalLength();\n        var p = path.getPointAtLength( l * fraction );\n        //console.log(p);      \n        return new GeoPoint( p.x, p.y );\n    }         \n    \n    \n    pathLength() {\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        return path.getTotalLength();\n    }             \n\n\n    asShapeInfo()\n    {  \n        if (( this.angle1 == 0 ) && ( this.angle2 == 360 ))\n            return ShapeInfo.circle( this.center.x, this.center.y, this.radius );\n\n        //ShapeInfo angles seem to go clockwise from East, rather than our anti-clickwise angles\n        var angle1 = 360 - this.angle2;\n        var angle2 = 360 - this.angle1;\n\n        if ( angle2 > 360 ) //the original angle1 was negative. \n        {\n            angle1 -= 360;\n            angle2 -= 360;\n        }\n\n        //if ( angle1 < 0 )\n        //angle1 = 0;\n\n        //if ( angle2 < 0 )\n        //angle2 = 0;\n\n       // if ( angle2 < angle1 )\n       // {\n       //     var t = angle2;\n       //     angle2 = angle1;\n       //     angle1 = t;\n       // }\n                \n        return ShapeInfo.arc( this.center.x, this.center.y, this.radius, this.radius, angle1 * Math.PI/180, angle2 * Math.PI/180 );\n    }    \n}\n\n\nclass GeoSpline {\n\n    //nodeData - an array of\n    //{ \n    //  inAngle  : \n    //  inLength : \n    //  point    : \n    //  outAngle : \n    //  outLength:  \n    //} \n\n    constructor( nodeData ) {\n        this.nodeData = nodeData;\n    }\n\n    applyOperation( pointTransformer ) {\n        var nodeData = [];\n        for ( var i=0; i<this.nodeData.length; i++ )\n        {\n            var node = this.nodeData[i];\n\n            //Need a control point, not a length and angle. \n            var inPoint = node.inControlPoint;\n            var outPoint = node.outControlPoint;\n            \n            if ( ( ! inPoint ) && ( node.inLength !== undefined ) )            \n                inPoint = node.point.pointAtDistanceAndAngleDeg( node.inLength, node.inAngle );\n\n            if ( ( ! outPoint ) && ( node.outLength !== undefined ) )\n                outPoint = node.point.pointAtDistanceAndAngleDeg( node.outLength, node.outAngle );\n    \n            var inPointTransformed = inPoint === undefined ? undefined : pointTransformer( inPoint );\n            var outPointTransformed =  outPoint === undefined ? undefined : pointTransformer( outPoint );\n\n            nodeData.push( {inControlPoint:   inPointTransformed,\n                            point:            pointTransformer( node.point ),\n                            outControlPoint:  outPointTransformed } ) ;\n        }\n        return new GeoSpline( nodeData );\n    }\n\n    svgPath()\n    {\n        var nodeData = this.nodeData;\n        var path;\n        for ( var i=0; i<nodeData.length; i++ )\n        {\n            if ( i===0 )\n            {\n                path = \"M\" + nodeData[i].point.x + \",\" + this.nodeData[i].point.y ;\n            }\n            else\n            {\n                var controlPoint1 = ( typeof nodeData[i-1].outControlPoint !== \"undefined\" ) ? nodeData[i-1].outControlPoint\n                                                                                             : nodeData[i-1].point.pointAtDistanceAndAngleDeg( nodeData[i-1].outLength, nodeData[i-1].outAngle );\n\n                var controlPoint2 = ( typeof nodeData[i].inControlPoint !== \"undefined\" ) ? nodeData[i].inControlPoint\n                                                                                          : nodeData[i].point.pointAtDistanceAndAngleDeg( nodeData[i].inLength, nodeData[i].inAngle );\n                path += \"C\" + controlPoint1.x + \" \" + controlPoint1.y +\n                        \" \" + controlPoint2.x + \" \" + controlPoint2.y +\n                        \" \" + nodeData[i].point.x + \" \" + nodeData[i].point.y;\n            }\n        }\n\n        //console.log( \"GeoSpline: \" + path );\n\n        return path;\n    }\n\n    asShapeInfo()\n    {        \n        return ShapeInfo.path( this.svgPath() );\n    }\n    \n    pointAlongPathFraction( fraction ) {\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        var l = path.getTotalLength();\n        var p = path.getPointAtLength( l * fraction );\n        //console.log(p);      \n        return new GeoPoint( p.x, p.y );\n    }       \n\n    pointAlongPath( length ) {\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        var p = path.getPointAtLength( length );\n        //console.log(p);      \n        return new GeoPoint( p.x, p.y );\n    }       \n\n\n    pathLength() {\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        return path.getTotalLength();\n    }             \n\n}\n\n\nclass GeoEllipticalArc {\n\n    constructor( center, radius1, radius2, angle1, angle2, rotationAngle ) \n    {\n        this.center = center;\n        this.radius1 = radius1;\n        this.radius2 = radius2;\n        this.angle1 = angle1;\n        this.angle2 = angle2;\n        this.rotationAngle = rotationAngle;\n    }\n\n\n    clone() {\n        return new GeoEllipticalArc( this.center, \n                                     this.radius1, \n                                     this.radius2, \n                                     this.angle1,  \n                                     this.angle2,\n                                     this.rotationAngle );\n    }\n\n    //https://observablehq.com/@toja/ellipse-and-elliptical-arc-conversion\n    //http://xahlee.info/js/svg_path_ellipse_arc.html\n    //https://observablehq.com/@toja/ellipse-and-elliptical-arc-conversion\n    getEllipsePointForAngle(cx, cy, rx, ry, phi, theta) \n    {\n        const { abs, sin, cos } = Math;\n        \n        //https://en.wikipedia.org/wiki/Ellipse#Polar_form_relative_to_focus\n        const radius=   ( rx * ry )\n                      / Math.sqrt( Math.pow( rx * Math.sin( theta ),2 ) + Math.pow( ry * Math.cos( theta ), 2 ) ); \n\n        const M = radius * cos(theta),\n              N = radius * sin(theta);  \n\n        return { x: cx + cos(phi) * M - sin(phi) * N,\n                 y: cy + sin(phi) * M + cos(phi) * N };\n     }\n\n\n    //TODO based on SVG book, but corrected\n    centeredToSVG( cx, cy, rx, ry, thetaDeg/*arcStart*/, deltaDeg/*arcExtent*/, phiDeg/*x axis rotation*/ )\n    {\n        var theta, endTheta, phiRad;\n        var largeArc, sweep;\n        theta = thetaDeg * Math.PI / 180;\n        endTheta = ( thetaDeg + deltaDeg ) * Math.PI / 180;\n        phiRad = phiDeg * Math.PI / 180;\n\n        //console.log( \"centeredToSVG thetaDeg: \" + thetaDeg );\n        //console.log( \"centeredToSVG deltaDeg: \" + deltaDeg );\n        //console.log( \"centeredToSVG endThetaDeg: \" + ( thetaDeg + deltaDeg ) );\n        //console.log( \"centeredToSVG endTheta: \" + endTheta );\n\n        var start = this.getEllipsePointForAngle(cx, cy, rx, ry, phiRad, theta);\n        var end = this.getEllipsePointForAngle(cx, cy, rx, ry, phiRad, endTheta);\n\n        //console.log( \"3. centeredToSVG x0,y0: \" + x0 + \",\" + y0 );\n        //console.log( \"3. centeredToSVG x1,y1: \" + x1 + \",\" + y1 );\n\n        largeArc = ( deltaDeg > 180 ) || ( deltaDeg < -180 ) ? 1 : 0;\n        sweep = ( deltaDeg > 0 ) ? 0 : 1;\n         \n        return { x: start.x,\n                 y: start.y,\n                rx: rx,\n                ry: ry,\n                xAxisAngle: phiDeg,\n                largeArc: largeArc,\n                sweep: sweep,\n                x1: end.x,\n                y1: end.y };\n    }    \n\n\n    svgPath()\n    {\n        // 90->180   -90 -> -180     -90,-90\n        // 0->90   -0 +-90\n        var d2 = this.centeredToSVG( this.center.x, this.center.y, this.radius1, this.radius2, 360-(this.angle1), -(this.angle2 - this.angle1), -this.rotationAngle );\n        var path = \"M\" + d2.x + \",\" + d2.y;\n        path += \" A\" + d2.rx + \" \" + d2.ry;\n        path += \" \" + d2.xAxisAngle;\n        path += \" \" + d2.largeArc + \",0\";// + d2.sweep;\n        path += \" \" + d2.x1 + \",\" + d2.y1 + \" \";\n\n        //console.log( \"GeoEllipticalArc: \" + path );\n\n        return path;\n    }\n\n    asShapeInfo()\n    {     \n        //TEMPORARY ON TRIAL - THIS WORKS, SO ROTATE TRANSLATE \n        //              cx, cy, rx, ry. start, end   \n        if ( this.rotationAngle === 0 )\n            return ShapeInfo.arc( this.center.x, this.center.y, this.radius1, this.radius2, this.angle1/180*Math.PI, this.angle2/180*Math.PI)\n\n        var svgPath = this.svgPath();\n        //console.log( \"EllipticalArc.asShapeInfo() this might not work for intersections... \" + svgPath );\n        return ShapeInfo.path( svgPath );\n    }\n    \n    pointAlongPathFraction( fraction ) {\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        var l = path.getTotalLength();\n        var p = path.getPointAtLength( l * fraction );\n        //console.log(p);      \n        return new GeoPoint( p.x, p.y );\n    }       \n\n    pointAlongPath( length ) {\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        var p = path.getPointAtLength( length );\n        //console.log(p);      \n        return new GeoPoint( p.x, p.y );\n    }       \n\n\n    pathLength() {\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        return path.getTotalLength();\n    }             \n\n}\n\n","class DrawingObject /*abstract*/ {\n    \n    constructor(data) {\n        this.data = data;\n    }\n\n    drawLabel( g, isOutline ) {\n\n        if ( isOutline )\n            return; //it would be confusing to be able to click on text that you can't see to select something. \n\n        //g - the svg group we want to add the text to\n        //o - the drawing object\n        var d = this.data; //the original json data\n        if (typeof this.p.x !== \"number\")\n            return;\n\n        var fontSize = Math.round( ( 1200 / scale / fontsSizedForScale ))/100;\n\n        g.append(\"text\")\n            .attr(\"x\", this.p.x + (typeof d.mx === \"undefined\" ? 0 : ( d.mx ) ) )\n            .attr(\"y\", this.p.y + (typeof d.my === \"undefined\" ? 0 : ( d.my + fontSize ) ) )\n            .text(d.name)\n            .attr(\"font-size\", fontSize + \"px\");\n    }\n\n\n    drawDot( g, isOutline ) {\n        g.append(\"circle\")\n            .attr(\"cx\", this.p.x)\n            .attr(\"cy\", this.p.y)\n            .attr(\"r\", Math.round( ( isOutline ? 1200 : 400 ) / scale ) /100 );\n    }\n\n\n    drawLine( g, isOutline ) {\n        if ( this.lineVisible() && this.line ) //If there was an error, line may not be set. \n        {\n            var l = g.append(\"line\")\n                     .attr(\"x1\", this.line.p1.x)\n                     .attr(\"y1\", this.line.p1.y)\n                     .attr(\"x2\", this.line.p2.x)\n                     .attr(\"y2\", this.line.p2.y)\n                     .attr(\"stroke-width\", this.getStrokeWidth( isOutline ) );\n\n            if ( ! isOutline )\n                l.attr(\"stroke\", this.getColor() )\n                 .attr(\"class\", this.getLineStyle() );\n        }\n    }\n\n\n    drawPath( g, path, isOutline ) {\n        if ( this.lineVisible() )\n        {\n            var p = g.append(\"path\")\n                    .attr(\"d\", path )\n                    .attr(\"fill\", \"none\")\n                    .attr(\"stroke-width\", this.getStrokeWidth( isOutline) );\n\n            if ( ! isOutline )        \n                p.attr(\"stroke\", this.getColor() )\n                 .attr(\"class\", this.getLineStyle() );\n        }\n    }    \n\n\n    drawCurve( g, isOutline ) {\n        if ( this.lineVisible() && this.curve )\n            this.drawPath( g, this.curve.svgPath(), isOutline );\n    }\n\n\n    ref() {\n        return '<a class=\"ps-ref\">' + this.data.name + '</a>';\n    }\n\n\n    refOf( anotherDrawingObject ) {\n        if ( ! anotherDrawingObject )\n            return \"???\";\n\n        if ( ! anotherDrawingObject.ref )\n            return \"????\";\n\n        return anotherDrawingObject.ref();\n    }\n\n\n    getStrokeWidth( isOutline, isSelected )\n    {\n        return Math.round( 1000 * ( isOutline ? 7.0 : ( isSelected ? 3.0 : 1.0 ) ) / scale / fontsSizedForScale ) /1000;\n    }\n\n\n    getColor() {\n        return this.data.color;\n    }\n\n    \n    getLineStyle()\n    {\n        return this.data.lineStyle;\n    }\n\n\n    lineVisible() {\n        return this.data.lineStyle !== \"none\";\n    }\n\n\n    pointEndLine(data) {\n        data.objectType = \"pointEndLine\";\n        data.basePoint = this;\n        return this.patternPiece.add(data);\n    }\n\n\n    pointAlongLine(data) {\n        data.objectType = \"pointAlongLine\";\n        data.firstPoint = this;\n        return this.patternPiece.add(data);\n    }\n\n\n    lineTo(data) {\n        data.objectType = \"line\";\n        data.firstPoint = this;\n        return this.patternPiece.add(data);\n    }\n\n\n    pointLineIntersect(data) {\n        data.objectType = \"pointLineIntersect\";\n        data.p1Line1 = this;\n        return this.patternPiece.add(data);\n    }\n}\n","class ArcElliptical extends DrawingObject {\n\n    //center\n    //angle1\n    //angle2\n    //radius1\n    //radius2\n    //rotationAngle\n\n    constructor(data) {\n        super(data);\n\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = data.derivedName;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.center === \"undefined\")\n            this.center = this.patternPiece.getObject(d.center);\n        if (typeof this.angle1 === \"undefined\")\n            this.angle1 = this.patternPiece.newFormula(d.angle1);\n        if (typeof this.angle2 === \"undefined\")\n            this.angle2 = this.patternPiece.newFormula(d.angle2);\n        if (typeof this.radius1 === \"undefined\")\n            this.radius1 = this.patternPiece.newFormula(d.radius1);\n        if (typeof this.radius2 === \"undefined\")\n            this.radius2 = this.patternPiece.newFormula(d.radius2);\n        if (typeof this.rotationAngle === \"undefined\")\n            this.rotationAngle = this.patternPiece.newFormula(d.rotationAngle);\n\n        this.arc = new GeoEllipticalArc( this.center.p, \n                                         this.radius1.value(),\n                                         this.radius2.value(), \n                                         this.angle1.value(), \n                                         this.angle2.value(),\n                                         this.rotationAngle.value() );\n        /*\n        if ( this.rotationAngle.value() != 0 )                                         \n        this.debugArc = new GeoEllipticalArc( this.center.p, \n                                            this.radius1.value(),\n                                            this.radius2.value(), \n                                            this.angle1.value(), \n                                            this.angle2.value(),\n                                            0 );*/\n   \n        this.p = this.arc.pointAlongPathFraction( 0.5 );\n\n        bounds.adjust( this.p );\n        bounds.adjust( this.arc.pointAlongPathFraction( 0 ) );\n        bounds.adjust( this.arc.pointAlongPathFraction( 0.25 ) );\n        bounds.adjust( this.arc.pointAlongPathFraction( 0.5 ) );\n        bounds.adjust( this.arc.pointAlongPathFraction( 0.75 ) );\n        bounds.adjust( this.arc.pointAlongPathFraction( 1 ) );\n    }\n\n\n    pointAlongPath( length )\n    {\n        return this.arc.pointAlongPath( length );\n    }\n    \n\n    asShapeInfo()\n    {\n        return this.arc.asShapeInfo();\n    }\n\n\n    draw( g, isOutline ) {\n        this.drawPath( g, this.arc.svgPath(), isOutline );\n\n        //if ( this.debugArc )\n        //    this.drawPath( g, this.debugArc.svgPath(), isOutline );\n\n        this.drawLabel( g, isOutline );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'elliptical arc with center ' + this.refOf( this.center )\n                + \" radius-x \" + this.data.radius1.htmlLength( asFormula ) \n                + \" radius-y \" + this.data.radius2.htmlLength( asFormula ) \n                + \" from angle \" + this.data.angle1.htmlAngle( asFormula ) \n                + \" to \" + this.data.angle2.htmlAngle( asFormula )\n                + \" rotation angle \" + this.data.rotationAngle.htmlAngle( asFormula ) ;\n    }\n\n    \n    setDependencies( dependencies ) {\n        dependencies.add( this, this.center );\n        dependencies.add( this, this.angle1 );\n        dependencies.add( this, this.angle2 );\n        dependencies.add( this, this.rotationAngle );\n        dependencies.add( this, this.radius1 );\n        dependencies.add( this, this.radius2 );\n    }    \n}\n","class ArcSimple extends DrawingObject {\n\n    //center\n    //angle1\n    //angle2\n    //radius \n\n    constructor(data) {\n        super(data);\n\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = data.derivedName;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.center === \"undefined\")\n            this.center = this.patternPiece.getObject(d.center);\n        if (typeof this.angle1 === \"undefined\")\n            this.angle1 = this.patternPiece.newFormula(d.angle1);\n        if (typeof this.angle2 === \"undefined\")\n            this.angle2 = this.patternPiece.newFormula(d.angle2);\n        if (typeof this.radius === \"undefined\")\n            this.radius = this.patternPiece.newFormula(d.radius);\n\n        this.arc = new GeoArc( this.center.p, this.radius.value(), this.angle1.value(), this.angle2.value() );\n\n        this.p = this.arc.pointAlongPathFraction( 0.5 );\n\n        bounds.adjust( this.p );\n        bounds.adjust( this.arc.pointAlongPathFraction( 0 ) );\n        bounds.adjust( this.arc.pointAlongPathFraction( 0.25 ) );\n        bounds.adjust( this.arc.pointAlongPathFraction( 0.5 ) );\n        bounds.adjust( this.arc.pointAlongPathFraction( 0.75 ) );\n        bounds.adjust( this.arc.pointAlongPathFraction( 1 ) );\n    }\n\n\n    pointAlongPath( length ) {\n        return this.arc.pointAlongPath( length );\n    }\n    \n\n    asShapeInfo() {\n        return this.arc.asShapeInfo();\n    }\n\n\n    draw( g, isOutline ) {\n        var d = this.data;\n        var arcPath = d3.path();\n        var a2 = this.angle2.value();\n        if ( a2 < this.angle1.value() )\n            a2 += 360;\n        arcPath.arc( this.center.p.x, this.center.p.y, \n                     this.radius.value(), \n                     -this.angle1.value() * Math.PI / 180, -a2 * Math.PI / 180, true );\n        \n        //console.log( \"ArcSimple d3 path \", arcPath );\n\n        if ( this.lineVisible() )\n            this.drawPath( g, arcPath, isOutline );\n\n        this.drawLabel(g, isOutline);\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'arc with center ' + this.refOf( this.center )\n                + \" radius \" + this.radius.htmlLength( asFormula ) \n                + \" from angle \" + this.angle1.htmlAngle( asFormula ) \n                + \" to \" + this.angle2.htmlAngle( asFormula );\n    }\n\n    \n    setDependencies( dependencies ) {\n        dependencies.add( this, this.center );\n        dependencies.add( this, this.angle1 );\n        dependencies.add( this, this.angle2 );\n        dependencies.add( this, this.radius );\n    }    \n}\n","class CutSpline extends DrawingObject { //TODO for consistency should be PointCutSpline ???\n\n    //curve\n    //length\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.curve === \"undefined\")\n            this.curve = this.patternPiece.getObject(d.spline);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n\n        this.p = this.curve.pointAlongPath( this.length.value() );\n        \n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, isOutline ) {\n        //this.drawLine( g );\n        this.drawDot( g, isOutline );\n        this.drawLabel( g, isOutline );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + this.data.length.htmlLength( asFormula ) \n                + \" along curve \" + this.refOf( this.curve );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.curve );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","//(c) Copyright 2019 Jason Dore\n\nvar scale;\n\n\n","class Line extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.firstPoint);\n            \n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.secondPoint);\n\n        this.line = new GeoLine(this.firstPoint.p, this.secondPoint.p);\n        bounds.adjustForLine(this.line);\n    }\n\n\n    draw( g, isOutline ) {\n        \n        this.drawLine( g, isOutline );\n        \n        //TODO we could display the derived name Line_A1_A2 at the mid-point along the line?       \n\n        //TODO for all lines we could draw a thicker invisible line do make it easier to click on the line.\n    }\n\n\n    html( asFormula ) {\n        return 'line ' + this.refOf( this.firstPoint ) + \" - \" + this.refOf( this.secondPoint );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n    }    \n}\n","class OperationFlipByAxis extends DrawingObject {\n\n    //operationName\n    //suffix\n    //center\n    //axis\n\n    constructor(data) {\n        super(data);\n        this.data.name = data.operationName;\n        this.axis = data.axis;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.center === \"undefined\")\n            this.center = this.patternPiece.getObject(d.center);\n    }\n\n\n    draw( g, isOutline ) {\n        //g is the svg group\n        //this.drawLine( g ); //TODO put an arrow head on this!\n        //this.drawDot( g );\n        //this.drawLabel( g );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + 'Flip operation: axis:' + this.axis \n                + \" around \" + this.refOf( this.center ) \n                         //\" angle:\" + this.data.angle.value() +\n                + \" suffix:\" + this.data.suffix;\n    }\n\n\n    applyOperationToPoint( p ) {\n        return this.flipPoint( p, this.center.p );\n    }\n\n\n    flipPoint( p, center ) {\n        var result = new GeoPoint( p.x, p.y );\n\n        if (    ( this.axis === \"Vertical\" ) \n             || ( this.axis === \"vertical\" )) //just in case.\n            result.x = center.x - ( p.x - center.x );\n        else\n            result.y = center.y - ( p.y - center.y );\n\n        return result;\n    }\n\n    \n    setDependencies( dependencies ) {\n        dependencies.add( this, this.center );\n    }    \n\n}\n","class OperationMove extends DrawingObject {\n\n    //operationName\n    //suffix\n    //angle\n    //length\n\n    constructor(data) {\n        super(data);\n        this.data.name = data.operationName;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        //if (typeof this.basePoint === \"undefined\")\n        //    this.basePoint = this.patternPiece.getObject(d.basePoint);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n            \n        if (typeof this.angle === \"undefined\")\n            this.angle = this.patternPiece.newFormula(d.angle);\n            \n        //Convert degrees to radians\n        //this.p = this.basePoint.p.pointAtDistanceAndAngleRad(this.length.value(), Math.PI * 2 * this.angle.value() / 360);\n        //this.line = new GeoLine(this.basePoint.p, this.p);\n        //bounds.adjustForLine(this.line);\n    }\n\n\n    draw( g, isOutline ) {\n        //g is the svg group\n        //this.drawLine( g ); //TODO put an arrow head on this!\n        //this.drawDot( g );\n        //this.drawLabel( g );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                    + 'Move operation: ' + this.data.length.htmlLength( asFormula ) \n                    //\" from \" + this.basePoint.data.name +\n                    + \" angle:\" + this.data.angle.htmlAngle( asFormula ) \n                    + \" suffix:\" + this.data.suffix;\n    }\n\n\n    applyOperationToPoint( p ) {\n        //Convert degrees to radians\n        var result = p.pointAtDistanceAndAngleDeg( this.length.value(), this.angle.value() );\n        //var line = new GeoLine( source.p, result.p );\n        return result;\n    }\n\n\n    setDependencies( dependencies ) {\n        //dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.length );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","class OperationResult extends DrawingObject {\n\n    //basePoint\n    //fromOperation\n\n    constructor(data) {\n        super(data);\n        this.data.name = data.derivedName;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.patternPiece.getObject(d.basePoint);\n\n        if (typeof this.fromOperation === \"undefined\")\n            this.fromOperation = this.patternPiece.getObject(d.fromOperation);\n\n        //if this.basePoint is a point... (if a curve, this is the midpoint)\n        if ( this.basePoint.p )\n            this.p = this.fromOperation.applyOperationToPoint( this.basePoint.p );\n\n        var operation = this.fromOperation;\n        var applyOperationToPointFunc = function( p ) {\n            return operation.applyOperationToPoint( p );\n        };\n\n        //else if this.basePoint.curve is a GeoSpline...\n        if ( this.basePoint.curve instanceof GeoSpline )\n        {\n            //so we get this captured and can just pass the function around\n            this.curve = this.basePoint.curve.applyOperation( applyOperationToPointFunc );\n        }\n        else if ( this.basePoint.line instanceof GeoLine ) //untested?\n        {\n            this.line = this.basePoint.line.applyOperation( applyOperationToPointFunc );\n        }\n        //TODO we might also have operated on an arc, circle, ellipse? Some might required a different approach that needs to be aligned with original behaviour\n\n        //This line would be useful if the operation, or operation result is selected. \n        //this.operationLine = new GeoLine(this.basePoint.p, this.p);\n\n        bounds.adjust( this.p );\n    }\n\n\n    getColor() {\n        return this.basePoint.getColor();\n    }\n\n    \n    getLineStyle() {\n        return this.basePoint.getLineStyle();\n    }\n\n\n    draw( g, isOutline ) {\n        //g is the svg group\n\n        //We might have operated on a point, spline (or presumably line)\n\n        if ( this.p )\n            this.drawDot( g, isOutline );\n\n        if ( this.curve )\n            this.drawCurve( g, isOutline ); \n\n        //TODO we might also have operated on an arc, circle, ellipse?\n\n        if ( this.line )\n            this.drawLine( g, isOutline ); \n            \n        if ( this.p )\n            this.drawLabel( g, isOutline );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'Operation ' + this.refOf( this.fromOperation )\n                + ' on ' + this.refOf( this.basePoint ); \n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.fromOperation );\n    }    \n\n}\n","class OperationRotate extends DrawingObject {\n\n    //operationName\n    //suffix\n    //angle\n    //center\n\n    constructor(data) {\n        super(data);\n        this.data.name = data.operationName;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.center === \"undefined\")\n            this.center = this.patternPiece.getObject(d.center);\n            \n        if (typeof this.angle === \"undefined\")\n            this.angle = this.patternPiece.newFormula(d.angle);            \n    }\n\n\n    draw( g, isOutline ) {\n        //g is the svg group\n        //this.drawLine( g ); //TODO put an arrow head on this!\n        //this.drawDot( g );\n        //this.drawLabel( g );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'Move rotate: ' \n                + \" center: \" + this.refOf( this.center ) \n                + \" angle:\" + this.data.angle.htmlAngle( asFormula ) \n                + \" suffix:\" + this.data.suffix;\n    }\n\n\n    applyOperationToPoint( p ) {\n        return p.rotate( this.center.p, this.angle.value() );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.center );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","class PerpendicularPointAlongLine extends DrawingObject {\n\n    //basePoint\n    //firstPoint\n    //secondPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.patternPiece.getObject(d.basePoint);\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.p1Line1);\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.p2Line1);\n\n        var line = new GeoLine(this.firstPoint.p, this.secondPoint.p);\n        \n        var baseLine = new GeoLine( this.basePoint.p, this.basePoint.p.pointAtDistanceAndAngleDeg( 1, line.angleDeg() + 90 ) );\n\n        this.p = line.intersect(baseLine);\n        this.line = new GeoLine( this.basePoint.p, this.p );\n\n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, isOutline ) {\n        //g is the svg group\n        this.drawLine( g, isOutline );\n        this.drawDot( g, isOutline );\n        this.drawLabel( g, isOutline );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'Point along line ' + this.refOf( this.firstPoint ) + ' - ' + this.refOf( this.secondPoint )\n                + ' where it is perpendicular to ' + this.refOf( this.basePoint );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.basePoint );\n    }    \n\n}\n","class PointAlongBisector extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n    //thirdPoint\n    //length\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.firstPoint);\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.secondPoint);\n        if (typeof this.thirdPoint === \"undefined\")\n            this.thirdPoint = this.patternPiece.getObject(d.thirdPoint);\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n            \n        var line1 = new GeoLine( this.secondPoint.p, this.firstPoint.p );    \n        var line2 = new GeoLine( this.secondPoint.p, this.thirdPoint.p );    \n\n        //TODO test what happens when this crosses the equator! i.e. one point is just below the equator and one just above (and in either direction)\n        var bisectingAngle = ( line1.angleDeg() + line2.angleDeg() ) /2;\n\n        //Convert degrees to radians\n        this.p = this.secondPoint.p.pointAtDistanceAndAngleDeg( this.length.value(), bisectingAngle );\n        this.line = new GeoLine(this.secondPoint.p, this.p);\n\n        bounds.adjustForLine(this.line);\n    }\n\n\n    draw( g, isOutline ) {\n        //g is the svg group\n        this.drawLine( g, isOutline );\n        this.drawDot( g, isOutline );\n        this.drawLabel( g, isOutline );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + this.data.length.htmlLength( asFormula ) \n                + \" along line bisecting \" + this.refOf( this.secondPoint ) \n                + \"-\" + this.refOf( firstPoint )\n                + \" and \" + this.refOf( this.secondPoint ) \n                + \"-\" + this.refOf( this.thirdPoint );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.thirdPoint );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","class PointAlongLine extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n    //length\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.firstPoint);\n\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.secondPoint);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n\n        this.baseLine = new GeoLine(this.firstPoint.p, this.secondPoint.p);\n        this.p = this.firstPoint.p.pointAtDistanceAndAngleRad(this.length.value(this.baseLine.length), this.baseLine.angle);\n        this.line = new GeoLine(this.firstPoint.p, this.p);\n        \n        bounds.adjustForLine(this.line);\n    }\n\n\n    draw( g, isOutline ) {\n        this.drawLine( g, isOutline );\n        this.drawDot( g, isOutline );\n        this.drawLabel( g, isOutline );\n    }\n\n\n    html( asFormula ) {\n        \n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + this.data.length.htmlLength( asFormula, this.baseLine? this.baseLine.length : 0 ) \n                + \" along line from \" + this.refOf( this.firstPoint )\n                + \" to \" + this.refOf( this.secondPoint );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","class PointAlongPerpendicular extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n    //length\n    //angle\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.firstPoint);\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.secondPoint);\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n        if (typeof this.angle === \"undefined\")\n            this.angle = this.patternPiece.newFormula(d.angle);\n            \n        var baseLine = new GeoLine( this.firstPoint.p, this.secondPoint.p );    \n        var totalAngle = this.angle.value() + 90 + baseLine.angleDeg();\n        //Convert degrees to radians\n        this.p = this.firstPoint.p.pointAtDistanceAndAngleDeg( this.length.value(), totalAngle );\n        this.line = new GeoLine(this.firstPoint.p, this.p);\n        bounds.adjustForLine(this.line);\n    }\n\n\n    draw( g , isOutline ) {\n        //g is the svg group\n        this.drawLine( g, isOutline );\n        this.drawDot( g, isOutline );\n        this.drawLabel( g, isOutline );\n    }\n\n\n    html( asFormula ) {\n        var h = '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + this.data.length.htmlLength( asFormula ) \n                + \" from \" + this.refOf( this.firstPoint ) \n                + \" perpendicular to the line to \" + this.refOf( this.secondPoint );\n\n        if (    ( this.data.angle.constant )\n             && ( this.data.angle.constant != 0 ) )\n            h += \" additional angle \" + this.data.angle.htmlAngle( asFormula );\n\n        return h;\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.length );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","class PointCutArc extends DrawingObject {\n\n    //arc\n    //length\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.arc === \"undefined\")\n            this.arc = this.patternPiece.getObject(d.arc);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n\n        this.p = this.arc.pointAlongPath( this.length.value() );\n        \n        bounds.adjust(this.p);\n    }\n\n    \n    draw( g, isOutline ) {\n        this.drawDot( g, isOutline );\n        this.drawLabel( g, isOutline );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + this.data.length.htmlLength( asFormula ) \n                + \" along arc \" + this.refOf( this.arc );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.arc );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","class PointCutSplinePath extends DrawingObject {\n\n    //splinePath\n    //length\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.splinePath === \"undefined\")\n            this.splinePath = this.patternPiece.getObject(d.splinePath);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n\n        this.p = this.splinePath.pointAlongPath( this.length.value() );\n        \n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, isOutline ) {\n        this.drawDot( g, isOutline );\n        this.drawLabel( g, isOutline );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + this.data.length.htmlLength( asFormula ) \n                + \" along path \" + this.refOf( this.splinePath );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.splinePath );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","class PointEndLine extends DrawingObject {\n\n    //basePoint\n    //length\n    //angle\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.patternPiece.getObject(d.basePoint);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n            \n        if (typeof this.angle === \"undefined\")\n            this.angle = this.patternPiece.newFormula(d.angle);\n            \n        //Convert degrees to radians\n        this.p = this.basePoint.p.pointAtDistanceAndAngleDeg( this.length.value(), this.angle.value() );\n        this.line = new GeoLine(this.basePoint.p, this.p);\n        \n        bounds.adjustForLine(this.line);\n    }\n\n\n    draw( g, isOutline ) {\n        this.drawLine( g, isOutline );\n        this.drawDot( g, isOutline );\n        this.drawLabel( g, isOutline );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + this.data.length.htmlLength( asFormula ) \n                + \" from \" + this.refOf( this.basePoint ) \n                + \" angle \" + this.data.angle.htmlAngle( asFormula );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.length );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","class PointFromArcAndTangent extends DrawingObject {\n\n    //arc\n    //tangent\n    //crossPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.tangent === \"undefined\")\n            this.tangent = this.patternPiece.getObject(d.tangent);\n\n        if (typeof this.arc === \"undefined\")\n            this.arc = this.patternPiece.getObject(d.arc); \n\n        this.crossPoint = d.crossPoint;\n\n        var tangentIntersections = this.arc.arc.getPointsOfTangent( this.tangent.p );\n        \n        //TODO what is the real logic for crossPoint One vs Two\n        if ( this.crossPoint === \"One\" ) \n            this.p = tangentIntersections[1];\n        else \n            this.p = tangentIntersections[0];\n            \n        this.line = new GeoLine( this.tangent.p, this.p );\n\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, isOutline ) {\n        this.drawLine(g, isOutline);\n        this.drawDot(g, isOutline);\n        this.drawLabel(g, isOutline);\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + 'point on arc ' + this.refOf( this.arc ) //derivedName?\n                + ' of tangent from point ' + this.refOf( this.tangent )\n                + ' crosspoint:' + this.crossPoint;\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.tangent );\n        dependencies.add( this, this.arc );\n    }    \n\n}\n","class PointFromCircleAndTangent extends DrawingObject {\n\n    //center\n    //tangent\n    //crossPoint\n    //radius\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.tangent === \"undefined\")\n            this.tangent = this.patternPiece.getObject(d.tangent);\n\n        if (typeof this.arc === \"undefined\")\n            this.center = this.patternPiece.getObject(d.center); \n\n        if (typeof this.radius === \"undefined\")\n            this.radius = this.patternPiece.newFormula(d.radius);\n\n        this.crossPoint = d.crossPoint;\n\n        var circle = new GeoArc( this.center.p, this.radius.value(), 0, 360 );\n\n        var tangentIntersections = circle.getPointsOfTangent( this.tangent.p );\n        \n        //TODO what is the real logic for crossPoint One vs Two\n        if ( this.crossPoint === \"One\" ) \n            this.p = tangentIntersections[1];\n        else \n            this.p = tangentIntersections[0];\n            \n        this.line = new GeoLine( this.tangent.p, this.p );\n\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, isOutline) {\n        this.drawLine(g, isOutline);\n        this.drawDot(g, isOutline);\n        this.drawLabel(g, isOutline);\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + 'point on circle with center ' + this.refOf( this.center ) \n                + ' radius ' + this.radius.htmlLength( asFormula ) \n                + ' of tangent from point ' + this.refOf( this.tangent )\n                + ' crosspoint:' + this.crossPoint;\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.tangent );\n        dependencies.add( this, this.center );\n        dependencies.add( this, this.radius );\n    }    \n\n}\n","class PointFromXandYOfTwoOtherPoints extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.firstPoint);\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.secondPoint);\n\n        this.p = new GeoPoint( this.firstPoint.p.x, this.secondPoint.p.y );\n        //this.line = new GeoLine(this.firstPoint.p, this.secondPoint.p);\n\n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, isOutline ) {\n        //TODO check that there is no option to draw a line as part of this tool. \n        this.drawDot( g, isOutline );\n        this.drawLabel( g, isOutline );\n    }\n\n\n    html( asFormula ) {\n        return 'line ' + this.refOf( this.firstPoint ) +  \" - \" + this.refOf( this.secondPoint );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n    }    \n}\n","class PointIntersectArcAndAxis extends DrawingObject {\n\n    //arc (provided as \"curve\"), and may be an arc or a spline (ob observation)\n    //basePoint\n    //angle\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.patternPiece.getObject(d.basePoint);\n\n        if (typeof this.arc === \"undefined\")\n            this.arc = this.patternPiece.getObject(d.curve); //An anomaly, would be better if this were arc.\n\n        if (typeof this.angle === \"undefined\")\n            this.angle = this.patternPiece.newFormula(d.angle);\n\n        var angleDeg = this.angle.value();\n        if ( angleDeg >= 360 )\n            angleDeg -= 360;\n        else if ( angleDeg < 0 )\n            angleDeg += 360;\n\n            //TODO replace 1000 with a calculation of the longest line that may be needed\n        let otherPoint = this.basePoint.p.pointAtDistanceAndAngleDeg( 1000/*infinite*/, angleDeg );\n\n        var longLine = new GeoLine( this.basePoint.p, otherPoint );\n\n        if ( this.arc.arc )\n            this.p = longLine.intersectArc( this.arc.arc );\n        else\n            this.p = longLine.intersectArc( this.arc.curve );\n\n\n        this.line = new GeoLine( this.basePoint.p, this.p );\n\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, isOutline) {\n        //g is the svg group\n        this.drawLine(g, isOutline);\n        this.drawDot(g, isOutline);\n        this.drawLabel(g, isOutline);\n    }\n\n\n    html( asFormula ) {\n        //TODO use a better name for this.curve, e.g. Arc_A_nn\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'intersect arc ' + this.refOf( this.arc )\n                + \" with line from \" + this.refOf( this.basePoint ) \n                + \" at angle \" + this.angle.htmlAngle( asFormula );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.arc );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","class PointIntersectArcAndLine extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n    //center\n    //radius\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.firstPoint);\n            \n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.secondPoint);\n\n        if (typeof this.center === \"undefined\")\n            this.center = this.patternPiece.getObject(d.center);\n\n        if (typeof this.radius === \"undefined\")\n            this.radius = this.patternPiece.newFormula(d.radius);\n\n        var line = new GeoLine( this.firstPoint.p, this.secondPoint.p );\n        var arc  = new GeoArc( this.center.p, this.radius.value(), 0, 360 );\n\n        this.p = line.intersectArc( arc );\n\n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, isOutline ) {\n\n        //TODO draw the line between basePoint and p\n        this.drawDot( g, isOutline );\n        this.drawLabel( g, isOutline );\n    }\n\n\n    html( asFormula ) {\n        \n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + 'intersect arc with center ' \n                + this.refOf( this.center ) \n                + \", radius \" + this.radius.htmlLength( asFormula ) \n                +  \" with line \" + this.refOf( this.firstPoint ) \n                + \"-\" + this.refOf( this.secondPoint );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.center );\n        dependencies.add( this, this.radius );\n    }    \n\n}\n","class PointIntersectArcs extends DrawingObject {\n\n    //firstArc\n    //secondArc\n    //crossPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstArc === \"undefined\")\n            this.firstArc = this.patternPiece.getObject(d.firstArc);\n            \n        if (typeof this.secondArc === \"undefined\")\n            this.secondArc = this.patternPiece.getObject(d.secondArc);\n\n        //Also this.data.crossPoint    \n\n        var arc1SI = this.firstArc.asShapeInfo();\n        var arc2SI = this.secondArc.asShapeInfo();\n\n        var intersections = Intersection.intersect(arc1SI, arc2SI);\n        \n        //intersections.points.forEach(console.log);    \n        \n        if ( intersections.points.length === 0 )\n        {\n            throw \"No intersections found. \";\n        }\n        else if ( intersections.points.length === 1 )\n        {\n            this.p = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n        }\n        else\n        {\n            //TODO A5 in the test should be (0,0) as the point of intersection is not during the specified angle of the arcs.\n            //For each intersection point\n            //TODO check that GeoLine( this.firstArc.center.p, p1)).angleDeg() between this.firstArc.arc.angle1 and this.firstArc.arc.angle2\n            //and similar for secondArc\n\n            //What is the angle in the first arc of the intersection point?\n            //One = smallest angle in the first arc.\n            //Two = largest angle in the first arc.\n            var p1 = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n            var p2 = new GeoPoint( intersections.points[1].x, intersections.points[1].y );\n            var angle1 = (new GeoLine( this.firstArc.center.p, p1)).angle;\n            var angle2 = (new GeoLine( this.firstArc.center.p, p2)).angle;\n\n            if ( this.data.crossPoint === \"One\" )\n            {\n                if ( angle1 < angle2 )\n                    this.p = p1;\n                else\n                    this.p = p2;\n            }            \n            else \n            {\n                if ( angle1 < angle2 )\n                    this.p = p2;\n                else\n                    this.p = p1;\n            }\n        }\n\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, isOutline) {\n        this.drawDot(g, isOutline);\n        this.drawLabel(g, isOutline);\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'intersect arcs ' + this.refOf( this.firstArc )\n                + \" and \" + this.refOf( this.secondArc )\n                + ( this.data.crossPoint === \"One\" ? \"\" : \" - second point\");\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstArc );\n        dependencies.add( this, this.secondArc );\n    }    \n\n}\n","class PointIntersectCircles extends DrawingObject {\n\n    //center1     ??? Confirm\n    //radiu1   ??? Confirm\n    //center2   ??? Confirm\n    //radius2  ??? Confirm\n    //crossPoint    ??? Confirm\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.center1 === \"undefined\")\n            this.center1 = this.patternPiece.getObject(d.center1);\n            \n        if (typeof this.center2 === \"undefined\")\n            this.center2 = this.patternPiece.getObject(d.center2);\n\n        if (typeof this.radius1 === \"undefined\")\n            this.radius1 = this.patternPiece.newFormula(d.radius1);\n\n        if (typeof this.radius2 === \"undefined\")\n            this.radius2 = this.patternPiece.newFormula(d.radius2);\n\n        //Also this.data.crossPoint    \n        var circle1 = new GeoArc( this.center1.p, this.radius1.value(), 0, 360 );\n        var circle2 = new GeoArc( this.center2.p, this.radius2.value(), 0, 360 );\n\n        var arc1SI = circle1.asShapeInfo();\n        var arc2SI = circle2.asShapeInfo();\n\n        var intersections = Intersection.intersect(arc1SI, arc2SI);\n        \n        //intersections.points.forEach(console.log);    \n        \n        if ( intersections.points.length === 0 )\n        {\n            throw \"No intersections found. \";\n        }\n        else if ( intersections.points.length === 1 )\n        {\n            //surely there must always be two intersects, unless they just touch\n            this.p = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n        }\n        else\n        {\n            /* we do not know what logic valentina/seamly uses\n\n            the smallest angle, except that if angle1 beween 270 and 360 and angle2 between 0 and 90 then add 360 to angle2. */\n\n            //NB: this is a subset of the logic that applies to PointIntersectArcs.\n            //What is the angle in the first arc of the intersection point?\n            //One = smallest angle in the first arc.\n            //Two = largest angle in the first arc.\n            var p1 = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n            var p2 = new GeoPoint( intersections.points[1].x, intersections.points[1].y );\n            var angle1 = (new GeoLine( circle1.center, p1)).angleDeg();\n            var angle2 = (new GeoLine( circle1.center, p2)).angleDeg();\n            if (( angle1 >= 270 ) && ( angle2 > 0 ) && ( angle2 < 90 ))\n                angle2 += 360;\n            else if (( angle2 >= 270 ) && ( angle1 > 0 ) && ( angle1 < 90 ))\n                angle1 += 360;\n\n            if ( this.data.crossPoint === \"One\" )\n            {\n                if ( angle1 < angle2 )\n                    this.p = p1;\n                else\n                    this.p = p2;\n            }            \n            else \n            {\n                if ( angle1 < angle2 )\n                    this.p = p2;\n                else\n                    this.p = p1;\n            }\n            \n           /*\n            //this is just a guess.. TODO what happens if the two y's are the same??\n            var p1 = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n            var p2 = new GeoPoint( intersections.points[1].x, intersections.points[1].y );\n            if ( this.data.crossPoint === \"One\" )\n            {\n                if ( p1.y < p2.y )\n                    this.p = p2;\n                else\n                    this.p = p1;\n            }\n            else\n            {\n                if ( p1.y < p2.y )\n                    this.p = p1;\n                else\n                    this.p = p2;\n            }\n            */\n        }\n\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, isOutline) {\n        this.drawDot(g, isOutline);\n        this.drawLabel(g, isOutline);\n    }\n\n\n    html( asFormula ) {\n        //TODO use a better name for this.arc, e.g. Arc_A_nn\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'intersect circles ' + this.refOf( this.center1 ) \n                + \" radius \" + this.radius1.htmlAngle( asFormula ) \n                + \" and \" + this.refOf( this.center2 ) \n                + \" radius \" + this.radius2.htmlLength( asFormula )\n                + ( this.data.crossPoint === \"One\" ? \"\" : \" - second point\");\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.center1 );\n        dependencies.add( this, this.center2 );\n        dependencies.add( this, this.radius1 );\n        dependencies.add( this, this.radius2 );\n    }    \n\n}\n","class PointIntersectCurveAndAxis extends DrawingObject {\n\n    //basePoint\n    //curve\n    //angle\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.patternPiece.getObject(d.basePoint);\n\n        if (typeof this.curve === \"undefined\")\n            this.curve = this.patternPiece.getObject(d.curve);\n\n        if (typeof this.angle === \"undefined\")\n            this.angle = this.patternPiece.newFormula(d.angle);\n\n        var angleDeg = this.angle.value();\n        if ( angleDeg >= 360 )\n            angleDeg -= 360;\n        else if ( angleDeg < 0 )\n            angleDeg += 360;\n\n        let otherPoint = this.basePoint.p.pointAtDistanceAndAngleDeg( 1000/*infinite TODO*/, angleDeg );\n\n        var line = new GeoLine( this.basePoint.p, otherPoint );\n\n        var lineSI = line.asShapeInfo();\n        var curveSI = this.curve.asShapeInfo();\n\n        var intersections = Intersection.intersect(lineSI, curveSI);        \n\n        if ( intersections.points.length === 0 )\n        {\n            throw \"No intersections found. \";\n        }\n        else\n        {\n            //intersections.points.forEach(console.log);    \n            this.p = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n        }\n        this.line = new GeoLine( this.basePoint.p, this.p );\n\n        bounds.adjust(this.p);\n    }\n\n    \n    draw(g, isOutline) {\n        //g is the svg group\n        this.drawLine(g, isOutline); \n        this.drawDot(g, isOutline);\n        this.drawLabel(g, isOutline);\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'intersect curve ' + this.refOf( this.curve )\n                + \" with line from \" + this.refOf( this.basePoint )\n                + \" at angle \" + this.angle.htmlAngle( asFormula );\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.curve );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","class PointIntersectCurves extends DrawingObject {\n\n    //curve1\n    //curve2\n    //verticalCrossPoint\n    //horizontalCrossPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.curve1 === \"undefined\")\n            this.curve1 = this.patternPiece.getObject(d.curve1);\n            \n        if (typeof this.curve2 === \"undefined\")\n            this.curve2 = this.patternPiece.getObject(d.curve2);\n\n        var curve1SI = this.curve1.asShapeInfo();\n        var curve2SI = this.curve2.asShapeInfo();\n\n        var intersections = Intersection.intersect(curve1SI, curve2SI);\n        \n        //intersections.points.forEach(console.log);    \n        if ( intersections.points.length === 0 )\n        {\n            this.p = new GeoPoint(0,0);\n            this.error = \"No intersections found.\";\n            console.log( \"No intersections found. PointIntersectCurves: \" + d.name );\n        }        \n        else if ( intersections.points.length === 1 )\n        {\n            this.p = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n        }\n        else if ( intersections.points.length > 1 )    \n        {\n            //Vertical correction has first dibs. verticalCrossPoint==\"One\" means highest point; horizontalCrossPoint==\"One\" means leftmost point\n            var minXPnt, maxXPnt, minYPnt, maxYPnt;\n            for ( var i = 0; i<intersections.points.length; i++ )\n            {\n                var intersect = intersections.points[i];\n                if (( ! minXPnt ) || ( intersect.x < minXPnt.x ))\n                    minXPnt = intersect;\n                if (( ! maxXPnt ) || ( intersect.x > maxXPnt.x ))\n                    maxXPnt = intersect;\n                if (( ! minYPnt ) || ( intersect.y < minYPnt.y ))\n                    minYPnt = intersect;\n                if (( ! maxYPnt ) || ( intersect.y > maxYPnt.y ))\n                    maxYPnt = intersect;\n            }\n            if ( minYPnt !== maxYPnt )\n            {\n                if ( this.data.verticalCrossPoint === \"One\" )\n                    this.p = minYPnt;\n                else\n                    this.p = maxYPnt;\n            }\n            else\n            {\n                if ( this.data.horizontalCrossPoint === \"One\" )\n                    this.p = minXPnt;\n                else\n                    this.p = maxXPnt;\n            }\n        }\n\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, isOutline) {\n        this.drawDot(g, isOutline);\n        this.drawLabel(g, isOutline);\n    }\n\n\n    html( asFormula ) {\n        //TODO use a better name for this.curve, e.g. Arc_A_nn\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'intersect curve ' + this.refOf( this.curve1 ) \n                + \" with \" + this.refOf( this.curve2 );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.curve1 );\n        dependencies.add( this, this.curve2 );\n    }    \n\n}\n","class PointIntersectLineAndAxis extends DrawingObject {\n\n    //basePoint\n    //p1Line1\n    //p2Line1\n    //angle\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.patternPiece.getObject(d.basePoint);\n\n        if (typeof this.p1Line1 === \"undefined\")\n            this.p1Line1 = this.patternPiece.getObject(d.p1Line1);\n\n        if (typeof this.p2Line1 === \"undefined\")\n            this.p2Line1 = this.patternPiece.getObject(d.p2Line1);\n\n        if (typeof this.angle === \"undefined\")\n            this.angle = this.patternPiece.newFormula(d.angle);\n\n\n        var line1 = new GeoLine(this.p1Line1.p, this.p2Line1.p);\n\n        var otherPoint = this.basePoint.p.pointAtDistanceAndAngleDeg( 1, this.angle.value() );\n\n        var line2 = new GeoLine(this.basePoint.p, otherPoint );\n\n        this.p = line1.intersect(line2);\n        this.line = new GeoLine( this.basePoint.p, this.p );\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, isOutline) {\n        this.drawLine( g, isOutline );\n        this.drawDot( g, isOutline );\n        this.drawLabel( g, isOutline );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + ' intersection of ' + this.refOf( this.p1Line1 ) \n                + \"-\" + this.refOf( this.p2Line1 ) \n                + \" with line from \" + this.refOf( this.basePoint ) \n                + \" at angle \" + this.angle.htmlAngle( asFormula );\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.p1Line1 );\n        dependencies.add( this, this.p2Line1 );\n        dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.angle );\n    }    \n\n\n}\n","class PointLineIntersect extends DrawingObject {\n\n    //p1Line1\n    //p2Line1\n    //p1Line2\n    //p2Line2\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.p1Line1 === \"undefined\")\n            this.p1Line1 = this.patternPiece.getObject(d.p1Line1);\n        if (typeof this.p2Line1 === \"undefined\")\n            this.p2Line1 = this.patternPiece.getObject(d.p2Line1);\n        if (typeof this.p1Line2 === \"undefined\")\n            this.p1Line2 = this.patternPiece.getObject(d.p1Line2);\n        if (typeof this.p2Line2 === \"undefined\")\n            this.p2Line2 = this.patternPiece.getObject(d.p2Line2);\n\n        this.line1 = new GeoLine(this.p1Line1.p, this.p2Line1.p);\n        this.line2 = new GeoLine(this.p1Line2.p, this.p2Line2.p);\n        this.p = this.line1.intersect(this.line2);\n\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, isOutline) {\n        this.drawDot(g, isOutline);\n        this.drawLabel(g, isOutline);\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'intersect ' + this.refOf( this.p1Line1 )\n                + \"-\" + this.refOf( this.p2Line1 ) \n                + \" with \" + this.refOf( this.p1Line2 ) \n                + \"-\" + this.refOf( this.p2Line2 );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.p1Line1 );\n        dependencies.add( this, this.p1Line2 );\n        dependencies.add( this, this.p2Line1 );\n        dependencies.add( this, this.p2Line2 );\n    }    \n\n\n}\n","class PointOfTriangle extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n    //p1Line1\n    //p2Line1\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.firstPoint);\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.secondPoint);\n\n        if (typeof this.p1Line1 === \"undefined\")\n            this.p1Line1 = this.patternPiece.getObject(d.p1Line1);\n        if (typeof this.p2Line1 === \"undefined\")\n            this.p2Line1 = this.patternPiece.getObject(d.p2Line1);\n\n            \n        var axisLine = new GeoLine( this.p1Line1.p, this.p2Line1.p );    \n        var otherLine = new GeoLine( this.firstPoint.p, this.secondPoint.p );\n\n        //Now we work out another point along the axis line that forms the right angle triangle \n        //with the otherLine.\n        //\n        //The trick here is to observe that all these points, for any axisLine will form an arc\n        //centered on the midpoint of otherLine with radiu of half length of otherLine\n        var intersectionPoint = axisLine.intersect( otherLine );\n        var midpoint = this.firstPoint.p.pointAtDistanceAndAngleRad( otherLine.length/2, otherLine.angle );\n        var arc = new GeoArc( midpoint, otherLine.length/2, 0, 360 );    \n        var extendedAxis = new GeoLine( intersectionPoint, intersectionPoint.pointAtDistanceAndAngleRad( otherLine.length*2, axisLine.angle ) );\n        this.p = extendedAxis.intersectArc( arc );\n\n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, isOutline ) {\n        this.drawDot( g, isOutline );\n        this.drawLabel( g, isOutline );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + \" Point along \" + this.refOf( this.p1Line1 )\n                + \"-\" + this.refOf( this.p2Line1 )\n                + \" that forms a right angle triangle with line  \" + this.refOf( this.firstPoint )\n                + \"-\" + this.refOf( this.secondPoint );\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.p1Line1 );\n        dependencies.add( this, this.p2Line1 );\n    }    \n\n}\n","class PointShoulder extends DrawingObject {\n\n    //pShoulder\n    //p1Line1\n    //p2Line1\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.shoulderPoint === \"undefined\")\n            this.shoulderPoint = this.patternPiece.getObject(d.shoulderPoint);\n\n        if (typeof this.p1Line1 === \"undefined\")\n            this.p1Line1 = this.patternPiece.getObject(d.p1Line1);\n\n        if (typeof this.p2Line1 === \"undefined\")\n            this.p2Line1 = this.patternPiece.getObject(d.p2Line1);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n\n        //Find the point that is length away from the shoulderPoint along\n        //the line p1Line1-p2line1.\n            \n        var axisLine = new GeoLine( this.p1Line1.p, this.p2Line1.p );    \n        var arc = new GeoArc( this.shoulderPoint.p, this.length.value(), 0, 360  );      \n        var offset = new GeoLine( this.shoulderPoint.p, this.p1Line1.p );\n        var extendedAxisLength = this.length.value() + offset.length;\n        var extendedAxis = new GeoLine( this.p1Line1.p, this.p1Line1.p.pointAtDistanceAndAngleRad( 1000, axisLine.angle ) );\n        this.p = extendedAxis.intersectArc( arc );\n        this.line = new GeoLine( this.p1Line1.p, this.p );\n\n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, isOutline ) {\n        this.drawLine( g, isOutline );\n        this.drawDot( g, isOutline );\n        this.drawLabel( g, isOutline );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n            + \" Point along \" + this.refOf( this.p1Line1 ) \n            + \"-\" + this.refOf( this.p2Line1 )\n            + \" being \" + this.length.htmlLength( asFormula ) \n            + \" from \" + this.refOf( this.shoulderPoint );\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.shoulderPoint );\n        dependencies.add( this, this.p1Line1 );\n        dependencies.add( this, this.p2Line1 );\n    }    \n\n}\n","class PointSingle extends DrawingObject {\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n        this.p = new GeoPoint(d.x, d.y);\n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, isOutline ) {\n        this.drawDot(g, isOutline);\n        this.drawLabel(g, isOutline);\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>:' \n            + \" point at x:\" + this.data.x + \", y:\" + this.data.y + \" from origin\"; //TODO add units\n    }\n\n\n    setDependencies( dependencies ) {\n    }    \n\n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass SplinePathInteractive extends DrawingObject {\n\n    constructor(data) {\n        super(data);\n\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = this.data.derivedName;        \n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if ( typeof this.nodes === \"undefined\" )\n        {\n            this.nodes = [];\n            for( var i=0; i< d.pathNode.length; i++ )\n            {\n                var pathNode = this.data.pathNode[i];\n\n                pathNode.point   = this.patternPiece.getObject( pathNode.point );\n                pathNode.angle1  = this.patternPiece.newFormula( pathNode.angle1 ); \n                pathNode.length1 = this.patternPiece.newFormula( pathNode.length1 ); \n                pathNode.angle2  = this.patternPiece.newFormula( pathNode.angle2 ); \n                pathNode.length2 = this.patternPiece.newFormula( pathNode.length2 );\n\n                this.nodes.push( { inAngle:   pathNode.angle1.value(),\n                                    inLength:  pathNode.length1.value(),\n                                    point:     pathNode.point.p,\n                                    outAngle:  pathNode.angle2.value(),\n                                    outLength: pathNode.length2.value() } );\n            }\n        }\n\n        this.curve = new GeoSpline( this.nodes );\n\n        this.midPoint = this.curve.pointAlongPathFraction( 0.5 );        \n        this.p = this.midPoint;\n        bounds.adjust( this.p );\n    \n        //Bounds will already have been adjusted for each node\n    }\n\n    \n    asShapeInfo()\n    {\n        return this.curve.asShapeInfo();\n    }\n\n\n    draw( g, isOutline ) {\n\n        this.drawCurve(g, isOutline);\n\n        //Where should we draw the label? half way along the curve? \n        this.drawLabel(g, isOutline);\n    }\n\n\n    pointAlongPath( length ) {\n        return this.curve.pointAlongPath( length );\n    }   \n\n\n    html( asFormula ) {\n        var html = '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                    +'curved path:';\n\n        var d = this.data;\n        for( var i=0; i< d.pathNode.length; i++ )\n        {\n            if ( i>0 )\n                html+= \"; \";\n         \n            html += \"<br />\";    \n            html += this.refOf( d.pathNode[i].point ) + \" \" + \n                    d.pathNode[i].angle1.htmlAngle( asFormula ) + \" \" + \n                    d.pathNode[i].length1.htmlLength( asFormula ) + \" \" + \n                    d.pathNode[i].angle2.htmlAngle( asFormula ) + \" \" + \n                    d.pathNode[i].length2.htmlLength( asFormula );\n        }\n\n        return html;\n    }\n\n    \n    setDependencies( dependencies )\n    {\n        for( var i=0; i< this.data.pathNode.length; i++ )\n        {\n            var pathNode = this.data.pathNode[i];\n            dependencies.add( this, pathNode.point );\n            dependencies.add( this, pathNode.angle1 );\n            dependencies.add( this, pathNode.angle2 );\n            dependencies.add( this, pathNode.length1 );\n            dependencies.add( this, pathNode.length2 );\n        }        \n    }    \n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass SplinePathUsingPoints extends DrawingObject {\n\n    constructor(data) {\n        super(data);\n\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = this.data.derivedName;        \n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if ( typeof this.nodes === \"undefined\" )\n        {\n            this.nodes = [];\n\n            for( var i=0; i< d.pathNode.length; i++ )\n            {\n                this.data.pathNode[i].point = this.patternPiece.getObject( this.data.pathNode[i].point );\n            }\n\n            for( var i=0; i< d.pathNode.length; i+=3 )\n            {\n                this.nodes.push( { \n                                   inControlPoint:   (i-1)>0 ? this.data.pathNode[i-1].point.p : undefined,\n                                   point:            this.data.pathNode[i].point.p,\n                                   outControlPoint:  (i+1) < this.data.pathNode.length ? this.data.pathNode[i+1].point.p : undefined,\n                                   } );\n            }\n        }\n\n        this.curve = new GeoSpline( this.nodes );\n\n        this.midPoint = this.curve.pointAlongPathFraction( 0.5 );        \n        this.p = this.midPoint;\n        bounds.adjust( this.p );\n\n        //Bounds will already have been adjusted for each node\n    }\n\n    \n    asShapeInfo()\n    {\n        return this.curve.asShapeInfo();\n    }\n\n\n    draw( g, isOutline ) {\n        if ( this.lineVisible() )\n            this.drawPath( g, this.curve.svgPath(), isOutline );\n\n        //Where should we draw the label? half way along the curve? \n        this.drawLabel( g, isOutline );\n    }\n\n\n    pointAlongPath( length ) {\n        return this.curve.pointAlongPath( length );\n    }   \n\n\n    html( asFormula ) {\n        var html = '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'curved path: ';\n\n        var d = this.data;\n\n        for( var i=0; i< d.pathNode.length; i+=3 )\n        {\n            if ( (i-1)>0 )\n                html += this.refOf( this.data.pathNode[i-1].point );\n\n            html += d.pathNode[i].point.ref() + \" \";            \n\n            if ( (i+1) < this.data.pathNode.length )\n                html += this.refOf(  this.data.pathNode[i+1].point );\n        }\n\n        return html;\n    }\n\n    \n    setDependencies( dependencies )\n    {\n        for( var i=0; i< this.data.pathNode.length; i++ )\n        {\n            dependencies.add( this, this.data.pathNode[i].point );\n        }        \n    }    \n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass SplineSimple extends DrawingObject {\n\n    //startPoint - the spline start\n    //endPoint - the spline end\n    //angle1\n    //angle2 \n    //length1\n    //length2\n\n    constructor(data) {\n        super(data);\n\n        //TODO output a useful spline ID\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = this.data.derivedName;        \n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.startPoint === \"undefined\")\n            this.startPoint = this.patternPiece.getObject(d.point1);\n\n        if (typeof this.endPoint === \"undefined\")\n            this.endPoint = this.patternPiece.getObject(d.point4);\n\n        if (typeof this.angle1 === \"undefined\")\n            this.angle1 = this.patternPiece.newFormula(d.angle1);\n\n        if (typeof this.angle2 === \"undefined\")\n            this.angle2 = this.patternPiece.newFormula(d.angle2);\n\n        if (typeof this.length1 === \"undefined\")\n            this.length1 = this.patternPiece.newFormula(d.length1);\n\n        if (typeof this.length2 === \"undefined\")\n            this.length2 = this.patternPiece.newFormula(d.length2);\n\n        this.curve = new GeoSpline( [ { inAngle: undefined, inLength: undefined, point: this.startPoint.p, outAngle: this.angle1.value(), outLength: this.length1.value() },\n                                       { inAngle: this.angle2.value(), inLength: this.length2.value(), point: this.endPoint.p, outAngle: undefined, outLength: undefined } ] );\n\n        this.midPoint = this.curve.pointAlongPathFraction( 0.5 );        \n        this.p = this.midPoint;\n\n        bounds.adjust( this.startPoint );\n        bounds.adjust( this.endPoint );\n        bounds.adjust( this.midPoint ); \n    }\n\n    \n    asShapeInfo()\n    {\n        return this.curve.asShapeInfo();\n    }\n\n\n    draw( g, isOutline ) {\n        \n        if ( this.lineVisible() )\n            this.drawPath( g, this.curve.svgPath(), isOutline );\n\n        this.drawLabel( g, isOutline );\n    }\n\n\n    pointAlongPath( length ) {\n        return this.curve.pointAlongPath( length );\n    }   \n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'spline from ' + this.refOf( this.startPoint ) \n                + \" angle \" + this.angle1.htmlAngle( asFormula ) \n                + \" length \" + this.length1.htmlLength( asFormula )\n            + \" to \" + this.refOf( this.endPoint ) \n            + \" angle \" + this.angle2.htmlAngle( asFormula ) \n            + \" length \" + this.length2.htmlLength( asFormula );\n    }\n\n    \n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.startPoint );\n        dependencies.add( this, this.endPoint );\n        dependencies.add( this, this.angle1 );\n        dependencies.add( this, this.angle2 );\n        dependencies.add( this, this.length1 );\n        dependencies.add( this, this.length2 );\n    }    \n}\n","class SplineUsingControlPoints extends DrawingObject {\n\n    //startPoint - the spline start\n    //startControlPoint\n    //endPoint - the spline end\n    //endControlPoint\n\n    constructor(data) {\n        super(data);\n\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = this.data.derivedName;        \n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.startPoint === \"undefined\")\n            this.startPoint = this.patternPiece.getObject(d.point1);\n\n        if (typeof this.startControlPoint === \"undefined\")\n            this.startControlPoint = this.patternPiece.getObject(d.point2);\n\n        if (typeof this.endControlPoint === \"undefined\")\n            this.endControlPoint = this.patternPiece.getObject(d.point3);\n\n        if (typeof this.endPoint === \"undefined\")\n            this.endPoint = this.patternPiece.getObject(d.point4);\n\n        this.curve = new GeoSpline( [ { point: this.startPoint.p, outControlPoint: this.startControlPoint.p },\n                                      { inControlPoint: this.endControlPoint.p,  point: this.endPoint.p } ] );\n\n        this.midPoint = this.curve.pointAlongPathFraction( 0.5 );        \n        this.p = this.midPoint;\n\n        bounds.adjust( this.startPoint );\n        bounds.adjust( this.endPoint );\n        bounds.adjust( this.midPoint ); \n    }\n\n    \n    asShapeInfo() {\n        return this.curve.asShapeInfo();\n    }\n\n\n    draw( g, isOutline ) {\n\n        if ( this.lineVisible() )\n            this.drawPath( g, this.curve.svgPath(), isOutline );\n\n        //Where should we draw the label? half way along the curve?\n        //this.drawDot(g, isOutline);\n        this.drawLabel( g, isOutline );\n    }\n\n\n    pointAlongPath( length ) {\n        return this.curve.pointAlongPath( length );\n    }   \n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n            + 'spline from ' + this.refOf( this.startPoint )\n            + \" using control point \" + this.refOf( this.startControlPoint )\n            + \" to \" + this.refOf( this.endPoint )\n            + \" using control point \" + this.refOf( this.endControlPoint );\n    }\n\n    \n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.startPoint );\n        dependencies.add( this, this.startControlPoint );\n        dependencies.add( this, this.endPoint );\n        dependencies.add( this, this.endControlPoint );\n    }    \n}\n","class TrueDart extends DrawingObject {\n\n    //p1Line1  2 points making up the line on which the dart sits. \n    //p2Line1\n    //point1 3 points that make up a V shape of the original dart, point1 and point3 lie on the baseline\n    //point2\n    //point3\n\n    constructor(data) {\n        super(data);\n        this.data.name = data.operationName;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.point1 === \"undefined\")\n            this.point1 = this.patternPiece.getObject(d.point1);\n        if (typeof this.point2 === \"undefined\")\n            this.point2 = this.patternPiece.getObject(d.point2);\n        if (typeof this.point3 === \"undefined\")\n            this.point3 = this.patternPiece.getObject(d.point3);\n\n        if (typeof this.p1Line1 === \"undefined\")\n            this.p1Line1 = this.patternPiece.getObject(d.p1Line1);\n        if (typeof this.p2Line1 === \"undefined\")\n            this.p2Line1 = this.patternPiece.getObject(d.p2Line1);\n\n        var lineD2A1 = new GeoLine( this.point2.p, this.p1Line1.p );\n        var lineD2D1 = new GeoLine( this.point2.p, this.point1.p );    \n        var angleA1D2D1 = lineD2A1.angleRad() - lineD2D1.angleRad();\n        var lengthD2TD1 = Math.cos( angleA1D2D1 ) * lineD2A1.length;\n        this.td1 = this.point2.p.pointAtDistanceAndAngleRad( lengthD2TD1, lineD2D1.angleRad() );\n    \n        var lineD2A2 = new GeoLine( this.point2.p, this.p2Line1.p );\n        var lineD2D3 = new GeoLine( this.point2.p, this.point3.p );    \n        var angleA1D2D3 = lineD2D3.angleRad() - lineD2A2.angleRad();\n        var lengthD2TD3 = Math.cos( angleA1D2D3 ) * lineD2A2.length;\n        this.td3 = this.point2.p.pointAtDistanceAndAngleRad( lengthD2TD3, lineD2D3.angleRad() );\n\n        //Nb. this.data.trueDartResult1 and trueDartResult2 give the names of the dart points generated.\n\n        bounds.adjust(this.td1);\n        bounds.adjust(this.td3);\n    }\n\n\n    draw( g, isOutline ) {\n        //no!\n        //this.drawDotForSpecificPoint( g, isOutline, this.td3 );\n        //this.drawLabel( g, isOutline );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + \" True darts baseline \" + this.refOf( this.p1Line1 )\n                + \"-\" + this.refOf( this.p2Line1 )\n                + \" original dart \" + this.refOf( this.point1 )\n                + \"-\" + this.refOf( this.point2 )\n                + \"-\" + this.refOf( this.point3 );\n    }\n\n\n    setDependencies( dependencies )\n    {\n        //TODO these could get captured automaticallly if, in calculate, we did getObjectAndSetDependency( blah, this )\n        dependencies.add( this, this.point1 );\n        dependencies.add( this, this.point2 );\n        dependencies.add( this, this.point3 );\n        dependencies.add( this, this.p1Line1 );\n        dependencies.add( this, this.p2Line1 );\n    }    \n\n}\n","class TrueDartResult extends DrawingObject {\n\n    //fromOperation\n\n    constructor(data) {\n        super(data);\n        this.name = this.data.name;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.fromOperation === \"undefined\")\n            this.fromOperation = this.patternPiece.getObject(d.fromOperation);\n\n        if ( this.name === this.fromOperation.data.trueDartResult1 )\n            this.p = this.fromOperation.td1;\n        else\n            this.p = this.fromOperation.td3;\n\n            /*\n        //if this.basePoint is a point... (if a curve, this is the midpoint)\n        if ( this.basePoint.p )\n            this.p = this.fromOperation.applyOperationToPoint( this.basePoint.p );\n\n        var operation = this.fromOperation;\n        var applyOperationToPointFunc = function( p ) {\n            return operation.applyOperationToPoint( p );\n        };\n\n        //else if this.basePoint.curve is a GeoSpline...\n        if ( this.basePoint.curve instanceof GeoSpline )\n        {\n            //so we get this captured and can just pass the function around\n            this.curve = this.basePoint.curve.applyOperation( applyOperationToPointFunc );\n        }\n        else if ( this.basePoint.line instanceof GeoLine ) //untested?\n        {\n            this.line = this.basePoint.line.applyOperation( applyOperationToPointFunc );\n        }\n        //TODO we might also have operated on an arc, circle, ellipse? Some might required a different approach that needs to be aligned with original behaviour\n\n        //This line would be useful if the operation, or operation result is selected. \n        //this.operationLine = new GeoLine(this.basePoint.p, this.p);\n        */\n\n        bounds.adjust( this.p );\n    }\n\n\n    getColor() {\n        return this.basePoint.getColor();\n    }\n\n    \n    getLineStyle() {\n        return this.basePoint.getLineStyle();\n    }\n\n\n    draw( g, isOutline ) {\n\n        if ( this.p )\n            this.drawDot( g, isOutline );\n\n        //if ( this.line )\n        //    this.drawLine( g, isOutline ); \n            \n        if ( this.p )\n            this.drawLabel( g, isOutline );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'Dart point from ' + this.refOf( this.fromOperation );\n    }\n\n\n    setDependencies( dependencies ) {\n        //dependencies.add( this, this.basePoint );\n\n        //TODO add a dependency on D1/D3 depeending on\n        dependencies.add( this, this.fromOperation );\n    }    \n\n}\n","//(c) Copyright 2019 Jason Dore\n\nclass Pattern {\n\n    constructor (data, options ) {\n        this.data = data;\n        this.options = options;\n        this.patternData = data.pattern;\n        this.increment = {};\n        this.measurement = {};\n        this.units = this.patternData.units ? this.patternData.units : \"cm\";\n        this.wallpapers = data.wallpaper;\n        this.bounds = new Bounds();\n\n        if ( typeof this.patternData.measurement !== \"undefined\" )\n        {\n            for (var a = 0; a < this.patternData.measurement.length; a++) {\n                var m = this.patternData.measurement[a];\n\n                //TODO test this increment that is a simple value...            \n                if (typeof m.value !== \"undefined\") \n                {\n                    m.constant = m.value;\n                    m.value = function () {\n                        return this.constant;\n                    };\n                    m.html = function() {\n                        return this.constant;\n                    };\n                }\n                else\n                {\n                    m.expression = new Expression( m.expression, this, null );\n                    m.value = function () {\n                        return this.expression.value();\n                    };\n                    m.html = function() {\n                        return this.expression.html( asFormula );\n                    };\n                }\n                this.measurement[ m.name ] = m;\n            }\n        }        \n        \n        if ( typeof this.patternData.increment !== \"undefined\" )\n        {\n            for (var a = 0; a < this.patternData.increment.length; a++) {\n                var inc = this.patternData.increment[a];\n\n                //TODO test this increment that is a simple value...            \n                if (typeof inc.constant !== \"undefined\") \n                {\n                    inc.value = function () {\n                        return this.constant;\n                    };\n                    inc.html = function() {\n                        return this.constant;\n                    };\n                }\n                else\n                {\n                    inc.expression = new Expression( inc.expression, this, null );\n                    inc.value = function () {\n                        return this.expression.value();\n                    };\n                    inc.html = function() {\n                        return this.expression.html( asFormula );\n                    };\n                }\n                this.increment[ inc.name ] = inc;\n            }\n        }        \n\n        this.patternPieces = [];\n        for( var i=0; i<this.patternData.patternPiece.length; i++ )\n        {\n            this.patternPieces.push( new PatternPiece( this.patternData.patternPiece[i], this ) );\n        }   \n    }\n\n    getIncrement(name) {\n        if (typeof name === \"object\")\n            return name;\n        return this.increment[name];\n    }\n\n    getMeasurement(name) {\n        if (typeof name === \"object\")\n            return name;\n        var m = this.measurement[name];\n\n        if ( !m )\n            throw \"Measurment not found:\" + name;\n\n        return m;\n    }\n\n\n}","//(c) Copyright 2019 Jason Dore\n\nclass Bounds {\n    \n    constructor() {\n        this.minX = undefined;\n        this.maxX = undefined;\n        this.minY = undefined;\n        this.maxY = undefined;\n    }\n\n    adjust(p) {\n\n        if (!p)\n            return; //e.g. an error\n\n        var x = p.x;\n        var y = p.y;\n\n        if (x !== undefined) {\n            if ((this.minX === undefined) || (x < this.minX))\n                this.minX = x;\n            if ((this.maxX === undefined) || (x > this.maxX))\n                this.maxX = x;\n        }\n\n        if (y !== undefined) {\n            if ((this.minY === undefined) || (y < this.minY))\n                this.minY = y;\n            if ((this.maxY === undefined) || (y > this.maxY))\n                this.maxY = y;\n        }\n\n        if ( this.parent )\n            this.parent.adjust(p);\n    }\n\n    adjustForLine(line) {\n\n        if (!line)\n            return;\n\n        this.adjust(line.p1);\n        this.adjust(line.p2);\n    }\n}\n\n\nclass PatternPiece {\n\n    constructor (data, pattern) {\n        this.data = data;\n        this.drawing = {};\n        this.pattern = pattern;\n\n        if (data) {\n            this.name = data.name;\n            this.drawingObjects = data.drawingObject;\n        }\n        else {\n            this.drawingObjects = [];\n        }\n        this.bounds = new Bounds();\n        this.bounds.parent = pattern.bounds;\n        this.init();\n    }\n    \n    init() {\n        if (!this.data)\n            return;\n        //Take each drawingObject in the JSON and convert to the appropriate \n        //type of object.\n        for (var a = 0; a < this.drawingObjects.length; a++) {\n            var dObj = this.drawingObjects[a];\n            dObj = this.newDrawingObj(dObj);\n            if (dObj === null)\n                continue;\n            //    throw( \"Unknown objectType:\" + dObj.objectType );\n            this.drawingObjects[a] = dObj; //these are now the objects with methods\n            this.registerObj(dObj);\n        }\n        this.analyseDependencies();\n    }\n\n    analyseDependencies()\n    {\n        //Now build up dependency links\n        this.dependencies = { \n            dependencies: [], \n            add: function ( source, target ) { \n                if ( target && typeof target.expression === \"object\" )\n                    target.expression.addDependencies( source, this );\n                else if ( target instanceof DrawingObject )\n                    this.dependencies.push( { source: source, target: target } ); \n            }  \n        };\n        \n        for (var a = 0; a < this.drawingObjects.length; a++) \n        {\n            var dObj = this.drawingObjects[a];\n            dObj.setDependencies( this.dependencies );\n        }\n        //TODO use a d3.map of a d3.set when we build up the data and then convert it to an array\n        //so that we can remove duplicates.\n    }\n\n    getObject(name) {\n        if (typeof name === \"object\")\n            return name;\n        return this.drawing[name];\n    }\n\n    //TODO make this a static method of DrawingObject\n    newDrawingObj(dObj) {\n        if (dObj.objectType === \"pointSingle\")\n            return new PointSingle(dObj);\n        else if (dObj.objectType === \"pointEndLine\")\n            return new PointEndLine(dObj);\n        else if (dObj.objectType === \"pointAlongLine\")\n            return new PointAlongLine(dObj);\n        else if (dObj.objectType === \"pointAlongPerpendicular\")\n            return new PointAlongPerpendicular(dObj);\n        else if (dObj.objectType === \"pointAlongBisector\")\n            return new PointAlongBisector(dObj);            \n        else if (dObj.objectType === \"pointFromXandYOfTwoOtherPoints\")\n            return new PointFromXandYOfTwoOtherPoints(dObj);\n        else if (dObj.objectType === \"pointIntersectLineAndAxis\")\n            return new PointIntersectLineAndAxis(dObj);\n        else if (dObj.objectType === \"line\")\n            return new Line(dObj);\n        else if (dObj.objectType === \"pointLineIntersect\")\n            return new PointLineIntersect(dObj);\n        else if (dObj.objectType === \"pointIntersectArcAndAxis\")\n            return new PointIntersectArcAndAxis(dObj);\n        else if (dObj.objectType === \"pointIntersectArcAndLine\")\n            return new PointIntersectArcAndLine(dObj);\n        else if (dObj.objectType === \"perpendicularPointAlongLine\")\n            return new PerpendicularPointAlongLine(dObj);\n        else if (dObj.objectType === \"pointOfTriangle\")\n            return new PointOfTriangle(dObj);            \n        else if (dObj.objectType === \"pointShoulder\")\n            return new PointShoulder(dObj);            \n        else if (dObj.objectType === \"arcSimple\")\n            return new ArcSimple(dObj);\n        else if (dObj.objectType === \"arcElliptical\")\n            return new ArcElliptical(dObj);\n        else if (dObj.objectType === \"splineSimple\")\n            return new SplineSimple(dObj);\n        else if (dObj.objectType === \"splineUsingPoints\")\n            return new SplineUsingControlPoints(dObj);\n        else if (dObj.objectType === \"splinePathInteractive\")\n            return new SplinePathInteractive(dObj);\n        else if (dObj.objectType === \"splinePathUsingPoints\")\n            return new SplinePathUsingPoints(dObj);\n        else if (dObj.objectType === \"cutSpline\")   //SHOULD THIS BE pointCutSpline for consistency?\n            return new CutSpline(dObj);\n        else if (dObj.objectType === \"pointCutSplinePath\")\n            return new PointCutSplinePath(dObj);      \n        else if (dObj.objectType === \"pointCutArc\")\n            return new PointCutArc(dObj);                              \n        else if (dObj.objectType === \"pointIntersectCurves\")\n            return new PointIntersectCurves(dObj);      \n        else if (dObj.objectType === \"pointIntersectCurveAndAxis\")\n            return new PointIntersectCurveAndAxis(dObj);      \n        else if (dObj.objectType === \"pointIntersectArcs\")\n            return new PointIntersectArcs(dObj);      \n        else if (dObj.objectType === \"pointIntersectCircles\")\n            return new PointIntersectCircles(dObj);                  \n        else if (dObj.objectType === \"operationMove\")\n            return new OperationMove(dObj);                  \n        else if (dObj.objectType === \"operationRotate\")\n            return new OperationRotate(dObj);                  \n        else if (dObj.objectType === \"operationFlipByAxis\")\n            return new OperationFlipByAxis(dObj);                  \n        else if (dObj.objectType === \"operationResult\")\n            return new OperationResult(dObj);                  \n        else if (dObj.objectType === \"pointFromArcAndTangent\")\n            return new PointFromArcAndTangent(dObj);                  \n        else if (dObj.objectType === \"pointFromCircleAndTangent\")\n            return new PointFromCircleAndTangent(dObj);                  \n        else if (dObj.objectType === \"trueDart\")\n            return new TrueDart(dObj);                              \n        else if (dObj.objectType === \"trueDartResult\")\n            return new TrueDartResult(dObj);                              \n        else \n        {\n            var fail = new PointSingle( {x:0, y:0, contextMenu:dObj.contextMenu } );\n            fail.error =  \"Unsupported drawing object type:\" + dObj.objectType;\n            return fail;\n        }\n        //throw( \"Unsupported drawing object type:\" + dObj.objectType );\n\n        return null;\n    }\n\n    newFormula(formula) {\n\n        var patternUnits = this.pattern.units;\n        var f = formula;\n        if (typeof formula.constant !== \"undefined\") {\n            f.value = function () {\n                return this.constant;\n            };\n            f.html = function() {\n                return this.constant;\n            };\n            f.htmlLength = function() {\n                return '<span class=\"const\">' + this.constant + \" \" + patternUnits + '</span>';\n            };\n            f.htmlAngle = function() {\n                return '<span class=\"const\">' + this.constant + \"&#176;\" + '</span>';\n            };\n        }\n        else if (typeof formula.expression === \"object\") {\n            f.expression = new Expression( f.expression, this.pattern, this );\n            f.value = function (currentLength) {\n                return f.expression.value(currentLength);\n            };\n            f.html = function( asFormula, currentLength ) {\n                return f.expression.html( asFormula, currentLength );\n            };\n            f.htmlLength = function( asFormula, currentLength ) {\n                var s = f.expression.html( asFormula, currentLength );\n                if ( ! asFormula )\n                    s += \" \" + patternUnits;\n                return s;\n            };\n            f.htmlAngle = function( asFormula, currentLength ) {\n                var s = f.expression.html( asFormula, currentLength );\n                if ( ! asFormula )\n                  s += \"&#176;\";\n                return s;\n            };\n        }\n        return f;\n    }\n\n    registerObj(dObj) {\n        this.drawing[dObj.data.name] = dObj;\n        dObj.patternPiece = this;\n        if (typeof dObj.calculate !== \"undefined\") {\n            \n            try {\n                dObj.calculate(this.bounds);\n\n            } catch (e) {\n                dObj.error = \"Calculation failed. \" + e;\n            }\n\n        }\n    }\n\n    pointSingle(data) {\n        data.objectType = \"pointSingle\";\n        var dObj = this.add( data );\n        //var dObj = new PointSingle(data);\n        //this.drawingObjects.push(dObj);\n        //this.registerObj(dObj);\n        return dObj;\n    }\n\n    add(data) {\n        if (this.defaults) {\n            for (var d in this.defaults) {\n                if (typeof data[d] === \"undefined\")\n                    data[d] = this.defaults[d];\n            }\n        }\n        var dObj = this.newDrawingObj(data);\n        this.drawingObjects.push(dObj);\n        this.registerObj(dObj);\n        return dObj;\n    }\n\n    setDefaults(defaults) {\n        this.defaults = defaults;\n    }\n}\n\n","//(c) Copyright 2019 Jason Dore\n//\n//Inspired by the excellent Seamly2D/Valentina pattern drawing software.\n//This library is a ground up implementation in Javascript intended to be compatible with, but\n//not based on, the Seamly2D/Valentina pattern making systen in order to support the community\n//pattern sharing website https://my-pattern.cloud/ . \n//\n//Source maintained at: https://github.com/MrDoo71/PatternEditor\n\nvar selectedObject;\nvar linksGroup;\nvar fontsSizedForScale = 1;\nvar fontResizeTimer;\nvar updateServerTimer;\nvar timeOfLastTweak;\nvar doDrawingAndTable;\n\nfunction drawPattern( dataAndConfig, ptarget, graphOptions ) \n{\n    //Remove the svg if called by graph_kill\n    if ( dataAndConfig === null )\n    {\n        var parent = document.getElementById(ptarget).parentNode;\n        var child = document.getElementById(ptarget);\n        parent.removeChild(child);\n        return ;\n    } \n\n    //This is a graph initialisation\n\n    var pattern = new Pattern( dataAndConfig, graphOptions );            \n    \n    // show menu on right-click.\n    var contextMenu = typeof goGraph === \"function\" ? function(d) {\n   \t\td3.event.preventDefault() ;\n    \tvar v = newkvpSet(false) ;\n    \tv.add(\"x\", d.x) ;   \n    \tv.add(\"y\", d.y) ;    \n    \tgoGraph( graphOptions.interactionPrefix + ':' + d.data.contextMenu ,\n    \t\t\t d3.event, \n    \t\t\t v ) ;\n    } : function(d){};     \n    \n    var targetdiv = d3.select( \"#\" + ptarget )\n                       .append( \"div\" )\n                       .attr( \"class\", \"pattern-editor\" );\n\n    if ( ! dataAndConfig.options )\n        dataAndConfig.options = {};\n\n    var options = dataAndConfig.options;\n\n    if ( options.allowPanAndZoom === undefined )\n        options.allowPanAndZoom = true;\n\n    if ( options.showFormulas === undefined )\n        options.showFormulas = true;\n\n    if ( options.drawingTableSplit === undefined )\n        options.drawingTableSplit = 0.66;\n\n    if ( ! options.viewOption )\n        options.viewOption = [  { \"mode\":\"drawing\", \"icon\": \"icon-picture\",       \"drawingTableSplit\": 1.0 },\n                                { \"mode\":\"mixed\",   \"icon\": \"icon-columns\",       \"drawingTableSplit\": 0.5 },\n                                { \"mode\":\"table\",   \"icon\": \"icon-align-justify\", \"drawingTableSplit\": 0 } ];\n\n    options.interactionPrefix = graphOptions.interactionPrefix;\n\n    options.layoutConfig = { drawingWidth: 400,\n                             drawingHeight: 600,\n                             drawingMargin: 0,\n                             tableWidth: 400,\n                             tableHeight: 600,\n                             tableMargin: 0 };\n\n    if ( ! options.translateX )                                           \n        options.translateX = 0;\n\n    if ( ! options.translateY )                                           \n        options.translateY = 0;\n\n    if ( ! options.scale )                                           \n        options.scale = 1;\n\n    options.setDrawingTableSplit = function( drawingTableSplit ) { //can be called with a decimal (0.0 - 1.0), a mode (\"drawing\",\"mixed\",\"table\"), or nothing.\n\n        //TODO if going full-screen and not specifying a split here, then keep the table the same width and give all extra space to the drawing\n        \n        if ( drawingTableSplit === undefined )\n            drawingTableSplit = this.drawingTableSplit;\n        else if ( drawingTableSplit === \"drawing\" )\n            drawingTableSplit = 1.0;\n        else if ( drawingTableSplit === \"mixed\" )\n            drawingTableSplit = this.lastMixedSplit ? this.lastMixedSplit : 0.5;\n        else if ( drawingTableSplit === \"table\" )\n            drawingTableSplit = 0.0;\n\n        if ( drawingTableSplit < 0.05 ) \n        {\n            drawingTableSplit = 0.0;\n            this.drawingTableSplitMode = \"table\";\n        }\n        else if ( drawingTableSplit > 0.95 ) \n        {\n            drawingTableSplit = 1.0;\n            this.drawingTableSplitMode = \"drawing\";\n        }\n        else\n        {\n            this.drawingTableSplitMode = \"mixed\";\n            this.lastMixedSplit = drawingTableSplit;\n        }\n\n        var availableWidth = Math.round( targetdiv.style('width').slice(0, -2) -30 );// 1000;\n        var availableHeight= Math.round( window.innerHeight - targetdiv.node().getBoundingClientRect().top -60/*controlpanel buttons height nad margin*/);\n        this.layoutConfig.drawingWidth = availableWidth * drawingTableSplit;\n        this.layoutConfig.tableWidth   = availableWidth * (1-drawingTableSplit);\n        this.layoutConfig.drawingHeight = availableHeight;\n        this.layoutConfig.tableHeight = availableHeight;\n\n        \n        if ( this.sizeButtons )\n        {\n            var drawingTableSplitMode = this.drawingTableSplitMode;\n            this.sizeButtons.selectAll(\"button\")\n                        .data( this.viewOption )\n                        //.enter()\n                        //.append(\"button\")\n                        .attr( \"class\",  function(d) { \n                            return d.mode == drawingTableSplitMode ? \"btn btn-primary\" : \"btn btn-default\" } );\n        }\n\n        if ( this.drawingTableSplit != drawingTableSplit )\n        {\n            this.drawingTableSplit = drawingTableSplit; //so we can call this without a parameter when toggling full size. \n            this.updateServer(); \n        }\n    };    \n\n    options.updateServer = graphOptions.interactionPrefix ? function( k, x, y ) {\n        if ( k )\n        {\n//TODO shouldn't this be this. rather than options.  ???\n\n            if (    (options.translateX == x)\n                 && (options.translateY == y)\n                 && (options.scale == k) )\n                 return;\n\n            options.translateX = x;\n            options.translateY = y;\n            options.scale = k;\n        }\n        console.log(\"Update server with pan: \" + x + \",\" + y + \" & zoom:\" + k + \" & options\");\n        var kvpSet = newkvpSet(true) ;\n        kvpSet.add('fullWindow', targetdiv.classed(\"full-page\") ) ;\n        kvpSet.add('drawingTableSplit', options.drawingTableSplit ) ;\n        kvpSet.add('scale', options.scale ) ;\n        kvpSet.add('translateX', options.translateX ) ;\n        kvpSet.add('translateY', options.translateY ) ;        \n        goGraph( options.interactionPrefix + ':' + options.update, fakeEvent(), kvpSet) ;    \n    } : undefined;\n\n    if ( options.fullWindow )\n        targetdiv.node().classList.add(\"full-page\");\n\n    options.setDrawingTableSplit( options.drawingTableSplit ); //shouln't cause a server update\n\n    var focusDrawingObject = function( d, scrollTable )\n    {\n        if (    ( d3.event) \n             && ( d3.event.originalTarget )\n             && ( d3.event.originalTarget.className === \"ps-ref\" )\n             && ( selectedObject == d )\n             )\n        {\n            selectedObject = d.patternPiece.getObject( d3.event.originalTarget.innerHTML );\n            scrollTable = true;\n        }\n        else if (    ( d3.event) \n                  && ( d3.event.srcElement )\n                  && ( d3.event.srcElement.className === \"ps-ref\" )\n                  && ( selectedObject == d )\n             )\n        {\n            selectedObject = d.patternPiece.getObject( d3.event.srcElement.innerHTML );\n            scrollTable = true;\n        }\n        else\n        {\n            selectedObject = d;\n        }\n\n        for( var j=0; j< pattern.patternPieces.length; j++ )\n            for( var i=0; i< pattern.patternPieces[j].drawingObjects.length; i++ )\n            {\n                var a = pattern.patternPieces[j].drawingObjects[i];\n                var g = a.drawingSvg;\n                if ( g )\n                {\n                    var strokeWidth = a.getStrokeWidth( false, (selectedObject==a) );\n                    g.selectAll( \"line\" )\n                     .attr(\"stroke-width\", strokeWidth );\n                    g.selectAll( \"path\" )\n                     .attr(\"stroke-width\", strokeWidth );\n                }\n                else \n                    console.log(\"No drawing object for \" + a.data.name );\n            }        \n\n        var graphdiv = targetdiv;\n        //Remove any existing highlighting in the table. \n        $(graphdiv.node()).find( \".j-active\" ).removeClass(\"j-active\");\n        $(graphdiv.node()).find( \".source\" ).removeClass(\"source\");\n        $(graphdiv.node()).find( \".target\" ).removeClass(\"target\");\n        //$(graphdiv.node()).find( \".j-outline.j-outline-active\" ).removeClass(\"j-outline-active\");\n        //$(this).addClass(\"j-active\"); //highlight the object in the drawing\n\n        //d, the drawing object we clicked on, has a direct reference to its representation in the table\n        if ( selectedObject.tableSvg ) //should always be set unless there has been a problem\n            selectedObject.tableSvg.node().classList.add(\"j-active\");\n\n        if ( selectedObject.drawingSvg )\n            selectedObject.drawingSvg.node().classList.add(\"j-active\");\n\n        if ( selectedObject.outlineSvg )\n        {\n            selectedObject.outlineSvg.node().classList.add(\"j-active\");\n            //the blush will only last 2 seconds anyway, but if we don't do this then a second click whilst it is the active one doesn't repeat the blush\n            setTimeout( function(){ selectedObject.outlineSvg.node().classList.remove(\"j-active\");}, 2000 );\n        }\n\n        //Set the css class of all links to \"link\" \"source link\" or \"target link\" as appropriate.\n        linksGroup.selectAll(\"path.link\") //rename .link to .dependency\n            .attr(\"class\", function( d ) {                         \n                if ( d.source == selectedObject ) \n                {\n                    d.target.tableSvg.node().classList.add(\"source\");\n\n                    if ( d.target.outlineSvg ) //if it errored this will be undefined\n                        d.target.outlineSvg.node().classList.add(\"source\");\n\n                    //d.target.tableSvg.each( function() { $(this).addClass(\"source\"); } );\n                    return \"source link\";\n                }\n                if ( d.target == selectedObject ) \n                {\n                    d.source.tableSvg.node().classList.add(\"target\");\n\n                    if ( d.source.outlineSvg ) //if it errored this will be undefined\n                        d.source.outlineSvg.node().classList.add(\"target\");\n\n                    //d.source.tableSvg.each( function() { $(this).addClass(\"target\"); } );\n                    return \"target link\";\n                }\n                return \"link\"; \n            } )\n            .each( function( d ) { \n                if (( d.source == selectedObject ) || ( d.target == selectedObject ))\n                    d3.select(this).raise();\n             } );\n\n        //Scroll the table to ensure that d.tableSvg is in view.    \n        if ( scrollTable )\n        {\n            if ( selectedObject.tableSvg )\n            {\n                var table = d3.select(\"div.pattern-table\");\n                table.transition()\n                     .duration(500)\n                     .tween(\"uniquetweenname\", scrollTopTween( selectedObject.tableSvg.node().__data__.tableSvgY - ( table.node().getBoundingClientRect().height /2) ));\n            }\n            else\n                console.log( \"Cannot scroll table, no tableSvg - \" + selectedObject.data.name );\n        }\n    };\n\n    doDrawingAndTable = function() {\n                                    if ( options.layoutConfig.drawingWidth )\n                                        doDrawing( targetdiv, pattern, options, contextMenu, focusDrawingObject );\n                                    else\n                                        targetdiv.select(\"svg.pattern-drawing\").remove();\n                                                                            \n                                    if (   ( options.layoutConfig.drawingWidth )\n                                        && ( options.layoutConfig.tableWidth ) )\n                                        doResizeBar( targetdiv, options );    \n                                    else\n                                        targetdiv.select(\"div.pattern-editor-resize\").remove();\n\n                                    if ( options.layoutConfig.tableWidth )\n                                        doTable( targetdiv, pattern, options, contextMenu, focusDrawingObject );\n                                    else\n                                        targetdiv.select(\"div.pattern-table\").remove();\n                                };\n\n    doControls( targetdiv, options, pattern );\n    doDrawingAndTable();                   \n    \n    var errorFound = false;\n    for( var j=0; j< pattern.patternPieces.length; j++ )\n    {\n        for( var i=0; i< pattern.patternPieces[j].drawingObjects.length; i++ )\n        {\n            var a = pattern.patternPieces[j].drawingObjects[i];\n            if ( a.error )\n            {\n                focusDrawingObject(a, true);\n                errorFound = true;\n                break;\n            }\n        }\n        if ( errorFound )\n            break;\n    }\n\n}\n\n\nfunction doResizeBar( graphdiv, editorOptions )\n{\n    var layoutConfig = editorOptions.layoutConfig;\n    var drag = d3.drag()\n    .on(\"start\", function(r) {\n        console.log(\"dragStart\");\n        var rg = d3.select(this);        \n        r.initialX = d3.event.x;\n        r.resizeBarBaseStyle = rg.attr(\"style\");\n    })\n    .on(\"drag\", function(r) {\n        console.log(\"drag\");\n        var rg = d3.select(this);       \n        rg.attr(\"style\", r.resizeBarBaseStyle + \" left:\" + ( d3.event.x - r.initialX ) + \"px;\" ); \n    })\n    .on(\"end\", function(r){\n        console.log(\"dragEnd: \" + d3.event.x + \" (\" + ( d3.event.x - r.initialX ) + \")\" );\n        console.log( \"layoutConfig:\" + layoutConfig ); \n        var rg = d3.select(this);       \n        rg.attr(\"style\", r.resizeBarBaseStyle ); \n        var newDrawingWidth = layoutConfig.drawingWidth + ( d3.event.x - r.initialX );\n        var newTableWidth  = layoutConfig.tableWidth - ( d3.event.x - r.initialX );\n        editorOptions.setDrawingTableSplit( newDrawingWidth / ( newDrawingWidth + newTableWidth) );\n        doDrawingAndTable();\n    });\n\n    var layoutConfig = editorOptions.layoutConfig;\n    var height = layoutConfig.drawingHeight;\n\n    graphdiv.select( \"div.pattern-editor-resize\" ).remove();\n    graphdiv.selectAll( \"div.pattern-editor-resize\" )\n            .data( [ editorOptions ] )\n            .enter()\n            .append(\"div\")\n            .attr(\"class\", \"pattern-editor-resize\")\n            .attr(\"style\", \"height:\" + height + \"px;\" )\n            .call( drag );\n}\n\n\nfunction doControls( graphdiv, editorOptions, pattern )\n{\n    if ( ! editorOptions )\n        return;\n\n    var controls = graphdiv.append(\"div\").attr(\"class\", \"pattern-editor-controls\")\n\n    if (    ( editorOptions.viewOption )\n         && ( editorOptions.viewOption.length > 1 ) )\n    {\n        editorOptions.sizeButtons = controls.append(\"div\").attr(\"class\", \"btn-group view-options\");\n        editorOptions.sizeButtons.selectAll(\"button\")\n                    .data( editorOptions.viewOption )\n                    .enter()\n                    .append(\"button\")\n                    .attr( \"class\",  function(d) { return d.mode == editorOptions.drawingTableSplitMode ? \"btn btn-primary\" : \"btn btn-default\" } )\n                    .html(function(d) { return '<i class=\"' + d.icon + '\"></i>'; })\n                    .on(\"click\", function(d) {\n                        d3.event.preventDefault();\n                        editorOptions.setDrawingTableSplit( d.mode );\n                        doDrawingAndTable();\n                        //$(this).parent().find(\"button\").removeClass(\"btn-primary\").addClass(\"btn-default\");\n                        //$(this).addClass(\"btn-primary\");\n                    } );\n                    //TODO set the selected button to button-primary\n    }\n\n    if ( editorOptions.includeFullPageOption )\n    {\n        var toggleFullScreen = function() {\n            d3.event.preventDefault();\n\n            if ( graphdiv.classed(\"full-page\") ) \n                graphdiv.node().classList.remove(\"full-page\");\n            else\n                graphdiv.node().classList.add(\"full-page\");\n\n            editorOptions.setDrawingTableSplit();\n\n            if ( editorOptions.updateServer ) \n                editorOptions.updateServer();\n\n            doDrawingAndTable();\n        };\n\n        var fullPageButton = controls.append(\"button\")\n                                     .attr(\"class\", \"btn btn-default toggle-full-page\")\n                                     .html( '<i class=\"icon-fullscreen\" />' )\n                                     .on(\"click\", toggleFullScreen );\n    }\n\n    //if ( editorOptions.includeFullPageOption )\n    {\n        var toggleShowFormulas = function() {\n            d3.event.preventDefault();\n            editorOptions.showFormulas = ! editorOptions.showFormulas;\n            d3.select(this).text( editorOptions.showFormulas ? \"hide formulas\" : \"show formulas\" );\n            doDrawingAndTable();\n        };\n\n        var toggleShowFormulas = controls.append(\"button\")\n                                     .attr(\"class\", \"btn btn-default toggle-show_formulas\")\n                                     .text( editorOptions.showFormulas ? \"hide formulas\" : \"show formulas\" )\n                                     .on(\"click\", toggleShowFormulas );\n    }    \n\n    if ( pattern.wallpapers )\n    {\n        initialiseWallpapers( pattern, editorOptions.interactionPrefix );\n\n        var wallpaperControlsGroups = controls.append(\"table\").attr(\"class\",\"wallpapers\");\n        wallpaperControlsGroups.selectAll(\"tr\")\n            .data( pattern.wallpapers )\n            .enter()\n            .append(\"tr\")\n            .attr( \"class\", function(w) { return w.hide ? 'wallpaper-hidden' : null; } )\n            .each( function(wallpaper,i){                \n                var wallpaperDiv = d3.select(this);\n                wallpaperDiv.append( \"td\" ).html( function(w) { return w.hide ? '<i class=\"icon-eye-close\"/>' : '<i class=\"icon-eye-open\"/>' } )\n                                           .on(\"click\", function(w) { d3.event.preventDefault(); d3.event.stopPropagation();\n                                                                      w.hide = ! w.hide; \n                                                                      d3.select(this).html( w.hide ? '<i class=\"icon-eye-close\"/>' : '<i class=\"icon-eye-open\"/>' );\n                                                                      d3.select(this.parentNode).attr( \"class\", w.hide ? 'wallpaper-hidden' : null );\n                                                                      w.updateServer();\n                                                                      var wallpaperGroups = graphdiv.select( \"g.wallpapers\");\n                                                                      doWallpapers( wallpaperGroups, pattern );                                                              \n                                                                     } );\n                wallpaperDiv.append( \"td\" ).html( function(w) { return w.editable ? '<i class=\"icon-unlock\"/>' : w.allowEdit ? '<i class=\"icon-lock\"/>' : '<i class=\"icon-lock disabled\"/>' } )\n                                           .on(\"click\", function(w) { d3.event.preventDefault(); d3.event.stopPropagation();\n                                                                      if ( w.allowEdit )\n                                                                      {\n                                                                        w.editable = ! w.editable; \n                                                                        d3.select(this).html( w.editable ? '<i class=\"icon-unlock\"/>' : '<i class=\"icon-lock\"/>' );\n                                                                        var wallpaperGroups = graphdiv.select( \"g.wallpapers\");\n                                                                        doWallpapers( wallpaperGroups, pattern );                                                              \n                                                                      }\n                                                                     } );\n                wallpaperDiv.append( \"td\" ).text( wallpaper.filename ? wallpaper.filename : wallpaper.imageurl );\n                                                                     //icon-lock icon-unlock icon-move icon-eye-open icon-eye-close\n            });\n    }\n}\n\n\nfunction initialiseWallpapers( pattern, interactionPrefix )\n{    \n    var updateServer = ( typeof goGraph === \"function\" ) ? function(e) {\n        var kvpSet = newkvpSet(true) ;\n        kvpSet.add('offsetX', this.offsetX ) ;\n        kvpSet.add('offsetY', this.offsetY ) ;\n        kvpSet.add('scaleX', this.scaleX * defaultScale ) ;\n        kvpSet.add('scaleY', this.scaleY * defaultScale ) ;\n        kvpSet.add('opacity', this.opacity ) ;\n        kvpSet.add('visible', ! this.hide ) ;\n        goGraph(interactionPrefix + ':' + this.update, fakeEvent(), kvpSet) ;    \n    } : function(e){};\n\n    var wallpapers = pattern.wallpapers; \n    for( var i=0; i<wallpapers.length; i++ )\n    {\n        var w = wallpapers[i];\n\n        if ( ! w.initialised )\n        {\n            //A 720px image is naturally 10in (at 72dpi)\n            //If our pattern as 10in across then our image should be 10 units.\n            //If our pattern was 10cm across then our image should be 25.4 units and we would expect to need to specify a scale of 1/2.54\n            var defaultScale = 72;\n            if ( pattern.units === \"cm\" )\n            {\n                defaultScale = 72 / 2.54;\n            }\n            else if ( pattern.units === \"mm\" )\n            {\n                defaultScale = 72 / 25.4;\n            }\n            w.scaleX = w.scaleX / defaultScale /*dpi*/; //And adjust by pattern.units\n            w.scaleY = w.scaleY / defaultScale /*dpi*/;\n            w.hide = ( w.visible !== undefined ) && (! w.visible );\n            w.allowEdit = ( w.allowEdit === undefined ) || ( w.allowEdit );\n            \n            //w.dimensionsKnown = dimensionsKnown;\n            $(\"<img/>\") // Make in memory copy of image to avoid css issues\n                .attr(\"src\", w.imageurl )\n                .attr(\"data-wallpaper\", i)\n                .on( \"load\", function() {\n                    //seems like we can't rely on closure to pass w in, it always   points to the final wallpaper\n                    w = wallpapers[ this.dataset.wallpaper ];\n                    w.width = this.width;   // Note: $(this).width() will not\n                    w.height = this.height; // work for in memory images.\n                    //console.log( \"jquery Image loaded w.imageurl \" + w.imageurl + \" width:\" + w.width + \" height:\" + w.height);\n                    //console.log( \"Wallpaper dimensions known. Image loaded w.imageurl width:\" + w.width + \" height:\" + w.height );\n                    if ( w.image )\n                    {\n                        //console.log( \" setting d3Image dimentions.\" );\n                        d3.select( w.image ).attr(\"width\", w.width );        \n                        d3.select( w.image ).attr(\"height\", w.height );        \n                    }\n                });\n                \n            if ( updateServer )\n                w.updateServer = updateServer;\n\n            w.initialised = true;\n        }    \n    }\n}\n\n\n//http://bl.ocks.org/humbletim/5507619\nfunction scrollTopTween(scrollTop) \n{\n    return function() {\n        var i = d3.interpolateNumber(this.scrollTop, scrollTop);\n        //console.log( \"function1: \", this.scrollTop, \" - \", scrollTop );\n        return function(t) { \n            this.scrollTop = i(t); \n            //console.log( \"function2: \", this.scrollTop );\n        };\n    }\n}\n  \n\n//Do the drawing... (we've added draw() to each drawing object.\nfunction doDrawing( graphdiv, pattern, editorOptions, contextMenu, focusDrawingObject )\n{\n    var layoutConfig = editorOptions.layoutConfig;\n    var margin = 0;//layoutConfig.drawingMargin;//25;    ///XXX why a margin at all?\n    var width =  layoutConfig.drawingWidth;\n    var height = layoutConfig.drawingHeight;\n\n    graphdiv.select(\"svg.pattern-drawing\").remove();\n\n    var svg = graphdiv.append(\"svg\")\n                       .attr(\"class\", \"pattern-drawing\" )\n                       .attr(\"width\", width + ( 2 * margin ) )\n                       .attr(\"height\", height + ( 2 * margin ));\n\n    //var transformGroup1 = svg.append(\"g\")\n    //                        .attr(\"transform\", \"translate(\" + ( margin ) + \",\" + ( margin ) + \")\");\n    var transformGroup1 = svg.append(\"g\");\n                            //.attr(\"transform\", \"translate(\" + ( editorOptions.translateX ) + \",\" + ( editorOptions.translateY ) + \") scale(\" + editorOptions.scale + \")\");\n\n    var patternWidth = ( pattern.bounds.maxX - pattern.bounds.minX );\n    var patternHeight =( pattern.bounds.maxY - pattern.bounds.minY );\n\n    var scaleX = width / patternWidth;                   \n    var scaleY = height / patternHeight;           \n    \n    if ( ( isFinite( scaleX ) ) && ( isFinite( scaleY ) ) )\n        scale = scaleX > scaleY ? scaleY : scaleX;\n    else if ( isFinite( scaleX ) )\n        scale = scaleX;\n    else\n        scale = 1;\n\n    //console.log( \"scale:\" + scale + \" patternWidth:\" + patternWidth + \" width:\" + width );\n\n    //transformGroup2 scales from calculated positions in pattern-space (e.g. 10 representing 10cm) to\n    //pixels available. So 10cm in a 500px drawing has a scale of 50. \n    var transformGroup2 = transformGroup1.append(\"g\")\n        .attr(\"transform\", \"scale(\" + scale + \",\" + scale + \")\");\n\n    //centralise horizontally                            \n    var boundsWidth = pattern.bounds.maxX - pattern.bounds.minX;\n    var availableWidth = width / scale;\n    var offSetX = ( availableWidth - boundsWidth ) /2;\n\n    //transformGroup3 shifts the position of the pattern, so that it is centered in the available space. \n    var transformGroup3 = transformGroup2.append(\"g\")\n                               .attr(\"class\",\"pattern\")\n                               .attr(\"transform\", \"translate(\" + ( ( -1.0 * ( pattern.bounds.minX - offSetX ) ) ) + \",\" + ( ( -1.0 * pattern.bounds.minY ) ) + \")\");    \n\n    if ( pattern.wallpapers )\n    {\n        var wallpaperGroups = transformGroup2.append(\"g\")\n                                             .attr(\"class\",\"wallpapers\")\n                                             .attr(\"transform\", \"translate(\" + ( ( -1.0 * ( pattern.bounds.minX - offSetX ) ) ) + \",\" + ( ( -1.0 * pattern.bounds.minY ) ) + \")\")   \n                                             .lower();\n        doWallpapers( wallpaperGroups, pattern );\n    }\n     \n    //Clicking on an object in the drawing should highlight it in the table.\n    var onclick = function(d) {\n        d3.event.preventDefault();\n        focusDrawingObject(d,true);\n    };\n\n    for( var j=0; j< pattern.patternPieces.length; j++ )\n    {\n        var patternPiece = pattern.patternPieces[j];\n\n        var outlineGroup = transformGroup3.append(\"g\").attr(\"class\",\"j-outline\");\n        var drawingGroup = transformGroup3.append(\"g\").attr(\"class\",\"j-drawing\");\n\n        var a = drawingGroup.selectAll(\"g\");    \n        a = a.data( patternPiece.drawingObjects );\n        a.enter()\n         .append(\"g\")\n         //.attr(\"class\", \"j-point\")\n         .on(\"contextmenu\", contextMenu)\n         .on(\"click\", onclick)\n         .each( function(d,i) {\n            var g = d3.select( this );            \n            if (( typeof d.draw === \"function\" ) && ( ! d.error ))\n            {\n                d.draw( g );\n                d.drawingSvg = g;                 \n            }\n        });\n\n        var a = outlineGroup.selectAll(\"g\");    \n        a = a.data( patternPiece.drawingObjects );\n        a.enter()\n         .append(\"g\")\n         //.attr(\"class\", \"j-outline\")\n         .on(\"contextmenu\", contextMenu)\n         .on(\"click\", onclick)\n         .each( function(d,i) {\n            var g = d3.select( this );\n            if (( typeof d.draw === \"function\" ) && ( ! d.error ))\n            {\n                d.draw( g, true );\n                d.outlineSvg = g;\n            }\n        });        \n    };\n\n    var updateServerAfterDelay = function()\n    {\n        //Lets only update the server if we've stopped panning and zooming for > 1s.\n        timeOfLastTweak = (new Date()).getTime();\n        if ( ! updateServerTimer )\n        {\n            var updateServerTimerExpired = function () {\n\n                updateServerTimer = null;          \n                //console.log(\"Zoom update server timer activated. TimeOfLastTweak:\" + timeOfLastTweak + \" Now:\" + (new Date()).getTime());\n\n                if ( (new Date()).getTime() >= ( timeOfLastTweak + 500 ) )\n                {\n                    var zt = d3.zoomTransform( transformGroup1.node() );\n                    if ( editorOptions.updateServer )\n                        editorOptions.updateServer( zt.k, zt.x, zt.y );\n                }\n                else\n                    updateServerTimer = setTimeout(updateServerTimerExpired, 500);\n            }\n\n            updateServerTimer = setTimeout(updateServerTimerExpired, 500);\n        }           \n    };\n\n    var zoomed = function() {\n        transformGroup1.attr(\"transform\", d3.event.transform);\n\n        var currentScale = d3.zoomTransform( transformGroup1.node() ).k; //do we want to scale 1-10 to 1-5 for fonts and linewidths and dots?\n        if (   ( currentScale > (1.1*fontsSizedForScale) )\n            || ( currentScale < (0.9*fontsSizedForScale) )\n            || ( currentScale == 1 ) || ( currentScale == 8 ) )\n        {\n            if ( ! fontResizeTimer )\n            {\n                fontResizeTimer = setTimeout(function () {      \n                    fontResizeTimer = null;          \n                    fontsSizedForScale = d3.zoomTransform( transformGroup1.node() ).k;\n                    //console.log( \"Resize for \" + fontsSizedForScale);\n\n                    for( var j=0; j< pattern.patternPieces.length; j++ )\n                    {\n                        var patternPiece = pattern.patternPieces[j];\n                \n                        for( var i=0; i< patternPiece.drawingObjects.length; i++ )\n                        {\n                            var a = patternPiece.drawingObjects[i];\n                            var g = a.drawingSvg;                            \n                            if ( g )\n                            {\n                                g.selectAll( \"text\" )\n                                .attr(\"font-size\", Math.round(1200 / scale / fontsSizedForScale)/100 + \"px\");\n\n                                g.selectAll( \"circle\" )\n                                .attr(\"r\", Math.round(400 / scale / fontsSizedForScale)/100 );\n\n                                {\n                                    var strokeWidth = a.getStrokeWidth( false, (selectedObject==a) );\n\n                                    g.selectAll( \"line\" )\n                                        .attr( \"stroke-width\", strokeWidth );\n\n                                    g.selectAll( \"path\" )\n                                        .attr( \"stroke-width\", strokeWidth );            \n                                }\n                            }\n\n                            g = a.outlineSvg;\n                            if ( g )\n                            {\n                                var strokeWidth = a.getStrokeWidth( true );\n\n                                g.selectAll( \"line\" )\n                                .attr( \"stroke-width\", strokeWidth );\n\n                                g.selectAll( \"path\" )\n                                .attr( \"stroke-width\", strokeWidth );           \n\n                                g.selectAll( \"circle\" )\n                                    .attr(\"r\", Math.round( 1200 / scale / fontsSizedForScale )/100 );\n                            }\n                        }        \n                    }\n                }, 50);         \n            }\n        }\n        updateServerAfterDelay();         \n    };           \n\n    fontsSizedForScale = 1; //the starting scale of transformGroup1.\n    if ( editorOptions.allowPanAndZoom )\n    {\n        //TODO just the fontsize needs setting initially to take editorOptions.scale into account\n\n        var transform = d3.zoomIdentity.translate(editorOptions.translateX, editorOptions.translateY).scale(editorOptions.scale);\n        var zoom = d3.zoom()\n                    .extent([[0, 0], [width, height]])\n                    .scaleExtent([0.5, 8])\n                    .on(\"zoom\", zoomed);\n        svg.call( zoom)\n           .call(zoom.transform, transform);\n\n        fontsSizedForScale = editorOptions.scale;\n    }\n}\n\n\nfunction doWallpapers( wallpaperGroups, pattern )\n{\n    var visibleWallpapers = [];\n    for( var i=0; i<pattern.wallpapers.length; i++ )\n    {\n        var w = pattern.wallpapers[i];\n\n        if ( ! w.hide )\n            visibleWallpapers.push( w );\n    }\n\n    var drag = d3.drag()\n        .on(\"start\", function(wallpaper) {\n            //var wallpaperG = d3.select(this);\n            //if ( ! wallpaper.editable )\n            //    return;\n            wallpaper.offsetXdragStart = wallpaper.offsetX - d3.event.x;\n            wallpaper.offsetYdragStart = wallpaper.offsetY - d3.event.y;\n        })\n        .on(\"drag\", function(wallpaper) {\n            //if ( ! wallpaper.editable )\n            //    return;\n            var wallpaperG = d3.select(this);        \n            wallpaper.offsetX = wallpaper.offsetXdragStart + d3.event.x;\n            wallpaper.offsetY = wallpaper.offsetYdragStart + d3.event.y;\n            wallpaperG.attr(\"transform\", \"translate(\" + wallpaper.offsetX + \",\" + wallpaper.offsetY + \") \" + \" scale(\" + wallpaper.scaleX + \",\" + wallpaper.scaleY + \" )\" );\n        })\n        .on(\"end\", function(wallpaper){\n            wallpaper.updateServer( d3.event );\n        });\n\n    wallpaperGroups.selectAll(\"g\")\n                    .data( visibleWallpapers, function(d){return d.filename} )\n                    //.filter(function(w){return !w.hide;})\n                    .enter()\n                    .append(\"g\")\n                    .attr( \"class\", function(w){ return w.editable ? \"wallpaper editable\" : \"wallpaper\" } )\n                    .attr(\"transform\", function(wallpaper) { return  \"translate(\" + ( wallpaper.offsetX ) + \",\" + ( wallpaper.offsetY ) + \")\"\n                                                                    + \" scale(\" + wallpaper.scaleX + \",\" + wallpaper.scaleY + \")\" } )\n                    .append( \"image\" )\n                    //.on( \"load\", function(w) {\n                    //    console.log(\"d3 image loaded\");\n                    //})\n                    .attr( \"href\", function(w) { return w.imageurl } )\n                    .attr( \"opacity\", function(w) { return w.opacity } )\n                    .each( function(w){\n                        //Set this up so that we can later use dimensionsKnown()\n                        console.log(\"** added d3 image and setting w.image width:\" + w.width + \" height:\" + w.height );\n                        w.image = this; \n                        //if we know the dimensions already, set them! (Safari needs this on showing a hidden wallpaper)\n                        d3.select(this).attr( \"width\",w.width);\n                        d3.select(this).attr( \"height\",w.height);\n                    } );\n\n    wallpaperGroups.selectAll(\"g\")\n                    .data( visibleWallpapers, function(d){return d.filename} )\n                    .exit().remove();\n\n    var resize = d3.drag()\n                    .on(\"start\", function(wallpaper) {\n                        wallpaper.offsetXdragStart = d3.event.x - wallpaper.width;\n                        wallpaper.offsetYdragStart = d3.event.y - wallpaper.height;\n                        //console.log(\"start offsetXdragStart:\" + wallpaper.offsetXdragStart );\n                    })\n                    .on(\"end\", function(wallpaper) {\n                        var wallpaperG = d3.select(this.parentNode);\n                        var circle = d3.select(this);\n                        var rect = wallpaperG.select(\"rect\");\n                        var ratio = circle.attr(\"cx\") / wallpaper.width;     \n                        var scaleXbefore = wallpaper.scaleX;                   \n                        wallpaper.scaleX = wallpaper.scaleX * ratio; //fixed aspect?\n                        wallpaper.scaleY = wallpaper.scaleY * ratio;\n                        //console.log( \"cx:\" + circle.attr(\"cx\") + \" image:\" + wallpaper.width + \"  ratio:\" + ratio + \"  scaleXbefore:\" + scaleXbefore + \"  scaleXNow:\" + wallpaper.scaleX );\n                        wallpaperG.attr(\"transform\", \"translate(\" + wallpaper.offsetX + \",\" + wallpaper.offsetY + \") \" + \" scale(\" + wallpaper.scaleX + \",\" + wallpaper.scaleY + \" )\" );\n                        circle.attr(\"cx\", wallpaper.width )\n                              .attr(\"cy\", wallpaper.height );\n                        rect.attr(\"width\", wallpaper.width )\n                            .attr(\"height\", wallpaper.height );\n                        wallpaper.updateServer( d3.event );\n                    } )\n                    .on(\"drag\", function(wallpaper) {\n                        var wallpaperG = d3.select(this.parentNode);\n                        var circle = d3.select(this);\n                        var rect = wallpaperG.select(\"rect\");\n                        var newX = d3.event.x - wallpaper.offsetXdragStart;\n                        var newY = d3.event.y - wallpaper.offsetYdragStart;\n                        //console.log(\"drag d3.event.x:\" + d3.event.x + \"  newX:\" + newX );\n                        if ( true ) //fixed aspect\n                        {\n                            var ratioX = newX / wallpaper.width;\n                            var ratioY = newY / wallpaper.height;\n                            var ratio = (ratioX+ratioY)/2.0;\n                            newX = ratio * wallpaper.width;\n                            newY = ratio * wallpaper.height;\n                        }\n                        circle.attr(\"cx\", newX )\n                                .attr(\"cy\", newY );\n                        rect.attr(\"width\", newX )\n                            .attr(\"height\", newY );\n                    });\n\n    //Add a resizing boundary to each editable wallpaper.                 \n    wallpaperGroups.selectAll(\"g\")\n                    .data( visibleWallpapers,function(d){return d.filename} )\n                    //.filter(function(w){return !w.hide;})\n                    .each( function(w,i) {\n                        var g = d3.select(this);\n                        //This worked on Firefox and Chrome, but not Safari.\n                        //var box = g.node().getBBox();\n                        //w.width = box.width;\n                        //w.height = box.height;\n\n                        if ( w.editable )\n                        {\n                            g.append(\"rect\")\n                            .attr(\"x\",0)\n                            .attr(\"y\",0)\n                            .attr(\"stroke\", \"red\")\n                            .attr(\"fill\", \"none\")\n                            .attr(\"width\", w.width)\n                            .attr(\"height\", w.height);\n    \n                            g.append( \"circle\") \n                            .attr(\"cx\", function(w) { return w.width } )\n                            .attr(\"cy\", function(w) { return w.height } )\n                            .attr(\"r\", 10 / scale / w.scaleX / fontsSizedForScale )\n                            .attr(\"fill\", \"red\")\n                            .call(resize);\n                            \n                            g.call(drag);\n                        }\n                        else\n                        {\n                            g.select(\"rect\").remove();\n                            g.select(\"circle\").remove();\n                            g.on(\".drag\", null );\n                        }\n                    } );\n    //resize(wallpaperGroups.selectAll(\"g > circle\"));            \n}\n\n\nfunction doTable( graphdiv, pattern, editorOptions, contextMenu, focusDrawingObject )\n{\n    var patternPiece1 = pattern.patternPieces[0];\n    var layoutConfig = editorOptions.layoutConfig;\n    var margin = layoutConfig.tableMargin;//25; \n    var width =  layoutConfig.tableWidth;//400;\n    var height = layoutConfig.tableHeight;//600;\n    var minItemHeight = 30; //should not be required\n    var itemMargin = 8;\n    var itemWidth = width *3/4;\n    var ypos = 0;\n    var seq = 1; //TODO get these in the XML as data?\n    var asFormula = editorOptions.showFormulas; \n\n    var onclick = function(d) {\n        d3.event.preventDefault();\n        focusDrawingObject(d,false);\n    }\n\n    graphdiv.select(\"div.pattern-table\").remove();\n\n    var combinedDrawingObjects = pattern.patternPieces.length == 1 ? pattern.patternPieces[0].drawingObjects \n                                                                   : pattern.patternPieces[0].drawingObjects.concat( pattern.patternPieces[1].drawingObjects);\n    for( var j=2; j< pattern.patternPieces.length; j++ )\n    {\n        combinedDrawingObjects = combinedDrawingObjects.concat( pattern.patternPieces[2].drawingObjects);\n    }\n\n    var svg = graphdiv.append(\"div\")\n                      .attr(\"class\", \"pattern-table\")\n                      .style( \"height\", height +\"px\" )    \n                      .append(\"svg\")\n                      .attr(\"width\", width + ( 2 * margin ) )\n                      .attr(\"height\", minItemHeight * combinedDrawingObjects.length );    \n\n    var a = svg.selectAll(\"g\");\n    a = a.data( combinedDrawingObjects );\n    a.enter()        \n    .append(\"g\")\n    .each( function(d,i) {\n\n        var divHeight = function(that) {\n\n            //this - the dom svg element\n            //that - the data object\n\n            //console.log( \"divHeight() of this:\" + this + \" that:\" + that );\n\n            //var div = $(this).find( \"div.nodedesc\" );\n            var h = $(this).find( \"div.outer\" ).height();\n            \n            if ( h < minItemHeight )\n                return minItemHeight;\n            return h;\n            \n        };\n\n        var g = d3.select( this );\n\n        g.attr( \"class\", \"j-item\") ;\n\n        if ( d.error )\n            g.attr( \"class\", \"j-item error\") ;\n\n        d.tableSvg = g;\n        d.tableSvgX = itemWidth;\n        d.tableSvgY = ypos + ( 0.5 * minItemHeight );\n\n        var fo = g.append( \"foreignObject\" )\n        .attr( \"x\", 0 )\n        .attr( \"y\", function (d) { \n             return ypos;\n         } )\n         .attr( \"width\", itemWidth  );\n\n        var html;\n        try {\n            html = d.html( asFormula );\n            if (d.error)\n                html += '<div class=\"error\">' + d.error + '</div>';\n        } catch ( e ) {\n            html = \"Failed to generate description.\";\n        }\n\n         var div = fo.append( \"xhtml:div\" )\n           .attr(\"class\",\"outer\")\n           .append( \"xhtml:div\" )\n           .attr(\"class\",\"desc\")\n           .html( html );\n\n        fo.attr( \"height\", 1 ); //required by firefox otherwise bounding rects returns nonsense\n        fo.attr( \"height\", divHeight );\n\n        g.attr( \"height\", divHeight )\n        .attr( \"y\", function (d) { \n                                    //Get the height of the foreignObject.\n                                    var h = this.childNodes[0].getBoundingClientRect().height;\n                                    ypos += h + itemMargin; \n                                    //console.log(\"y: \" + ypos );\n                                    return ypos } )\n\n        g.on(\"contextmenu\", contextMenu)\n         .on(\"click\", onclick );\n    });                   \n        \n    svg.attr(\"height\", ypos );    \n\n    linksGroup = svg.append(\"g\")\n                    .attr(\"class\", \"links\");\n\n    //Links area is width/4 by ypos.            \n    var linkScale = (width/4) / Math.log( Math.abs( ypos /30 ) );   \n    drawLinks( patternPiece1, linkScale );\n}\n\n\nfunction drawLinks( patternPiece, linkScale )\n{\n    var linkData = patternPiece.dependencies.dependencies;\n\n    linksGroup.selectAll(\"path.link\") //rename .link to .dependency\n                    .data(linkData)\n                    .enter().append(\"path\")\n                    .attr(\"class\", \"link\" )\n                    .attr(\"d\", function( link ) {\n                        var x0 = link.source.tableSvgX, y0 = link.source.tableSvgY,\n                            x1 = link.target.tableSvgX, y1 = link.target.tableSvgY;\n                    \n                        var dx = x0 - x1,\n                            dy = y0 - y1,\n                            l = Math.log( Math.abs(dy /30 ) ) * linkScale;\n                    \n                        var path = d3.path();\n                        path.moveTo( x0, y0 );\n                        path.bezierCurveTo( x0+l , y0, x1+l, y1, x1, y1 );\n                        return path;                      \n                    } );\n                    //.attr(\"d\", curve);\n}\n\n\n/*\n * Curve that connects items in the table.\n */\nfunction curve(link) {\n    var x0 = link.source.tableSvgX, y0 = link.source.tableSvgY,\n        x1 = link.target.tableSvgX, y1 = link.target.tableSvgY;\n\n    var dx = x0 - x1,\n        dy = y0 - y1,\n        l = Math.log( Math.abs(dy /30 ) ) * 50;\n\n    var path = d3.path();\n    path.moveTo( x0, y0 );\n    path.bezierCurveTo( x0+l , y0, x1+l, y1, x1, y1 );\n    return path;                      \n}\n\n\nfunction newkvpSet(noRefresh)\n{\n    var kvp = { } ;\n    kvp.kvps = new Array() ;\n\n    kvp.add = function (k, v)\n    {\n        this.kvps.push ( {k: k, v: v} ) ;\n    } ;\n\n    kvp.toString = function (p)\n    {\n        var r = '' ;\n\n        for (var i = 0 ; i < this.kvps.length ; i++)\n        {\n            r += '&' + p + this.kvps[i].k + '=' + this.kvps[i].v ;\n        }\n\n        return r ;\n    } ;\n\n    if (noRefresh)\n        kvp.add(\"_noRefresh\", -1) ;\n\n    return kvp ;\n}\n\n\nfunction fakeEvent(location, x, y)\n{\n    var pXY = {x: 0, y: 0} ;\n    \n    if (location !== undefined)\n    {\n        pXY = getElementXY(location) ;\n        pXY.x = Math.round(pXY.x + x) ;\n        pXY.y = Math.round(pXY.y + y) ;\n    }\n    else\n    {\n        pXY.x = Math.round(x) ;\n        pXY.y = Math.round(y) ;\n    }\n    \n    // event to satisfy goGraph's requirements\n    return { target: location, pageX: 0, pageY: 0, processedXY: pXY } ;\n}\n\n\nexport{ PatternPiece, doDrawing, doTable, drawPattern  };","//(c) Copyright 2019 Jason Dore\n//\n//Inspired by the excellent Seamly2D/Valentina pattern drawing software.\n//This library is a ground up implementation in Javascript intended to be compatible with, but\n//not based on, the Seamly2D/Valentina pattern making systen in order to support the community\n//pattern sharing website https://my-pattern.cloud/ . \n//\n//Source maintained at: https://github.com/MrDoo71/PatternEditor\n\nclass Expression {\n\n    constructor(data, pattern, patternPiece) {\n        this.dataDebug = data;\n        this.operation = data.operationType;\n        this.pattern = pattern;\n        this.patternPiece = patternPiece;\n\n        //divide, multiply etc. and functions too\n        if (typeof data.parameter !== \"undefined\") \n        {\n            this.params = data.parameter;\n            for (var a = 0; a < this.params.length; a++) {\n                var p = this.params[a];\n                this.params[a] = new Expression(p, pattern, patternPiece);\n            }            \n        }\n\n        //integer constant\n        if (typeof data.integerValue !== \"undefined\") \n        {\n            this.constant = data.integerValue;\n            this.value = this.constantValue; //eh?\n        }\n        else if (typeof data.decimalValue !== \"undefined\") \n        {\n            this.constant = data.decimalValue;\n            this.value = this.constantValue; //eh?\n        }\n        else if (data.operationType === \"Variable\") \n        {\n            if (data.variableType === \"Keyword\")\n            {\n                this.variable = data.keyword;\n                this.value = this.keywordValue;\n            }\n            else if (data.variableType === \"Increment\")\n            {\n                this.variable = pattern.getIncrement( data.incrementVar );\n                this.value = this.incrementValue;\n            }\n            else if ( data.measurement )\n            {\n                this.variable = pattern.getMeasurement( data.measurement );\n                this.value = this.measurementValue;\n            }\n            else if ( data.variableType === \"angleOfLine\" )\n            {\n                this.drawingObject1 = patternPiece.getObject( data.drawingObject1 );\n                this.drawingObject2 = patternPiece.getObject( data.drawingObject2 );\n                this.function = data.variableType;\n                this.value = this.functionValue;\n            }\n            else if ( data.variableType === \"lengthOfLine\" )\n            {\n                this.drawingObject1 = patternPiece.getObject( data.drawingObject1 );\n                this.drawingObject2 = patternPiece.getObject( data.drawingObject2 );\n                this.function = data.variableType;\n                this.value = this.functionValue;\n            }\n            else if (    ( data.variableType === \"lengthOfSplinePath\" )\n                      || ( data.variableType === \"lengthOfSpline\" ) )\n            {\n                if ( data.drawingObject1 && data.drawingObject2 )\n                    //at least one of these will be an intersect on a curve, otherwise they are end points of the curve. \n                    this.drawingObject = patternPiece.getObject( \"Spl_\" + data.drawingObject1 + \"_\" + data.drawingObject2 );\n                else\n                    //this is the spline drawing object itself, the curve comes directly from it. \n                    this.drawingObject = patternPiece.getObject( data.drawingObject1 );\n\n                this.function = data.variableType;\n                this.value = this.functionValue;\n            }            \n            else if ( data.variableType === \"lengthOfArc\" )\n            {\n                this.drawingObject = patternPiece.getObject( data.drawingObject1 );\n                this.arcSelection = data.arcSelection;\n                this.function = data.variableType;\n                this.value = this.functionValue;\n            }            \n            else \n                throw \"Unsupported variableType:\" + data.variableType;\n        }\n        else if ( typeof data.functionName !== \"undefined\" )\n        {\n            this.function = data.functionName;\n            this.value = this.functionValue;\n            //having done the parameters earlier. \n        }\n        else if ( this.operationType !== \"undefined\" )\n        {\n            //add, multiply etc.\n            this.value = this.operationValue;\n        }\n        else throw \"Unsupported expression.\" ;\n    }\n\n    \n    incrementValue() {\n        return this.variable.value();\n    }    \n\n\n    measurementValue() {\n        //console.log(\"Measurement units \" + this.variable.units );\n        //console.log(\"Pattern units \" + this.pattern.units );\n        var measurementUnits = this.variable.units;\n        var patternUnits = this.pattern.units;\n        if ( measurementUnits === patternUnits )\n            return this.variable.value();\n\n        var mm = 1;\n        if ( measurementUnits === \"cm\" )\n            mm = 10;\n        else if ( measurementUnits === \"inch\" )\n            mm = 25.4;\n\n        var pp = mm;\n\n        if ( patternUnits === \"cm\" )\n            pp = mm / 10;\n        else if ( patternUnits === \"inch\" )\n            pp = mm / 25.4;\n\n        return pp * this.variable.value();\n    }    \n\n\n    functionValue(currentLength) {\n        if ( this.function === \"angleOfLine\" )\n        {\n            var point1 = new GeoPoint( this.drawingObject1.p.x, this.drawingObject1.p.y );\n            var point2 = new GeoPoint( this.drawingObject2.p.x, this.drawingObject2.p.y );\n            var line = new GeoLine( point1, point2 );\n            var deg = line.angleDeg();\n            if ( deg < 0 )\n                deg += 360; \n            return deg;\n        }\n        else if ( this.function === \"lengthOfLine\" )\n        {\n            var point1 = new GeoPoint( this.drawingObject1.p.x, this.drawingObject1.p.y );\n            var point2 = new GeoPoint( this.drawingObject2.p.x, this.drawingObject2.p.y );\n            var line = new GeoLine( point1, point2 );\n            //console.log( \"lengthOfLine \" + this.drawingObject1.data.name + this.drawingObject2.data.name + \" = \" + line.getLength() );\n            return line.getLength();\n        }\n        else if (    ( this.function === \"lengthOfSplinePath\" )\n                  || ( this.function === \"lengthOfSpline\" ) )\n        {\n            return this.drawingObject.curve.pathLength();\n        }        \n        else if ( this.function === \"lengthOfArc\" )\n        {\n            if ( this.arcSelection === \"wholeArc\")\n                return this.drawingObject.arc.pathLength();\n            else\n            {\n                //this.drawingObject is a cut object\n                var arcDrawingObject = this.drawingObject.curve ? this.drawingObject.curve : this.drawingObject.arc;\n\n                //where in the arc is this.drawingObject.curve?\n                var radiusToIntersectLine = new GeoLine( arcDrawingObject.center.p, this.drawingObject.p );\n                var angleToIntersectRad = radiusToIntersectLine.angle;\n                if ( this.arcSelection === \"beforeArcCut\")\n                {\n                    if ( arcDrawingObject.arc instanceof GeoEllipticalArc )\n                    {\n                        //else elliptical arc: from the arc's start angle to this cut angle. \n                        const cutArc = arcDrawingObject.arc.clone();\n                        cutArc.angle2 = radiusToIntersectLine.angleDeg() - cutArc.rotationAngle;\n                        if ( cutArc.angle2 < 0 )\n                            cutArc.angle2 += 360;\n                        return cutArc.pathLength();\n                    }\n                    else //if arc\n                    {\n                        var arcStartAngleRad = arcDrawingObject.angle1.value() / 360 * 2 * Math.PI;\n                        var segmentRad = angleToIntersectRad-arcStartAngleRad;                    \n                        var length = radiusToIntersectLine.length * segmentRad; //because circumference of a arc is radius * angle (if angle is expressed in radians, where a full circle would be Math.PI*2 )\n\n                        //console.log( \"beforeArcCut \" + this.drawingObject.data.name + \" = \" + length );\n                        return length;\n                    }                    \n                }\n                else //afterArcCut\n                {\n                    if ( arcDrawingObject.arc instanceof GeoEllipticalArc )\n                    {\n                        const cutArc = arcDrawingObject.arc.clone();\n                        cutArc.angle1 = radiusToIntersectLine.angleDeg()  - cutArc.rotationAngle;\n                        if ( cutArc.angle1 < 0 )\n                            cutArc.angle1 += 360;\n                        return cutArc.pathLength();\n                    }\n                    else //if arc\n                    {\n                        var arcEndAngleRad = arcDrawingObject.angle2.value() / 360 * 2 * Math.PI;\n                        var segmentRad = arcEndAngleRad - angleToIntersectRad;\n                        var length = radiusToIntersectLine.length * segmentRad;\n                        return length;\n                    }\n                }\n            }\n        }        \n        else if  ( this.function === \"sqrt\" )\n        {\n            var p1 = this.params[0].value(currentLength);\n            return Math.sqrt( p1 ); \n        }\n        else if  ( this.function === \"-\" )\n        {\n            var p1 = this.params[0].value(currentLength);\n            return -p1; \n        }\n        else throw (\"Unknown function: \" + this.function );\n    }\n    \n\n    constantValue() {\n        return this.constant;\n    }\n\n\n    operationValue(currentLength) {\n\n        if (typeof this.params[0].value !== \"function\")\n            throw \"expression p1 not valid\";\n\n        if ( this.operation !== \"parenthesis\" )    \n        {\n            if (typeof this.params[1].value !== \"function\")\n                throw \"expression p2 not valid\";\n        }\n\n        if (this.operation === \"add\")\n            return this.params[0].value(currentLength) + this.params[1].value(currentLength);\n\n        else if (this.operation === \"subtract\")\n            return this.params[0].value(currentLength) - this.params[1].value(currentLength);\n\n        else if (this.operation === \"multiply\")\n            return this.params[0].value(currentLength) * this.params[1].value(currentLength);\n\n        else if (this.operation === \"divide\")\n            return this.params[0].value(currentLength) / this.params[1].value(currentLength);\n            \n        else if (this.operation === \"equalTo\")\n            return this.params[0].value(currentLength) == this.params[1].value(currentLength);\n\n        else if (this.operation === \"notEqualTo\")\n            return this.params[0].value(currentLength) != this.params[1].value(currentLength);\n\n        else if (this.operation === \"lessThan\")\n            return this.params[0].value(currentLength) < this.params[1].value(currentLength);\n\n        else if (this.operation === \"lessThanOrEqualTo\")\n            return this.params[0].value(currentLength) <= this.params[1].value(currentLength);\n            \n        else if (this.operation === \"greaterThan\")\n            return this.params[0].value(currentLength) > this.params[1].value(currentLength);\n\n        else if (this.operation === \"greaterThanOrEqualTo\")\n            return this.params[0].value(currentLength) >= this.params[1].value(currentLength);\n\n        else if (this.operation === \"parenthesis\")\n            return this.params[0].value(currentLength);\n\n        else if  ( this.operation === \"power\" )\n        {\n            var p1 = this.params[0].value(currentLength);\n            var p2 = this.params[1].value(currentLength);\n            return Math.pow( p1, p2 );\n        }    \n        else if (this.operation === \"ternary\")\n        {\n            var conditionTestResult = this.params[0].value(currentLength);\n            if ( conditionTestResult )\n                return this.params[1].value(currentLength);\n            else\n                return this.params[2].value(currentLength);\n        }\n\n\n        throw (\"Unknown operation: \" + this.operation);\n    }\n\n\n    keywordValue(currentLength) {\n        if (this.variable === \"CurrentLength\")\n            return currentLength;\n        throw (\"Unknown keyword: \" + this.variable);\n    }\n\n\n    html( asFormula, currentLength ) {\n\n        if ( ! asFormula )\n        {\n            try { \n                return Number.parseFloat( this.value( currentLength ) ).toPrecision(4); \n            } catch ( e ) {\n                return \"???\"\n            }\n        }\n\n        if ( this.variable )\n        {\n            if (this.variable === \"CurrentLength\")\n                return \"CurrentLength\";\n\n            return this.variable.name;\n        }\n\n        if ( this.constant )\n            return this.constant;\n\n        if ( this.function )\n        {\n            if ( this.function === \"lengthOfLine\" )\n                return \"lengthOfLine(\" + this.drawingObject1.ref() + \", \" + this.drawingObject2.ref() + \")\";\n\n            if ( this.function === \"angleOfLine\" )\n                return \"angleOfLine(\" + this.drawingObject1.ref() + \", \" + this.drawingObject2.ref() + \")\";\n\n            if ( this.function === \"lengthOfSpline\" )\n            {\n                if ( ! this.drawingObject )\n                    return \"lengthOfSpline( ??? )\";\n                \n                return \"lengthOfSpline(\" + this.drawingObject.ref() + \")\";\n            };\n\n            if ( this.function === \"lengthOfSplinePath\" )\n            {\n                if ( ! this.drawingObject )\n                    return \"lengthOfSplinePath( ??? )\";\n\n                return \"lengthOfSplinePath(\" + this.drawingObject.ref() + \")\";\n            };\n\n            if ( this.function === \"lengthOfArc\" )\n            {\n                if ( ! this.drawingObject )\n                    return \"lengthOfArc( ??? )\";\n                \n                return \"lengthOfArc(\" + this.arcSelection + \" \" + this.drawingObject.ref() + \")\";\n            };\n\n            if ( this.function === \"sqrt\" )\n            {\n                return ( \"sqrt(\" + this.params[0].html( asFormula, currentLength ) + \")\" ); \n            }\n\n            if ( this.function === \"-\" )\n            {\n                return ( \"-(\" + this.params[0].html( asFormula, currentLength ) + \")\" ); \n            }            \n\n            //else\n            return \"UNKNOWN FUNCTION TYPE\" + this.function;\n        }\n\n        if ( this.operation ) \n        {\n            var useOperatorNotation = false;\n\n            if (this.operation === \"add\") \n                useOperatorNotation = \" + \";\n\n            if (this.operation === \"subtract\") \n                useOperatorNotation = \" - \";\n\n            if (this.operation === \"divide\") \n                useOperatorNotation = \" / \";\n\n            if (this.operation === \"multiply\") \n                useOperatorNotation = \" * \";\n                \n            var t = ( useOperatorNotation || this.operation === \"parenthesis\" ? \"\" : this.operation ) + \"(\";\n            var first = true;\n            for ( var p in this.params )\n            {\n                if ( ! first )\n                {\n                    if ( useOperatorNotation )\n                        t += useOperatorNotation;\n                    else\n                        t += \",\";\n                }\n                t += this.params[p].html( asFormula, currentLength );\n                first = false;\n            }\n            t += \")\";\n            return t;\n        }\n\n        return \"UNKNOWN EXPRESSION TYPE\";\n    };\n\n\n    //The dependencies of this expression need adding to the source drawingObject that uses this expression\n    addDependencies( source, dependencies ) \n    {\n        if ( typeof this.drawingObject1 !== \"undefined\" )\n            dependencies.add( source, this.drawingObject1 );\n\n        if ( typeof this.drawingObject2 !== \"undefined\" )\n            dependencies.add( source, this.drawingObject2 );\n\n        if ( typeof this.drawingObject !== \"undefined\" ) //e.g. lengthOfArc\n            dependencies.add( source, this.drawingObject );\n\n        //recurse into the expression parameters.\n        if ( this.params )\n        {       \n            for (var a = 0; a < this.params.length; a++) {\n                var p = this.params[a];\n                p.addDependencies( source, dependencies );\n            }\n        }\n\n        //TODO also add dependencies on measurements and increments and (optionally) show these in the list too. \n    }\n}\n\n\n"]}