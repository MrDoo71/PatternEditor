{"version":3,"sources":["drawing/DrawingObject.js","drawing/ArcElliptical.js","drawing/ArcSimple.js","drawing/CutSpline.js","drawing/Drawing.js","drawing/Line.js","drawing/OperationFlipByAxis.js","drawing/OperationFlipLine.js","drawing/OperationMove.js","drawing/OperationResult.js","drawing/OperationRotate.js","drawing/PerpendicularPointAlongLine.js","drawing/PointAlongBisector.js","drawing/PointAlongLine.js","drawing/PointAlongPerpendicular.js","drawing/PointCutArc.js","drawing/PointCutSplinePath.js","drawing/PointEndLine.js","drawing/PointFromArcAndTangent.js","drawing/PointFromCircleAndTangent.js","drawing/PointFromXandYOfTwoOtherPoints.js","drawing/PointIntersectArcAndAxis.js","drawing/PointIntersectArcAndLine.js","drawing/PointIntersectArcs.js","drawing/PointIntersectCircles.js","drawing/PointIntersectCurveAndAxis.js","drawing/PointIntersectCurves.js","drawing/PointIntersectLineAndAxis.js","drawing/PointLineIntersect.js","drawing/PointOfTriangle.js","drawing/PointShoulder.js","drawing/PointSingle.js","drawing/SplinePathInteractive.js","drawing/SplinePathUsingPoints.js","drawing/SplineSimple.js","drawing/SplineUsingControlPoints.js","drawing/TrueDart.js","drawing/TrueDartResult.js","Pattern.js","Group.js","Piece.js","PatternDrawing.js","PatternEditor.js","expression.js","geometry/Bounds.js","geometry/GeoArc.js","geometry/GeoEllipticalArc.js","geometry/GeoLine.js","geometry/GeoPoint.js","geometry/GeoSpline.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3bA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5kCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3iDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"patterneditor.js","sourcesContent":["//(c) Copyright 2019 Jason Dore\n//\n//This library collates the various geometric calclulation requirements\n//of the drawing objects into a small number of primitives. \n//\n//This library then generally uses other libraries to perform those \n//geometric calculations where they are non trivial\n//(e.g. intersection of lines with splines).\n//\n//Source maintained at: https://github.com/MrDoo71/PatternEditor\n\nclass DrawingObject /*abstract*/ {\n    \n    constructor(data) {\n        this.data = data;\n        this.contextMenu = data.contextMenu;\n    }\n\n    drawLabel( g, drawingOptions ) {\n\n        if ( ! drawingOptions.label )\n            return;\n\n        //g - the svg group we want to add the text to\n        //o - the drawing object\n\n        var d = this.data; //the original json data\n\n        if (   ( this.p )\n            && ( typeof this.p.x === \"number\" ) )\n        {\n            var labelPosition = this.labelPosition();\n\n            if ( labelPosition.drawLine )\n                g.append(\"line\")\n                .attr(\"x1\", this.p.x)\n                .attr(\"y1\", this.p.y)\n                .attr(\"x2\", labelPosition.labelLineX )\n                .attr(\"y2\", labelPosition.labelLineY )\n                .attr(\"stroke-width\", this.getStrokeWidth( false ) )\n                .attr(\"class\", \"labelLine\" );\n\n            var labelText = d.name;\n            try {\n                if ( d.showLength === \"label\" )\n                    labelText += \" \" + this.getLengthAndUnits();\n            } catch ( e ) {                \n            }\n\n            g.append(\"text\")\n            .attr(\"class\",\"labl\")\n            .attr(\"x\", labelPosition.labelX )\n            .attr(\"y\", labelPosition.labelY )\n            .attr(\"font-size\", labelPosition.fontSize + \"px\")\n            .text( labelText );\n\n        }\n\n        if (( d.showLength === \"line\" ) && this.lineVisible())\n            this.drawLengthAlongLine( g, drawingOptions );\n    }\n\n    drawLengthAlongLine( g, drawingOptions )\n    {\n        const d = this.data; //the original json data\n        const fontSize = Math.round( 1300 / scale / fontsSizedForScale )/100;\n\n        \n        try {\n            const lengthToDisplay = this.getLengthAndUnits();\n            var p;\n            var a = 0; //horizontal, unless we get an angle. \n            if ( this.line  )\n            {\n                p = this.line.pointAlongPathFraction(0.5);\n                a = this.line.angleDeg();\n            }\n\n            else if ( this.curve )\n            {\n                p = this.curve.pointAlongPathFraction(0.5);\n                //TODO a =\n            }\n\n            if ( ! p )\n                throw \"Failed to determine position for label\";\n\n            {\n                var baseline = \"middle\";\n                var align = \"middle\";\n                var ta = 0;\n                var dy = 0;\n                //const patternUnits = this.patternPiece.pattern.units;\n                // /const spacing = (fontSize * 0.2);\n                const spacing = this.patternPiece.pattern.getPatternEquivalentOfMM(1);\n    \n\n                // East(ish)\n                if ((( a >= 0 ) && ( a <45 )) || (( a > 270 ) && ( a <= 360 )))\n                {\n                    baseline = \"hanging\"; //For Safari, handing doesn't work once rotated\n                    ta = - a;\n                    //p.y += spacing;\n                    dy = spacing;\n                }\n                // West(ish)\n                else if (  (( a >= 135 ) && ( a <225 )) \n                )//|| (( a > 270 ) && ( a <315 ))  )\n                {\n                    baseline = \"hanging\";\n                    ta = - (a-180);\n                    //p.y += spacing;\n                    dy = spacing;\n                }\n                //North(ish)\n                else if (( a > 45 ) && ( a < 135 )) \n                {\n                    baseline = \"middle\";//\"auto\"\n                    align = \"middle\";\n                    ta = -a;\n                    p.x -= spacing;\n                }\n                //South(ish)\n                else if (( a > 225 ) && ( a <= 270 )) \n                {\n                    baseline = \"auto\"\n                    align = \"middle\";\n                    ta = - ( a-180 );\n                    p.x -= spacing;\n                }\n\n                g.append(\"text\")\n                .attr(\"class\",\"length\")\n                .attr( \"transform\", \"translate(\" + p.x + \",\" + p.y +  \") rotate(\"+ta+\")\" )\n                .attr( \"dominant-baseline\", baseline ) //if we're drawing below the line. \n                .attr( \"text-anchor\", align ) //if we're drawing to the left of the line\n                .attr( \"dy\", dy + \"px\" ) //need to also scale this\n                .attr(\"font-size\", fontSize + \"px\")\n                .text( lengthToDisplay ); //TODO make this more generic to cater for different types.\n    \n            }\n        } catch ( e ) {\n            console.log( \"Failed to show length. \", e );            \n        }\n    }\n\n\n    labelPosition() {\n\n        if ( ! this.p )\n            return null;\n\n        //console.log( \"Scale: \" + scale + \" fontsSizedForScale:\" + fontsSizedForScale );    \n\n        var d = this.data; //the original json data\n        var fontSize = Math.round( 1300 / scale / fontsSizedForScale )/100;\n        var fudge = 1.0; //0.75*mx because we use a smaller font than seamly2d\n\n        //This is different to seamly2d behaviour, we'll actually reduce mx/my a bit if you zoom in\n        if ( fontsSizedForScale > 1 )\n            fudge = (1 + 1/fontsSizedForScale) /2;\n\n        var mx = (typeof d.mx === \"undefined\") ? 0 : d.mx;\n        var my = (typeof d.my === \"undefined\") ? 0 : d.my;\n\n        //some odd data exists out there in operation results of splines e.g. 3 Button Sack rev.1\n        if (( mx >= 2147480000 ) || ( my >= 2147480000 ))\n        {\n            mx = 0;\n            my = 0;\n        }\n\n        var pos = { labelX: this.p.x + fudge * mx,\n                    labelY: this.p.y + fudge * ( my + fontSize ),\n                    labelLineX: this.p.x + fudge * mx,  //line goes to left of label\n                    labelLineY: this.p.y + fudge * ( my + 0.5 * fontSize ), //line always goes to vertical midpoint of text\n                    fontSize: fontSize\n                    };\n\n        //TODO adjust the labelLine to be cleverer, intersecting a boundary box around the text.      \n        \n        if (( mx <= 0 ) && ( d.name ))\n            pos.labelLineX = this.p.x + fudge * ( mx + 0.5 * d.name.length * fontSize ); //otherwise line goes to center of label\n\n        if ( my <= 0 )\n            pos.labelLineY = this.p.y + fudge * ( my + fontSize ); //align to bottom of text\n\n        var minLineLength = 2 * fontSize;\n\n        pos.drawLine =    ( Math.abs( this.p.x - pos.labelX ) > minLineLength )\n                       || ( Math.abs( this.p.y - pos.labelY ) > minLineLength );\n\n        //TODO drawing a line can become newly desirable because of zooming, but we won't have added it. \n\n        return pos;\n    }\n\n\n    getLengthAndUnits()\n    {\n        var l = undefined;\n\n        if ( this.line )\n            l = this.line.length;\n        else if (( this.curve ) && ( typeof this.curve.pathLength === \"function\" ))\n            l = this.curve.pathLength();\n        else if (( this.arc ) && ( typeof this.arc.pathLength === \"function\" ))\n            l = this.arc.pathLength();\n\n        if ( l !== undefined )\n        {\n            const patternUnits = this.patternPiece.pattern.units;\n            var precision = patternUnits === \"mm\" ? 10.0 : 100.0;\n            l = Math.round( precision * l ) / precision;            \n            return l + \" \" + patternUnits;    \n        }\n            \n        throw \"Unknown length\";\n    }\n\n\n    drawDot( g, drawingOptions ) {\n\n        if ( ! drawingOptions.dot )\n            return; \n\n        const isOutline = drawingOptions.outline;\n        g.append(\"circle\")\n            .attr(\"cx\", this.p.x)\n            .attr(\"cy\", this.p.y)\n            .attr(\"r\", Math.round( ( isOutline ? 1200 : 400 ) / scale ) /100 );\n    }\n\n\n    drawLine( g, drawingOptions ) {\n\n        const isOutline = drawingOptions.outline;\n        \n        if ( this.lineVisible() && this.line ) //If there was an error, line may not be set. \n        {\n            var l = g.append(\"line\")\n                     .attr(\"x1\", this.line.p1.x)\n                     .attr(\"y1\", this.line.p1.y)\n                     .attr(\"x2\", this.line.p2.x)\n                     .attr(\"y2\", this.line.p2.y)\n                     .attr(\"stroke-width\", this.getStrokeWidth( isOutline ) );\n\n            if ( ! isOutline )\n                l.attr(\"stroke\", this.getColor() )\n                 .attr(\"class\", this.getLineStyle() );\n        }\n    }\n\n\n    drawPath( g, path, drawingOptions ) {\n\n        const isOutline = drawingOptions.outline;\n\n        if ( this.lineVisible() )\n        {\n            var p = g.append(\"path\")\n                    .attr(\"d\", path )\n                    .attr(\"fill\", \"none\")\n                    .attr(\"stroke-width\", this.getStrokeWidth( isOutline) );\n\n            if ( ! isOutline )        \n                p.attr(\"stroke\", this.getColor() )\n                 .attr(\"class\", this.getLineStyle() );\n        }\n    }    \n\n\n    drawCurve( g, drawingOptions ) {\n\n        const isOutline = drawingOptions.outline;\n\n        if ( ( this.lineVisible() ) && this.curve )\n            this.drawPath( g, this.curve.svgPath(), drawingOptions );\n    }\n\n\n    drawArc( g, drawingOptions ) {\n\n        const isOutline = drawingOptions.outline;\n        \n        if ( ( this.lineVisible() /*|| isOutline*/ ) && this.arc )\n        {\n                if ( this.lineVisible() )\n                {\n                    if (    ( this.arc instanceof GeoEllipticalArc )\n                         && ( this.arc.useSvgEllipse() ) )\n                    {\n                        var p = g.append(\"ellipse\")\n                        .attr(\"transform\", \"rotate(\" + this.arc.rotationAngle + \")\" )\n                        .attr(\"cx\", this.arc.center.x )\n                        .attr(\"cy\", this.arc.center.y )\n                        .attr(\"rx\", this.arc.radius1 )\n                        .attr(\"ry\", this.arc.radius2 )\n                        .attr(\"fill\", \"none\")\n                        .attr(\"stroke-width\", this.getStrokeWidth( isOutline) );\n    \n                        if ( ! isOutline )        \n                            p.attr(\"stroke\", this.getColor() )\n                            .attr(\"class\", this.getLineStyle() );    \n                    }\n                    else\n                        this.drawPath( g, this.arc.svgPath(), drawingOptions );    \n                }\n\n                //Labels that are along the line  should only show if we're drawing the line\n                this.drawLabel(g, drawingOptions);\n        }            \n    }\n\n\n    ref() {\n        return '<a class=\"ps-ref\">' + this.data.name + '</a>';\n    }\n\n\n    refOf( anotherDrawingObject ) {\n        if ( ! anotherDrawingObject )\n            return \"???\";\n\n        if ( ! anotherDrawingObject.ref )\n            return \"????\";\n\n        return anotherDrawingObject.ref();\n    }\n\n\n    getStrokeWidth( isOutline, isSelected )\n    {\n        return Math.round( 1000 * ( isOutline ? 7.0 : ( isSelected ? 3.0 : 1.0 ) ) / scale / fontsSizedForScale ) /1000;\n    }\n\n\n    getColor() {\n\n        if (( this.data.color === \"black\" ) && ( typeof iskDarkMode !== \"undefined\" ) && iskDarkMode )\n            return \"white\";\n\n        if (( this.data.color === \"white\" ) && ( typeof iskDarkMode !== \"undefined\" )&& ( ! iskDarkMode ) )\n            return \"black\";\n          \n        return this.data.color;\n    }\n\n    \n    getLineStyle()\n    {\n        return this.data.lineStyle;\n    }\n\n\n    lineVisible() {\n        return this.data.lineStyle !== \"none\";\n    }\n\n\n    pointEndLine(data) {\n        data.objectType = \"pointEndLine\";\n        data.basePoint = this;\n        return this.patternPiece.add(data);\n    }\n\n\n    pointAlongLine(data) {\n        data.objectType = \"pointAlongLine\";\n        data.firstPoint = this;\n        return this.patternPiece.add(data);\n    }\n\n\n    lineTo(data) {\n        data.objectType = \"line\";\n        data.firstPoint = this;\n        return this.patternPiece.add(data);\n    }\n\n\n    pointLineIntersect(data) {\n        data.objectType = \"pointLineIntersect\";\n        data.p1Line1 = this;\n        return this.patternPiece.add(data);\n    }\n\n\n    setIsMemberOfGroup( group )\n    {\n        if ( ! this.memberOf )        \n            this.memberOf = [];\n\n        this.memberOf.push( group );\n    }\n\n\n    isVisible( options )\n    {\n        if ( this.memberOf )   \n        {\n            var isVisible = false;\n\n            this.memberOf.forEach( \n                function(g) { \n                if ( g.visible ) \n                    isVisible = true; \n            } ); \n\n            if ( ! isVisible )\n                return false; //We are in 1+ groups, but none were visible.\n        }\n\n        if ( options && options.targetPiece )\n        {\n            //TODO get rid of this now that we have skipDrawing\n            if ( options.downloadOption ) //see elsewhere where we use the same control.\n                return false; //Should targetPiece mean we don't display any drawing objects? \n\n            var isVisible = false;\n\n            //if this obj doesn't match a detailNode then return false\n            //if ( options.targetPiece.nodesByName[ this.data.name ] )\n            //    isVisible = true;\n\n            //TODO or if ! this.UsedByObjects\n            //return false\n            //if ( this.usedByPieces contains options.targetPiece )\n            //return true else return false\n\n            options.targetPiece.detailNodes.forEach( \n                function(n) { \n                    if ( n.dObj === this ) \n                        isVisible = true; \n            }, this ); \n\n            if ( ! isVisible )\n                return false;\n        }\n\n        return true;\n    }\n}\n","class ArcElliptical extends DrawingObject {\n\n    //center\n    //angle1\n    //angle2\n    //radius1\n    //radius2\n    //rotationAngle\n\n    constructor(data) {\n        super(data);\n\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = data.derivedName;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.center === \"undefined\")\n            this.center = this.patternPiece.getObject(d.center);\n        if (typeof this.angle1 === \"undefined\")\n            this.angle1 = this.patternPiece.newFormula(d.angle1);\n        if (typeof this.angle2 === \"undefined\")\n            this.angle2 = this.patternPiece.newFormula(d.angle2);\n        if (typeof this.radius1 === \"undefined\")\n            this.radius1 = this.patternPiece.newFormula(d.radius1);\n        if (typeof this.radius2 === \"undefined\")\n            this.radius2 = this.patternPiece.newFormula(d.radius2);\n        if (typeof this.rotationAngle === \"undefined\")\n            this.rotationAngle = this.patternPiece.newFormula(d.rotationAngle);\n\n        this.arc = new GeoEllipticalArc( this.center.p, \n                                         this.radius1.value(),\n                                         this.radius2.value(), \n                                         this.angle1.value(), \n                                         this.angle2.value(),\n                                         this.rotationAngle.value() );\n        /*\n        if ( this.rotationAngle.value() != 0 )                                         \n        this.debugArc = new GeoEllipticalArc( this.center.p, \n                                            this.radius1.value(),\n                                            this.radius2.value(), \n                                            this.angle1.value(), \n                                            this.angle2.value(),\n                                            0 );*/\n   \n        this.p = this.arc.pointAlongPathFraction( 0.5 );\n\n        this.adjustBounds( bounds );\n    }\n\n    \n    adjustBounds( bounds )\n    {\n        bounds.adjust( this.p );\n        this.arc.adjustBounds( bounds );\n    }\n\n\n    pointAlongPath( length )\n    {\n        return this.arc.pointAlongPath( length );\n    }\n    \n\n    asShapeInfo()\n    {\n        return this.arc.asShapeInfo();\n    }\n\n\n    draw( g, drawOptions ) {\n        this.drawArc( g, drawOptions );        \n        //this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'elliptical arc with center ' + this.refOf( this.center )\n                + \" radius-x \" + this.radius1.htmlLength( asFormula ) \n                + \" radius-y \" + this.radius2.htmlLength( asFormula ) \n                + \" from angle \" + this.angle1.htmlAngle( asFormula ) \n                + \" to \" + this.angle2.htmlAngle( asFormula )\n                + \" rotation angle \" + this.rotationAngle.htmlAngle( asFormula ) ;\n    }\n\n    \n    setDependencies( dependencies ) {\n        dependencies.add( this, this.center );\n        dependencies.add( this, this.angle1 );\n        dependencies.add( this, this.angle2 );\n        dependencies.add( this, this.rotationAngle );\n        dependencies.add( this, this.radius1 );\n        dependencies.add( this, this.radius2 );\n    }    \n}\n","class ArcSimple extends DrawingObject {\n\n    //center\n    //angle1\n    //angle2\n    //radius \n\n    constructor(data) {\n        super(data);\n\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = data.derivedName;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.center === \"undefined\")\n            this.center = this.patternPiece.getObject(d.center);\n        if (typeof this.angle1 === \"undefined\")\n            this.angle1 = this.patternPiece.newFormula(d.angle1);\n        if (typeof this.angle2 === \"undefined\")\n            this.angle2 = this.patternPiece.newFormula(d.angle2);\n        if (typeof this.radius === \"undefined\")\n            this.radius = this.patternPiece.newFormula(d.radius);\n\n        this.arc = new GeoArc( this.center.p, this.radius.value(), this.angle1.value(), this.angle2.value() );\n\n        this.p = this.arc.pointAlongPathFraction( 0.5 );\n\n        this.adjustBounds( bounds );\n    }\n\n    \n    adjustBounds( bounds )\n    {\n        bounds.adjust( this.p ); //not necessarily\n        this.arc.adjustBounds( bounds );\n    }\n\n\n    pointAlongPath( length ) {\n        return this.arc.pointAlongPath( length );\n    }\n    \n\n    asShapeInfo() {\n        return this.arc.asShapeInfo();\n    }\n\n\n    draw( g, drawOptions ) {\n\n        this.drawArc( g, drawOptions );\n        //this.drawLabel(g, drawOptions ); Only do the label if the line style!=none\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'arc with center ' + this.refOf( this.center )\n                + \" radius \" + this.radius.htmlLength( asFormula ) \n                + \" from angle \" + this.angle1.htmlAngle( asFormula ) \n                + \" to \" + this.angle2.htmlAngle( asFormula );\n    }\n\n    \n    setDependencies( dependencies ) {\n        dependencies.add( this, this.center );\n        dependencies.add( this, this.angle1 );\n        dependencies.add( this, this.angle2 );\n        dependencies.add( this, this.radius );\n    }    \n}\n","class CutSpline extends DrawingObject { //TODO for consistency should be PointCutSpline ???\n\n    //curve\n    //length\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.curve === \"undefined\")\n            this.curve = this.patternPiece.getObject(d.spline);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n\n        //Note tha this.curve might be something like a SplineSimple, but it might also be an OperationResult\n        this.p = this.curve.pointAlongPath( this.length.value() );\n        this.adjustBounds( bounds );\n    }\n\n    \n    adjustBounds( bounds )\n    {        \n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, drawOptions ) {\n        //this.drawLine( g );\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + this.data.length.htmlLength( asFormula ) \n                + \" along curve \" + this.refOf( this.curve );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.curve );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","//(c) Copyright 2019 Jason Dore\n//https://github.com/MrDoo71/PatternEditor\n\nvar scale;\n\n\n","class Line extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.firstPoint);\n            \n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.secondPoint);\n\n        this.line = new GeoLine(this.firstPoint.p, this.secondPoint.p);\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjustForLine(this.line);\n    }\n\n\n    draw( g, drawOptions ) {\n        \n        this.drawLine( g, drawOptions );\n\n        this.drawLabel( g, drawOptions );\n        \n        //TODO we could display the derived name Line_A1_A2 at the mid-point along the line?       \n\n        //TODO for all lines we could draw a thicker invisible line do make it easier to click on the line.\n    }\n\n\n    html( asFormula ) {\n        return 'line ' + this.refOf( this.firstPoint ) + \" - \" + this.refOf( this.secondPoint );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n    }    \n}\n","class OperationFlipByAxis extends DrawingObject {\n\n    //operationName\n    //suffix\n    //center\n    //axis\n\n    constructor(data) {\n        super(data);\n        this.data.name = data.operationName;\n        this.axis = data.axis;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.center === \"undefined\")\n            this.center = this.patternPiece.getObject(d.center);\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        //Done by OperationResult\n    }\n\n\n    draw( g, drawOptions ) {\n        //g is the svg group\n        //this.drawLine( g ); //TODO put an arrow head on this!\n        //this.drawDot( g );\n        //this.drawLabel( g );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + 'Flip ' + this.axis \n                + \" around \" + this.refOf( this.center ) \n                         //\" angle:\" + this.data.angle.value() +\n                + \" applying suffix '\" + this.data.suffix + \"'\";\n    }\n\n\n    applyOperationToPoint( p ) {\n        return this.flipPoint( p, this.center.p );\n    }\n\n\n    flipPoint( p, center ) {\n        var result = new GeoPoint( p.x, p.y );\n\n        if (    ( this.axis === \"Vertical\" ) \n             || ( this.axis === \"vertical\" )) //just in case.\n            result.x = center.x - ( p.x - center.x );\n        else\n            result.y = center.y - ( p.y - center.y );\n\n        return result;\n    }\n\n    \n    setDependencies( dependencies ) {\n        dependencies.add( this, this.center );\n    }    \n\n}\n","class OperationFlipByLine extends DrawingObject {\n\n    //operationName\n    //suffix\n    //p1Line1\n    //p2Line1\n  \n\n    constructor(data) {\n        super(data);\n        this.data.name = data.operationName;\n        this.axis = data.axis;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.p1Line1 === \"undefined\")\n            this.p1Line1 = this.patternPiece.getObject(d.p1Line1);\n\n        if (typeof this.p2Line1 === \"undefined\")\n            this.p2Line1 = this.patternPiece.getObject(d.p2Line1);\n\n        this.line = new GeoLine( this.p1Line1.p, this.p2Line1.p );\n\n        this.adjustBounds( bounds );\n    }\n\n    adjustBounds( bounds )\n    {\n        //Done by OperationResult\n    }\n\n\n    draw( g, drawOptions ) {\n        //g is the svg group\n        //this.drawLine( g ); //TODO put an arrow head on this!\n        //this.drawDot( g );\n        //this.drawLabel( g );\n\n        this.drawLine( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + 'Flip over line ' + this.refOf( this.p1Line1 ) \n                + \"-\" + this.refOf( this.p2Line1 ) \n                + \" applying suffix '\" + this.data.suffix + \"'\";\n    }\n\n\n    applyOperationToPoint( p ) {\n\n        return this.flipPoint( p, this.line );\n    }\n\n\n    flipPoint( p, line ) {\n        \n        //image the point of view rotated such that this.line is on the x-axis at 0deg. \n        //if the line is at 45deg, rotate the line and the source point by -45 deg. flip the y component, then rotate back by +45. \n\n        var p0 = p.rotate( this.line.p1, -this.line.angleDeg() );\n\n        var p0f = new GeoPoint( p0.x, this.line.p1.y - ( p0.y - this.line.p1.y ) );\n\n        var result = p0f.rotate( this.line.p1, this.line.angleDeg() );\n\n        return result;\n    }\n\n    \n    setDependencies( dependencies ) {\n        dependencies.add( this, this.p1Line1 );\n        dependencies.add( this, this.p2Line1 );\n    }    \n\n}\n","class OperationMove extends DrawingObject {\n\n    //operationName\n    //suffix\n    //angle\n    //length\n\n    constructor(data) {\n        super(data);\n        this.data.name = data.operationName;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        //if (typeof this.basePoint === \"undefined\")\n        //    this.basePoint = this.patternPiece.getObject(d.basePoint);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n            \n        if (typeof this.angle === \"undefined\")\n            this.angle = this.patternPiece.newFormula(d.angle);\n            \n        //Convert degrees to radians\n        //this.p = this.basePoint.p.pointAtDistanceAndAngleRad(this.length.value(), Math.PI * 2 * this.angle.value() / 360);\n        //this.line = new GeoLine(this.basePoint.p, this.p);\n        //bounds.adjustForLine(this.line);\n        \n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        //Done by OperationResult\n    }\n\n\n    draw( g, drawOptions ) {\n        //g is the svg group\n        //this.drawLine( g ); //TODO put an arrow head on this!\n        //this.drawDot( g );\n        //this.drawLabel( g );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                    + 'Move ' + this.data.length.htmlLength( asFormula ) \n                    //\" from \" + this.basePoint.data.name +\n                    + \" at angle \" + this.data.angle.htmlAngle( asFormula ) \n                    + \" applying suffix '\" + this.data.suffix + \"'\";\n    }\n\n\n    applyOperationToPoint( p ) {\n        //Convert degrees to radians\n        var result = p.pointAtDistanceAndAngleDeg( this.length.value(), this.angle.value() );\n        //var line = new GeoLine( source.p, result.p );\n        return result;\n    }\n\n\n    setDependencies( dependencies ) {\n        //dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.length );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","class OperationResult extends DrawingObject {\n\n    //basePoint\n    //fromOperation\n\n    constructor(data) {\n        super(data);\n        this.data.name = data.derivedName;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.patternPiece.getObject(d.basePoint);\n\n        if (typeof this.fromOperation === \"undefined\")\n            this.fromOperation = this.patternPiece.getObject(d.fromOperation);\n\n        //if this.basePoint is a point... (if a curve, this is the midpoint)\n        if ( this.basePoint.p )\n            this.p = this.fromOperation.applyOperationToPoint( this.basePoint.p );\n\n        var operation = this.fromOperation;\n        var applyOperationToPointFunc = function( p ) {\n            return operation.applyOperationToPoint( p );\n        };\n\n        if ( this.basePoint.curve instanceof GeoSpline )\n        {\n            //so we get this captured and can just pass the function around\n            this.curve = this.basePoint.curve.applyOperation( applyOperationToPointFunc );\n        }\n\n        if ( this.basePoint.line instanceof GeoLine ) //untested?\n        {\n            this.line = this.basePoint.line.applyOperation( applyOperationToPointFunc );\n        }\n\n        if (   ( this.basePoint.arc instanceof GeoArc ) //untested?\n            || ( this.basePoint.arc instanceof GeoEllipticalArc ) )\n        {\n            this.arc = this.basePoint.arc.applyOperation( applyOperationToPointFunc );\n        }\n\n        //TODO This line would be useful if the operation, or operation result is selected. \n        //THOUGH, if the operation is a rotate then drawing an arc would be useful. \n        //this.operationLine = new GeoLine(this.basePoint.p, this.p);\n\n        if (( this.line ) || ( this.curve ) || ( this.arc ))\n        {\n            if ( ! this.data.lineStyle )\n                this.data.lineStyle = this.basePoint.data.lineStyle;\n\n            if ( ! this.data.color )    \n                this.data.color = this.basePoint.data.color;\n        }\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust( this.p );\n    }\n\n    \n    pointAlongPath( length ) {\n\n        if ( this.arc )\n            return this.arc.pointAlongPath( length );\n\n        if ( this.curve )\n            return this.curve.pointAlongPath( length );\n            \n        throw \"pointAlongPath not implemented for this operation result. \";\n    }\n\n\n    getColor() {\n        return this.basePoint.getColor();\n    }\n\n    \n    getLineStyle() {\n        return this.basePoint.getLineStyle();\n    }\n\n\n    draw( g, drawOptions ) {\n        //g is the svg group\n\n        //We might have operated on a point, spline (or presumably line)\n\n        if (( this.p ) && ( ! this.curve ) && ( ! this.arc ))\n            this.drawDot( g, drawOptions );\n\n        if ( this.curve )\n            this.drawCurve( g, drawOptions ); \n\n        if ( this.arc )\n            this.drawArc( g, drawOptions );             \n\n        if ( this.line )\n            this.drawLine( g, drawOptions ); \n            \n        if ( this.p )\n            this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'Result of ' + this.refOf( this.fromOperation )\n                + ' on ' + this.refOf( this.basePoint ); \n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.fromOperation );\n    }    \n\n}\n","class OperationRotate extends DrawingObject {\n\n    //operationName\n    //suffix\n    //angle\n    //center\n\n    constructor(data) {\n        super(data);\n        this.data.name = data.operationName;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.center === \"undefined\")\n            this.center = this.patternPiece.getObject(d.center);\n            \n        if (typeof this.angle === \"undefined\")\n            this.angle = this.patternPiece.newFormula(d.angle);            \n            \n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        //Done by OperationResult\n    }\n\n\n    draw( g, drawOptions ) {\n        //g is the svg group\n        //this.drawLine( g ); //TODO put an arrow head on this!\n        //this.drawDot( g );\n        //this.drawLabel( g );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'Rotate: ' \n                + this.data.angle.htmlAngle( asFormula ) \n                + \" around \" + this.refOf( this.center ) \n                + \" applying suffix '\" + this.data.suffix + \"'\";\n    }\n\n\n    applyOperationToPoint( p ) {\n        return p.rotate( this.center.p, this.angle.value() );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.center );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","class PerpendicularPointAlongLine extends DrawingObject {\n\n    //basePoint\n    //firstPoint\n    //secondPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.patternPiece.getObject(d.basePoint);\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.p1Line1);\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.p2Line1);\n\n        var line = new GeoLine(this.firstPoint.p, this.secondPoint.p);\n        \n        var baseLine = new GeoLine( this.basePoint.p, this.basePoint.p.pointAtDistanceAndAngleDeg( 1, line.angleDeg() + 90 ) );\n\n        this.p = line.intersect(baseLine);\n        this.line = new GeoLine( this.basePoint.p, this.p );\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, drawOptions ) {\n        //g is the svg group\n        this.drawLine( g, drawOptions );\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'Point along line ' + this.refOf( this.firstPoint ) + ' - ' + this.refOf( this.secondPoint )\n                + ' where it is perpendicular to ' + this.refOf( this.basePoint );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.basePoint );\n    }    \n\n}\n","class PointAlongBisector extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n    //thirdPoint\n    //length\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.firstPoint);\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.secondPoint);\n        if (typeof this.thirdPoint === \"undefined\")\n            this.thirdPoint = this.patternPiece.getObject(d.thirdPoint);\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n            \n        var line1 = new GeoLine( this.secondPoint.p, this.firstPoint.p );    \n        var line2 = new GeoLine( this.secondPoint.p, this.thirdPoint.p );    \n\n        //TODO test what happens when this crosses the equator! i.e. one point is just below the equator and one just above (and in either direction)\n        var bisectingAngle = ( line1.angleDeg() + line2.angleDeg() ) /2;\n\n        //Convert degrees to radians\n        this.p = this.secondPoint.p.pointAtDistanceAndAngleDeg( this.length.value(), bisectingAngle );\n        this.line = new GeoLine(this.secondPoint.p, this.p);\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjustForLine(this.line);\n    }\n\n\n    draw( g, drawOptions ) {\n        //g is the svg group\n        this.drawLine( g, drawOptions );\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + this.data.length.htmlLength( asFormula ) \n                + \" along line bisecting \" + this.refOf( this.secondPoint ) \n                + \"-\" + this.refOf( this.firstPoint )\n                + \" and \" + this.refOf( this.secondPoint ) \n                + \"-\" + this.refOf( this.thirdPoint );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.thirdPoint );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","class PointAlongLine extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n    //length\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.firstPoint);\n\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.secondPoint);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n\n        this.baseLine = new GeoLine(this.firstPoint.p, this.secondPoint.p);\n        this.p = this.firstPoint.p.pointAtDistanceAndAngleRad(this.length.value(this.baseLine.length), this.baseLine.angle);\n        this.line = new GeoLine(this.firstPoint.p, this.p);\n        \n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjustForLine(this.line);\n    }\n\n\n    draw( g, drawOptions ) {\n        this.drawLine( g, drawOptions );\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        \n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + this.data.length.htmlLength( asFormula, this.baseLine? this.baseLine.length : 0 ) \n                + \" along line from \" + this.refOf( this.firstPoint )\n                + \" to \" + this.refOf( this.secondPoint );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","class PointAlongPerpendicular extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n    //length\n    //angle\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.firstPoint);\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.secondPoint);\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n        if (typeof this.angle === \"undefined\")\n            this.angle = this.patternPiece.newFormula(d.angle);\n            \n        var baseLine = new GeoLine( this.firstPoint.p, this.secondPoint.p );    \n        var totalAngle = this.angle.value() + 90 + baseLine.angleDeg();\n        //Convert degrees to radians\n        this.p = this.firstPoint.p.pointAtDistanceAndAngleDeg( this.length.value(), totalAngle );\n        this.line = new GeoLine(this.firstPoint.p, this.p);\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjustForLine(this.line);\n    }\n\n\n    draw( g , drawOptions ) {\n        //g is the svg group\n        this.drawLine( g, drawOptions );\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        var h = '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + this.data.length.htmlLength( asFormula ) \n                + \" from \" + this.refOf( this.firstPoint ) \n                + \" perpendicular to the line to \" + this.refOf( this.secondPoint );\n\n        if (    ( this.data.angle.constant )\n             && ( this.data.angle.constant != 0 ) )\n            h += \" additional angle \" + this.data.angle.htmlAngle( asFormula );\n\n        return h;\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.length );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","class PointCutArc extends DrawingObject {\n\n    //arc\n    //length\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.arc === \"undefined\")\n            this.arc = this.patternPiece.getObject(d.arc);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n\n        this.p = this.arc.pointAlongPath( this.length.value() );\n        \n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n    \n    draw( g, drawOptions ) {\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + this.data.length.htmlLength( asFormula ) \n                + \" along arc \" + this.refOf( this.arc );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.arc );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","class PointCutSplinePath extends DrawingObject {\n\n    //splinePath\n    //length\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.splinePath === \"undefined\")\n            this.splinePath = this.patternPiece.getObject(d.splinePath);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n\n        this.p = this.splinePath.pointAlongPath( this.length.value() );\n        \n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, drawOptions ) {\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + this.data.length.htmlLength( asFormula ) \n                + \" along path \" + this.refOf( this.splinePath );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.splinePath );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","class PointEndLine extends DrawingObject {\n\n    //basePoint\n    //length\n    //angle\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.patternPiece.getObject(d.basePoint);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n            \n        if (typeof this.angle === \"undefined\")\n            this.angle = this.patternPiece.newFormula(d.angle);\n\n        this.p = this.basePoint.p.pointAtDistanceAndAngleDeg( this.length.value(), this.angle.value() );\n        this.line = new GeoLine(this.basePoint.p, this.p);\n        \n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjustForLine(this.line);\n    }\n\n\n    draw( g, drawOptions ) {\n        this.drawLine( g, drawOptions );\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + this.data.length.htmlLength( asFormula ) \n                + \" from \" + this.refOf( this.basePoint ) \n                + \" angle \" + this.data.angle.htmlAngle( asFormula );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.length );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","class PointFromArcAndTangent extends DrawingObject {\n\n    //arc\n    //tangent\n    //crossPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.tangent === \"undefined\")\n            this.tangent = this.patternPiece.getObject(d.tangent);\n\n        if (typeof this.arc === \"undefined\")\n            this.arc = this.patternPiece.getObject(d.arc); \n\n        this.crossPoint = d.crossPoint;\n\n        var tangentIntersections = this.arc.arc.getPointsOfTangent( this.tangent.p );\n        \n        //TODO what is the real logic for crossPoint One vs Two\n        if ( this.crossPoint === \"One\" ) \n            this.p = tangentIntersections[1];\n        else \n            this.p = tangentIntersections[0];\n            \n        this.line = new GeoLine( this.tangent.p, this.p );\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, drawOptions ) {\n        this.drawLine(g, drawOptions );\n        this.drawDot(g, drawOptions );\n        this.drawLabel(g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + 'point on arc ' + this.refOf( this.arc ) //derivedName?\n                + ' of tangent from point ' + this.refOf( this.tangent )\n                + ' crosspoint:' + this.crossPoint;\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.tangent );\n        dependencies.add( this, this.arc );\n    }    \n\n}\n","class PointFromCircleAndTangent extends DrawingObject {\n\n    //center\n    //tangent\n    //crossPoint\n    //radius\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.tangent === \"undefined\")\n            this.tangent = this.patternPiece.getObject(d.tangent);\n\n        if (typeof this.arc === \"undefined\")\n            this.center = this.patternPiece.getObject(d.center); \n\n        if (typeof this.radius === \"undefined\")\n            this.radius = this.patternPiece.newFormula(d.radius);\n\n        this.crossPoint = d.crossPoint;\n\n        var circle = new GeoArc( this.center.p, this.radius.value(), 0, 360 );\n\n        var tangentIntersections = circle.getPointsOfTangent( this.tangent.p );\n        \n        //TODO what is the real logic for crossPoint One vs Two\n        if ( this.crossPoint === \"One\" ) \n            this.p = tangentIntersections[1];\n        else \n            this.p = tangentIntersections[0];\n            \n        this.line = new GeoLine( this.tangent.p, this.p );\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, drawOptions ) {\n        this.drawLine(g, drawOptions );\n        this.drawDot(g, drawOptions );\n        this.drawLabel(g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + 'point on circle with center ' + this.refOf( this.center ) \n                + ' radius ' + this.radius.htmlLength( asFormula ) \n                + ' of tangent from point ' + this.refOf( this.tangent )\n                + ' crosspoint:' + this.crossPoint;\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.tangent );\n        dependencies.add( this, this.center );\n        dependencies.add( this, this.radius );\n    }    \n\n}\n","class PointFromXandYOfTwoOtherPoints extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.firstPoint);\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.secondPoint);\n\n        this.p = new GeoPoint( this.firstPoint.p.x, this.secondPoint.p.y );\n        //this.line = new GeoLine(this.firstPoint.p, this.secondPoint.p);\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, drawOptions ) {\n        //TODO check that there is no option to draw a line as part of this tool. \n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>:' +\n               ' point at X from ' + this.refOf( this.firstPoint ) +  \" and Y from \" + this.refOf( this.secondPoint );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n    }    \n}\n","class PointIntersectArcAndAxis extends DrawingObject {\n\n    //arc (provided as \"curve\"), and may be an arc or a spline (by observation)\n    //basePoint\n    //angle\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.patternPiece.getObject(d.basePoint);\n\n        if (typeof this.arc === \"undefined\")\n            this.arc = this.patternPiece.getObject(d.curve); //An anomaly, would be better if this were arc.\n\n        if (typeof this.angle === \"undefined\")\n            this.angle = this.patternPiece.newFormula(d.angle);\n\n        var angleDeg = this.angle.value();\n        if ( angleDeg >= 360 )\n            angleDeg -= 360;\n        else if ( angleDeg < 0 )\n            angleDeg += 360;\n\n        var curveOrArc = ( this.arc.arc ) ? this.arc.arc : this.arc.curve ;\n\n        //Rather than use an arbitrarily long line (which was causing issues)\n        //calculate the max length of line. The line cannot be longer than\n        //the bounding box encompassing the basePoint and the curve. \n        var tempBounds = new Bounds();\n        tempBounds.adjust( this.basePoint.p );\n        this.arc.adjustBounds( tempBounds );\n        var maxLineLength = tempBounds.diagonaglLength() * 1.25;\n        \n        let otherPoint = this.basePoint.p.pointAtDistanceAndAngleDeg( maxLineLength, angleDeg );\n\n        var longLine = new GeoLine( this.basePoint.p, otherPoint );\n\n        this.p = longLine.intersectArc( curveOrArc );\n\n        this.line = new GeoLine( this.basePoint.p, this.p );\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, drawOptions ) {\n        //g is the svg group\n        this.drawLine(g, drawOptions );\n        this.drawDot(g, drawOptions );\n        this.drawLabel(g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        //TODO use a better name for this.curve, e.g. Arc_A_nn\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'intersect arc ' + this.refOf( this.arc )\n                + \" with line from \" + this.refOf( this.basePoint ) \n                + \" at angle \" + this.angle.htmlAngle( asFormula );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.arc );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","class PointIntersectArcAndLine extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n    //center\n    //radius\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.firstPoint);\n            \n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.secondPoint);\n\n        if (typeof this.center === \"undefined\")\n            this.center = this.patternPiece.getObject(d.center);\n\n        if (typeof this.radius === \"undefined\")\n            this.radius = this.patternPiece.newFormula(d.radius);\n\n        var line = new GeoLine( this.firstPoint.p, this.secondPoint.p );\n        var arc  = new GeoArc( this.center.p, this.radius.value(), 0, 360 );\n\n        this.p = line.intersectArc( arc );\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, drawOptions ) {\n\n        //TODO draw the line between basePoint and p\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        \n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + 'intersect arc with center ' \n                + this.refOf( this.center ) \n                + \", radius \" + this.radius.htmlLength( asFormula ) \n                +  \" with line \" + this.refOf( this.firstPoint ) \n                + \"-\" + this.refOf( this.secondPoint );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.center );\n        dependencies.add( this, this.radius );\n    }    \n\n}\n","class PointIntersectArcs extends DrawingObject {\n\n    //firstArc\n    //secondArc\n    //crossPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstArc === \"undefined\")\n            this.firstArc = this.patternPiece.getObject(d.firstArc);\n            \n        if (typeof this.secondArc === \"undefined\")\n            this.secondArc = this.patternPiece.getObject(d.secondArc);\n\n        var arc1SI = this.firstArc.asShapeInfo();\n        var arc2SI = this.secondArc.asShapeInfo();\n\n        var intersections = Intersection.intersect(arc1SI, arc2SI);\n        \n        //intersections.points.forEach(console.log);    \n\n        if ( intersections.points.length === 0 )\n        {\n            throw \"No intersections found. \";\n        }\n        else if ( intersections.points.length === 1 )\n        {\n            this.p = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n        }\n        else\n        {\n            //TODO A5 in the test should be (0,0) as the point of intersection is not during the specified angle of the arcs.\n            //For each intersection point\n            //TODO check that GeoLine( this.firstArc.center.p, p1)).angleDeg() between this.firstArc.arc.angle1 and this.firstArc.arc.angle2\n            //and similar for secondArc\n\n            //What is the angle in the first arc of the intersection point?\n            //One = smallest angle in the first arc.\n            //Two = largest angle in the first arc.\n            var p1 = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n            var p2 = new GeoPoint( intersections.points[1].x, intersections.points[1].y );\n            var angle1 = (new GeoLine( this.firstArc.center.p, p1)).angle;\n            var angle2 = (new GeoLine( this.firstArc.center.p, p2)).angle;\n\n            if ( this.data.crossPoint === \"One\" )\n            {\n                if ( angle1 < angle2 )\n                    this.p = p1;\n                else\n                    this.p = p2;\n            }            \n            else \n            {\n                if ( angle1 < angle2 )\n                    this.p = p2;\n                else\n                    this.p = p1;\n            }\n        }\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, drawOptions ) {\n        this.drawDot(g, drawOptions );\n        this.drawLabel(g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'intersect arcs ' + this.refOf( this.firstArc )\n                + \" and \" + this.refOf( this.secondArc )\n                + ( this.data.crossPoint === \"One\" ? \"\" : \" - second point\");\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstArc );\n        dependencies.add( this, this.secondArc );\n    }    \n\n}\n","class PointIntersectCircles extends DrawingObject {\n\n    //center1     ??? Confirm\n    //radiu1   ??? Confirm\n    //center2   ??? Confirm\n    //radius2  ??? Confirm\n    //crossPoint    ??? Confirm\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.center1 === \"undefined\")\n            this.center1 = this.patternPiece.getObject(d.center1);\n            \n        if (typeof this.center2 === \"undefined\")\n            this.center2 = this.patternPiece.getObject(d.center2);\n\n        if (typeof this.radius1 === \"undefined\")\n            this.radius1 = this.patternPiece.newFormula(d.radius1);\n\n        if (typeof this.radius2 === \"undefined\")\n            this.radius2 = this.patternPiece.newFormula(d.radius2);\n\n        //Also this.data.crossPoint    \n        var circle1 = new GeoArc( this.center1.p, this.radius1.value(), 0, 360 );\n        var circle2 = new GeoArc( this.center2.p, this.radius2.value(), 0, 360 );\n\n        var arc1SI = circle1.asShapeInfo();\n        var arc2SI = circle2.asShapeInfo();\n\n        var intersections = Intersection.intersect(arc1SI, arc2SI);\n        \n        //intersections.points.forEach(console.log);    \n        \n        if ( intersections.points.length === 0 )\n        {\n            throw \"No intersections found. \";\n        }\n        else if ( intersections.points.length === 1 )\n        {\n            //surely there must always be two intersects, unless they just touch\n            this.p = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n        }\n        else\n        {\n            /* we do not know what logic valentina/seamly uses\n\n            the smallest angle, except that if angle1 beween 270 and 360 and angle2 between 0 and 90 then add 360 to angle2. */\n\n            //NB: this is a subset of the logic that applies to PointIntersectArcs.\n            //What is the angle in the first arc of the intersection point?\n            //One = smallest angle in the first arc.\n            //Two = largest angle in the first arc.\n            var p1 = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n            var p2 = new GeoPoint( intersections.points[1].x, intersections.points[1].y );\n            var angle1 = (new GeoLine( circle1.center, p1)).angleDeg();\n            var angle2 = (new GeoLine( circle1.center, p2)).angleDeg();\n            if (( angle1 >= 270 ) && ( angle2 > 0 ) && ( angle2 < 90 ))\n                angle2 += 360;\n            else if (( angle2 >= 270 ) && ( angle1 > 0 ) && ( angle1 < 90 ))\n                angle1 += 360;\n\n            if ( this.data.crossPoint === \"One\" )\n            {\n                if ( angle1 < angle2 )\n                    this.p = p1;\n                else\n                    this.p = p2;\n            }            \n            else \n            {\n                if ( angle1 < angle2 )\n                    this.p = p2;\n                else\n                    this.p = p1;\n            }\n            \n           /*\n            //this is just a guess.. TODO what happens if the two y's are the same??\n            var p1 = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n            var p2 = new GeoPoint( intersections.points[1].x, intersections.points[1].y );\n            if ( this.data.crossPoint === \"One\" )\n            {\n                if ( p1.y < p2.y )\n                    this.p = p2;\n                else\n                    this.p = p1;\n            }\n            else\n            {\n                if ( p1.y < p2.y )\n                    this.p = p1;\n                else\n                    this.p = p2;\n            }\n            */\n        }\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, drawOptions ) {\n        this.drawDot(g, drawOptions );\n        this.drawLabel(g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        //TODO use a better name for this.arc, e.g. Arc_A_nn\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'intersect circles ' + this.refOf( this.center1 ) \n                + \" radius \" + this.radius1.htmlAngle( asFormula ) \n                + \" and \" + this.refOf( this.center2 ) \n                + \" radius \" + this.radius2.htmlLength( asFormula )\n                + ( this.data.crossPoint === \"One\" ? \"\" : \" - second point\");\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.center1 );\n        dependencies.add( this, this.center2 );\n        dependencies.add( this, this.radius1 );\n        dependencies.add( this, this.radius2 );\n    }    \n\n}\n","class PointIntersectCurveAndAxis extends DrawingObject {\n\n    //basePoint\n    //curve\n    //angle\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.patternPiece.getObject(d.basePoint);\n\n        if (typeof this.curve === \"undefined\")\n            this.curve = this.patternPiece.getObject(d.curve);\n\n        if (typeof this.angle === \"undefined\")\n            this.angle = this.patternPiece.newFormula(d.angle);\n\n        var angleDeg = this.angle.value();\n        if ( angleDeg >= 360 )\n            angleDeg -= 360;\n        else if ( angleDeg < 0 )\n            angleDeg += 360;\n\n\n        //Rather than use an arbitrarily long line (which was causing issues)\n        //calculate the max length of line. The line cannot be longer than\n        //the bounding box encompassing the basePoint and the curve. \n        var tempBounds = new Bounds();\n        tempBounds.adjust( this.basePoint.p );\n        this.curve.adjustBounds( tempBounds );\n        var maxLineLength = tempBounds.diagonaglLength() * 1.25;\n        \n        let otherPoint = this.basePoint.p.pointAtDistanceAndAngleDeg( maxLineLength, angleDeg );\n\n        var line = new GeoLine( this.basePoint.p, otherPoint );\n\n        var lineSI = line.asShapeInfo();\n        var curveSI = this.curve.asShapeInfo();\n\n        var intersections = Intersection.intersect(lineSI, curveSI);        \n\n        if ( intersections.points.length === 0 )\n        {\n            throw \"No intersections found. \";\n        }\n        else\n        {\n            //intersections.points.forEach(console.log);    \n            this.p = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n        }\n        this.line = new GeoLine( this.basePoint.p, this.p );\n\n        this.adjustBounds( bounds );\n    }\n    \n        \n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n    \n    draw(g, drawOptions ) {\n        //g is the svg group\n        this.drawLine(g, drawOptions ); \n        this.drawDot(g, drawOptions );\n        this.drawLabel(g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'intersect curve ' + this.refOf( this.curve )\n                + \" with line from \" + this.refOf( this.basePoint )\n                + \" at angle \" + this.angle.htmlAngle( asFormula );\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.curve );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","class PointIntersectCurves extends DrawingObject {\n\n    //curve1\n    //curve2\n    //verticalCrossPoint\n    //horizontalCrossPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.curve1 === \"undefined\")\n            this.curve1 = this.patternPiece.getObject(d.curve1);\n            \n        if (typeof this.curve2 === \"undefined\")\n            this.curve2 = this.patternPiece.getObject(d.curve2);\n\n        var curve1SI = this.curve1.asShapeInfo();\n        var curve2SI = this.curve2.asShapeInfo();\n\n        var intersections = Intersection.intersect(curve1SI, curve2SI);\n        \n        //intersections.points.forEach(console.log);    \n        if ( intersections.points.length === 0 )\n        {\n            this.p = new GeoPoint(0,0);\n            this.error = \"No intersections found.\";\n            console.log( \"No intersections found. PointIntersectCurves: \" + d.name );\n        }        \n        else if ( intersections.points.length === 1 )\n        {\n            this.p = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n        }\n        else if ( intersections.points.length > 1 )    \n        {\n            //Vertical correction has first dibs. verticalCrossPoint==\"One\" means highest point; horizontalCrossPoint==\"One\" means leftmost point\n            var minXPnt, maxXPnt, minYPnt, maxYPnt;\n            for ( var i = 0; i<intersections.points.length; i++ )\n            {\n                var intersect = intersections.points[i];\n                if (( ! minXPnt ) || ( intersect.x < minXPnt.x ))\n                    minXPnt = intersect;\n                if (( ! maxXPnt ) || ( intersect.x > maxXPnt.x ))\n                    maxXPnt = intersect;\n                if (( ! minYPnt ) || ( intersect.y < minYPnt.y ))\n                    minYPnt = intersect;\n                if (( ! maxYPnt ) || ( intersect.y > maxYPnt.y ))\n                    maxYPnt = intersect;\n            }\n            if ( minYPnt !== maxYPnt )\n            {\n                if ( this.data.verticalCrossPoint === \"One\" )\n                    this.p = minYPnt;\n                else\n                    this.p = maxYPnt;\n            }\n            else\n            {\n                if ( this.data.horizontalCrossPoint === \"One\" )\n                    this.p = minXPnt;\n                else\n                    this.p = maxXPnt;\n            }\n        }\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, drawOptions ) {\n        this.drawDot(g, drawOptions );\n        this.drawLabel(g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        //TODO use a better name for this.curve, e.g. Arc_A_nn\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'intersect curve ' + this.refOf( this.curve1 ) \n                + \" with \" + this.refOf( this.curve2 );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.curve1 );\n        dependencies.add( this, this.curve2 );\n    }    \n\n}\n","class PointIntersectLineAndAxis extends DrawingObject {\n\n    //basePoint\n    //p1Line1\n    //p2Line1\n    //angle\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.patternPiece.getObject(d.basePoint);\n\n        if (typeof this.p1Line1 === \"undefined\")\n            this.p1Line1 = this.patternPiece.getObject(d.p1Line1);\n\n        if (typeof this.p2Line1 === \"undefined\")\n            this.p2Line1 = this.patternPiece.getObject(d.p2Line1);\n\n        if (typeof this.angle === \"undefined\")\n            this.angle = this.patternPiece.newFormula(d.angle);\n\n        var line1 = new GeoLine(this.p1Line1.p, this.p2Line1.p);\n\n        var otherPoint = this.basePoint.p.pointAtDistanceAndAngleDeg( 1, this.angle.value() );\n\n        var line2 = new GeoLine(this.basePoint.p, otherPoint );\n\n        this.p = line1.intersect(line2);\n        this.line = new GeoLine( this.basePoint.p, this.p );\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, drawOptions ) {\n        this.drawLine( g, drawOptions );\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + ' intersection of ' + this.refOf( this.p1Line1 ) \n                + \"-\" + this.refOf( this.p2Line1 ) \n                + \" with line from \" + this.refOf( this.basePoint ) \n                + \" at angle \" + this.angle.htmlAngle( asFormula );\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.p1Line1 );\n        dependencies.add( this, this.p2Line1 );\n        dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.angle );\n    }    \n\n\n}\n","class PointLineIntersect extends DrawingObject {\n\n    //p1Line1\n    //p2Line1\n    //p1Line2\n    //p2Line2\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.p1Line1 === \"undefined\")\n            this.p1Line1 = this.patternPiece.getObject(d.p1Line1);\n        if (typeof this.p2Line1 === \"undefined\")\n            this.p2Line1 = this.patternPiece.getObject(d.p2Line1);\n        if (typeof this.p1Line2 === \"undefined\")\n            this.p1Line2 = this.patternPiece.getObject(d.p1Line2);\n        if (typeof this.p2Line2 === \"undefined\")\n            this.p2Line2 = this.patternPiece.getObject(d.p2Line2);\n\n        this.line1 = new GeoLine(this.p1Line1.p, this.p2Line1.p);\n        this.line2 = new GeoLine(this.p1Line2.p, this.p2Line2.p);\n        this.p = this.line1.intersect(this.line2);\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, drawOptions ) {\n        this.drawDot(g, drawOptions );\n        this.drawLabel(g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'intersect ' + this.refOf( this.p1Line1 )\n                + \"-\" + this.refOf( this.p2Line1 ) \n                + \" with \" + this.refOf( this.p1Line2 ) \n                + \"-\" + this.refOf( this.p2Line2 );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.p1Line1 );\n        dependencies.add( this, this.p1Line2 );\n        dependencies.add( this, this.p2Line1 );\n        dependencies.add( this, this.p2Line2 );\n    }    \n\n\n}\n","class PointOfTriangle extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n    //p1Line1\n    //p2Line1\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.firstPoint);\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.secondPoint);\n\n        if (typeof this.p1Line1 === \"undefined\")\n            this.p1Line1 = this.patternPiece.getObject(d.p1Line1);\n        if (typeof this.p2Line1 === \"undefined\")\n            this.p2Line1 = this.patternPiece.getObject(d.p2Line1);\n\n            \n        var axisLine = new GeoLine( this.p1Line1.p, this.p2Line1.p );    \n        var otherLine = new GeoLine( this.firstPoint.p, this.secondPoint.p );\n\n        //Now we work out another point along the axis line that forms the right angle triangle \n        //with the otherLine.\n        //\n        //The trick here is to observe that all these points, for any axisLine will form an arc\n        //centered on the midpoint of otherLine with radiu of half length of otherLine\n        var intersectionPoint = axisLine.intersect( otherLine );\n        var midpoint = this.firstPoint.p.pointAtDistanceAndAngleRad( otherLine.length/2, otherLine.angle );\n        var arc = new GeoArc( midpoint, otherLine.length/2, 0, 360 );    \n        var extendedAxis = new GeoLine( intersectionPoint, intersectionPoint.pointAtDistanceAndAngleRad( otherLine.length*2, axisLine.angle ) );\n        this.p = extendedAxis.intersectArc( arc );\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, drawOptions ) {\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + \" Point along \" + this.refOf( this.p1Line1 )\n                + \"-\" + this.refOf( this.p2Line1 )\n                + \" that forms a right angle triangle with line  \" + this.refOf( this.firstPoint )\n                + \"-\" + this.refOf( this.secondPoint );\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.p1Line1 );\n        dependencies.add( this, this.p2Line1 );\n    }    \n\n}\n","class PointShoulder extends DrawingObject {\n\n    //pShoulder\n    //p1Line1\n    //p2Line1\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.shoulderPoint === \"undefined\")\n            this.shoulderPoint = this.patternPiece.getObject(d.shoulderPoint);\n\n        if (typeof this.p1Line1 === \"undefined\")\n            this.p1Line1 = this.patternPiece.getObject(d.p1Line1);\n\n        if (typeof this.p2Line1 === \"undefined\")\n            this.p2Line1 = this.patternPiece.getObject(d.p2Line1);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n\n        //Find the point that is length away from the shoulderPoint along\n        //the line p1Line1-p2line1.\n            \n        var axisLine = new GeoLine( this.p1Line1.p, this.p2Line1.p );    \n        var arc = new GeoArc( this.shoulderPoint.p, this.length.value(), 0, 360  );      \n        var offset = new GeoLine( this.shoulderPoint.p, this.p1Line1.p );\n        var extendedAxisLength = this.length.value() + offset.length;\n        var extendedAxis = new GeoLine( this.p1Line1.p, this.p1Line1.p.pointAtDistanceAndAngleRad( extendedAxisLength, axisLine.angle ) );\n\n        try {\n            this.p = extendedAxis.intersectArc( arc );\n        } catch (e) {\n            //Maybe the axisLine is going in the wrong direction, and therefore extending it's length didn't help.\n            //Try reversing axisLine...\n            var axisLine = new GeoLine( this.p2Line1.p, this.p1Line1.p );    \n            var arc = new GeoArc( this.shoulderPoint.p, this.length.value(), 0, 360  );      \n            var offset = new GeoLine( this.shoulderPoint.p, this.p2Line1.p );\n            var extendedAxisLength = this.length.value() + offset.length;\n            var extendedAxis = new GeoLine( this.p2Line1.p, this.p2Line1.p.pointAtDistanceAndAngleRad( extendedAxisLength, axisLine.angle ) );\n            this.p = extendedAxis.intersectArc( arc );    \n        }\n\n        this.line = new GeoLine( this.shoulderPoint.p, this.p );\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, drawOptions ) {\n        this.drawLine( g, drawOptions );\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n            + \" Point along \" + this.refOf( this.p1Line1 ) \n            + \"-\" + this.refOf( this.p2Line1 )\n            + \" being \" + this.length.htmlLength( asFormula ) \n            + \" from \" + this.refOf( this.shoulderPoint );\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.shoulderPoint );\n        dependencies.add( this, this.p1Line1 );\n        dependencies.add( this, this.p2Line1 );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","class PointSingle extends DrawingObject {\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n        this.p = new GeoPoint(d.x, d.y);\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, drawOptions ) {\n        this.drawDot(g, drawOptions );\n        this.drawLabel(g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>:' \n            + \" point at x:\" + this.data.x + \", y:\" + this.data.y + \" from origin\"; //TODO add units\n    }\n\n\n    setDependencies( dependencies ) {\n    }    \n\n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass SplinePathInteractive extends DrawingObject {\n\n    constructor(data) {\n        super(data);\n\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = this.data.derivedName;        \n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if ( typeof this.nodes === \"undefined\" )\n        {\n            this.nodes = [];\n            for( var i=0; i< d.pathNode.length; i++ )\n            {\n                var pathNode = this.data.pathNode[i];\n\n                pathNode.point   = this.patternPiece.getObject( pathNode.point );\n                pathNode.angle1  = this.patternPiece.newFormula( pathNode.angle1 ); \n                pathNode.length1 = this.patternPiece.newFormula( pathNode.length1 ); \n                pathNode.angle2  = this.patternPiece.newFormula( pathNode.angle2 ); \n                pathNode.length2 = this.patternPiece.newFormula( pathNode.length2 );\n\n                this.nodes.push( { inAngle:   pathNode.angle1.value(),\n                                    inLength:  pathNode.length1.value(),\n                                    point:     pathNode.point.p,\n                                    outAngle:  pathNode.angle2.value(),\n                                    outLength: pathNode.length2.value() } );\n            }\n        }\n\n        this.curve = new GeoSpline( this.nodes );\n\n        this.midPoint = this.curve.pointAlongPathFraction( 0.5 );        \n        this.p = this.midPoint;\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust( this.p );\n        this.curve.adjustBounds( bounds );\n    }\n\n    \n    asShapeInfo()\n    {\n        return this.curve.asShapeInfo();\n    }\n\n\n    draw( g, drawOptions ) {\n\n        this.drawCurve(g, drawOptions );\n\n        //Where should we draw the label? half way along the curve? \n        this.drawLabel(g, drawOptions );\n    }\n\n\n    pointAlongPath( length ) {\n        return this.curve.pointAlongPath( length );\n    }   \n\n\n    html( asFormula ) {\n        var html = '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                    +'curved path:';\n\n        var d = this.data;\n\n        html += \"<table><tbody>\";\n        for( var i=0; i< d.pathNode.length; i++ )\n        {\n            html += \"<tr><td>\";\n            html += this.refOf( d.pathNode[i].point );\n            html += \"</td>\";\n\n            if ( i == 0 )\n                html += \"<td></td><td></td>\";\n            else\n                html +=    \"<td>\" + d.pathNode[i].angle1.htmlAngle( asFormula ) \n                        + \"</td><td>\" + d.pathNode[i].length1.htmlLength( asFormula ) + \"</td>\";\n\n            if ( i == (d.pathNode.length -1) )\n                html += \"<td></td><td></td>\";\n            else\n                html +=    \" <td>\" + d.pathNode[i].angle2.htmlAngle( asFormula ) \n                        + \"</td><td>\" + d.pathNode[i].length2.htmlLength( asFormula ) + \"</td>\";\n\n            html += \"</tr>\";         \n        }\n        html += \"</tbody></table>\";\n        return html;\n    }\n\n    \n    setDependencies( dependencies )\n    {\n        for( var i=0; i< this.data.pathNode.length; i++ )\n        {\n            var pathNode = this.data.pathNode[i];\n            dependencies.add( this, pathNode.point );\n            dependencies.add( this, pathNode.angle1 );\n            dependencies.add( this, pathNode.angle2 );\n            dependencies.add( this, pathNode.length1 );\n            dependencies.add( this, pathNode.length2 );\n        }        \n    }    \n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass SplinePathUsingPoints extends DrawingObject {\n\n    constructor(data) {\n        super(data);\n\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = this.data.derivedName;        \n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if ( typeof this.nodes === \"undefined\" )\n        {\n            this.nodes = [];\n\n            for( var i=0; i< d.pathNode.length; i++ )\n            {\n                this.data.pathNode[i].point = this.patternPiece.getObject( this.data.pathNode[i].point );\n            }\n\n            for( var i=0; i< d.pathNode.length; i+=3 )\n            {\n                this.nodes.push( { \n                                   inControlPoint:   (i-1)>0 ? this.data.pathNode[i-1].point.p : undefined,\n                                   point:            this.data.pathNode[i].point.p,\n                                   outControlPoint:  (i+1) < this.data.pathNode.length ? this.data.pathNode[i+1].point.p : undefined,\n                                   } );\n            }\n        }\n\n        this.curve = new GeoSpline( this.nodes );\n\n        this.midPoint = this.curve.pointAlongPathFraction( 0.5 );        \n        this.p = this.midPoint;\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust( this.p );\n\n        //Bounds will already have been adjusted for each node\n    }\n\n    \n    asShapeInfo()\n    {\n        return this.curve.asShapeInfo();\n    }\n\n\n    draw( g, drawOptions ) {\n        if ( this.lineVisible() )\n            this.drawPath( g, this.curve.svgPath(), drawOptions );\n\n        //Where should we draw the label? half way along the curve? \n        this.drawLabel( g, drawOptions );\n    }\n\n\n    pointAlongPath( length ) {\n        return this.curve.pointAlongPath( length );\n    }   \n\n\n    html( asFormula ) {\n        var html = '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'curved path: ';\n\n        var d = this.data;\n\n        html += \"<table><tbody>\";\n\n        for( var i=0; i< d.pathNode.length; i+=3 )\n        {\n            html += \"<tr><td>\";\n\n            if ( (i-1)>0 )\n                html += this.refOf( this.data.pathNode[i-1].point );\n\n            html += \"</td><td>\";\n\n            html += this.refOf( d.pathNode[i].point );\n\n            html += \"</td><td>\";\n\n            if ( (i+1) < this.data.pathNode.length )\n                html += this.refOf(  this.data.pathNode[i+1].point );\n\n            html += \"</td></tr>\";                \n        }\n\n        html += \"</tbody></table>\";\n\n        return html;\n    }\n\n    \n    setDependencies( dependencies )\n    {\n        for( var i=0; i< this.data.pathNode.length; i++ )\n        {\n            dependencies.add( this, this.data.pathNode[i].point );\n        }        \n    }    \n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass SplineSimple extends DrawingObject {\n\n    //startPoint - the spline start\n    //endPoint - the spline end\n    //angle1\n    //angle2 \n    //length1\n    //length2\n\n    constructor(data) {\n        super(data);\n\n        //TODO output a useful spline ID\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = this.data.derivedName;        \n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.startPoint === \"undefined\")\n            this.startPoint = this.patternPiece.getObject(d.point1);\n\n        if (typeof this.endPoint === \"undefined\")\n            this.endPoint = this.patternPiece.getObject(d.point4);\n\n        if (typeof this.angle1 === \"undefined\")\n            this.angle1 = this.patternPiece.newFormula(d.angle1);\n\n        if (typeof this.angle2 === \"undefined\")\n            this.angle2 = this.patternPiece.newFormula(d.angle2);\n\n        if (typeof this.length1 === \"undefined\")\n            this.length1 = this.patternPiece.newFormula(d.length1);\n\n        if (typeof this.length2 === \"undefined\")\n            this.length2 = this.patternPiece.newFormula(d.length2);\n\n        this.curve = new GeoSpline( [ { inAngle: undefined, inLength: undefined, point: this.startPoint.p, outAngle: this.angle1.value(), outLength: this.length1.value() },\n                                       { inAngle: this.angle2.value(), inLength: this.length2.value(), point: this.endPoint.p, outAngle: undefined, outLength: undefined } ] );\n\n        this.midPoint = this.curve.pointAlongPathFraction( 0.5 );        \n        this.p = this.midPoint;\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        this.curve.adjustBounds( bounds );\n    }\n\n    \n    asShapeInfo()\n    {\n        return this.curve.asShapeInfo();\n    }\n\n\n    draw( g, drawOptions ) {\n        \n        if ( this.lineVisible() )\n            this.drawPath( g, this.curve.svgPath(), drawOptions );\n\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    pointAlongPath( length ) {\n        return this.curve.pointAlongPath( length );\n    }   \n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'spline from ' + this.refOf( this.startPoint ) \n                + \" angle \" + this.angle1.htmlAngle( asFormula ) \n                + \" length \" + this.length1.htmlLength( asFormula )\n            + \" to \" + this.refOf( this.endPoint ) \n            + \" angle \" + this.angle2.htmlAngle( asFormula ) \n            + \" length \" + this.length2.htmlLength( asFormula );\n    }\n\n    \n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.startPoint );\n        dependencies.add( this, this.endPoint );\n        dependencies.add( this, this.angle1 );\n        dependencies.add( this, this.angle2 );\n        dependencies.add( this, this.length1 );\n        dependencies.add( this, this.length2 );\n    }    \n}\n","class SplineUsingControlPoints extends DrawingObject {\n\n    //startPoint - the spline start\n    //startControlPoint\n    //endPoint - the spline end\n    //endControlPoint\n\n    constructor(data) {\n        super(data);\n\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = this.data.derivedName;        \n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.startPoint === \"undefined\")\n            this.startPoint = this.patternPiece.getObject(d.point1);\n\n        if (typeof this.startControlPoint === \"undefined\")\n            this.startControlPoint = this.patternPiece.getObject(d.point2);\n\n        if (typeof this.endControlPoint === \"undefined\")\n            this.endControlPoint = this.patternPiece.getObject(d.point3);\n\n        if (typeof this.endPoint === \"undefined\")\n            this.endPoint = this.patternPiece.getObject(d.point4);\n\n        this.curve = new GeoSpline( [ { point: this.startPoint.p, outControlPoint: this.startControlPoint.p },\n                                      { inControlPoint: this.endControlPoint.p,  point: this.endPoint.p } ] );\n\n        this.midPoint = this.curve.pointAlongPathFraction( 0.5 );        \n        this.p = this.midPoint;\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        this.curve.adjustBounds( bounds );\n    }\n\n    \n    asShapeInfo() {\n        return this.curve.asShapeInfo();\n    }\n\n\n    draw( g, drawOptions ) {\n\n        if ( this.lineVisible() )\n            this.drawPath( g, this.curve.svgPath(), drawOptions );\n\n        //Where should we draw the label? half way along the curve?\n        //this.drawDot(g, drawOptions);\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    pointAlongPath( length ) {\n        return this.curve.pointAlongPath( length );\n    }   \n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n            + 'spline from ' + this.refOf( this.startPoint )\n            + \" using control point \" + this.refOf( this.startControlPoint )\n            + \" to \" + this.refOf( this.endPoint )\n            + \" using control point \" + this.refOf( this.endControlPoint );\n    }\n\n    \n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.startPoint );\n        dependencies.add( this, this.startControlPoint );\n        dependencies.add( this, this.endPoint );\n        dependencies.add( this, this.endControlPoint );\n    }    \n}\n","class TrueDart extends DrawingObject {\n\n    //p1Line1  2 points making up the line on which the dart sits. \n    //p2Line1\n    //point1 3 points that make up a V shape of the original dart, point1 and point3 lie on the baseline\n    //point2\n    //point3\n\n    constructor(data) {\n        super(data);\n        this.data.name = data.operationName;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.point1 === \"undefined\")\n            this.point1 = this.patternPiece.getObject(d.point1);\n        if (typeof this.point2 === \"undefined\")\n            this.point2 = this.patternPiece.getObject(d.point2);\n        if (typeof this.point3 === \"undefined\")\n            this.point3 = this.patternPiece.getObject(d.point3);\n\n        if (typeof this.p1Line1 === \"undefined\")\n            this.p1Line1 = this.patternPiece.getObject(d.p1Line1);\n        if (typeof this.p2Line1 === \"undefined\")\n            this.p2Line1 = this.patternPiece.getObject(d.p2Line1);\n\n        //var lineD2A1 = new GeoLine( this.point2.p, this.p1Line1.p );\n        //var lineD2A2 = new GeoLine( this.point2.p, this.p2Line1.p );\n\n        var lineD2D1 = new GeoLine( this.point2.p, this.point1.p ); \n        var lineD2D3 = new GeoLine( this.point2.p, this.point3.p );    \n\n        var angleD2D1 = lineD2D1.angleDeg();\n        var angleD2D3 = lineD2D3.angleDeg();\n\n        var totalDartAngle = angleD2D1 - angleD2D3;\n\n        //edge case:\n        //if D2D1 angle is 10 and D2D3 is 350 (or vice versa) then it would be better to consider D2D3 to be -10. \n        if ( totalDartAngle > 180 )\n        {\n            angleD2D1 -= 360;\n            totalDartAngle = angleD2D1 - angleD2D3;\n        }\n        else if ( totalDartAngle < -180 ) \n        {\n            angleD2D3 -= 360;\n            totalDartAngle = angleD2D1 - angleD2D3;\n        }\n\n        var halfDartAngle = totalDartAngle /2;\n\n        var pointA1rotated = this.p1Line1.p.rotate( this.point2.p, -halfDartAngle );\n        var pointD1rotated = this.point1.p.rotate( this.point2.p, -halfDartAngle );\n        var pointA2rotated = this.p2Line1.p.rotate( this.point2.p, halfDartAngle );\n        var pointD2rotated = this.point3.p.rotate( this.point2.p, halfDartAngle );\n\n        var lineA1RA2R = new GeoLine( pointA1rotated, pointA2rotated );\n        this.line = lineA1RA2R; //TEMP\n        var pointClosure = lineA1RA2R.intersect( new GeoLine( this.point2.p, pointD1rotated ) ); //could equally use pointD2rotated\n        this.p = pointClosure; //TEMP\n\n        this.td1 = pointClosure.rotate( this.point2.p, halfDartAngle );\n        this.td3 = pointClosure.rotate( this.point2.p, -halfDartAngle );\n\n        //Only works where D2 is perpendicular to the midpoint of D1D3\n        //var angleA1D2D1 = lineD2A1.angleRad() - lineD2D1.angleRad();\n        //var lengthD2TD1 = Math.cos( angleA1D2D1 ) * lineD2A1.length;\n        //this.td1 = this.point2.p.pointAtDistanceAndAngleRad( lengthD2TD1, lineD2D1.angleRad() );    \n        //var angleA1D2D3 = lineD2D3.angleRad() - lineD2A2.angleRad();\n        //var lengthD2TD3 = Math.cos( angleA1D2D3 ) * lineD2A2.length;\n        //this.td3 = this.point2.p.pointAtDistanceAndAngleRad( lengthD2TD3, lineD2D3.angleRad() );\n\n        //Nb. this.data.trueDartResult1 and trueDartResult2 give the names of the dart points generated.\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.td1);\n        bounds.adjust(this.td3);\n    }\n\n\n    draw( g, drawOptions ) {\n        this.drawLine( g, drawOptions ); //TEMP - though actually handy\n        this.drawDot( g, drawOptions ); //TEMP\n        this.drawLabel( g, drawOptions ); //TEMP\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + \" True darts baseline \" + this.refOf( this.p1Line1 )\n                + \"-\" + this.refOf( this.p2Line1 )\n                + \" original dart \" + this.refOf( this.point1 )\n                + \"-\" + this.refOf( this.point2 )\n                + \"-\" + this.refOf( this.point3 );\n    }\n\n\n    setDependencies( dependencies )\n    {\n        //TODO these could get captured automaticallly if, in calculate, we did getObjectAndSetDependency( blah, this )\n        dependencies.add( this, this.point1 );\n        dependencies.add( this, this.point2 );\n        dependencies.add( this, this.point3 );\n        dependencies.add( this, this.p1Line1 );\n        dependencies.add( this, this.p2Line1 );\n    }    \n\n}\n","class TrueDartResult extends DrawingObject {\n\n    //fromOperation\n\n    constructor(data) {\n        super(data);\n        this.name = this.data.name;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.fromOperation === \"undefined\")\n            this.fromOperation = this.patternPiece.getObject(d.fromOperation);\n\n        if ( this.name === this.fromOperation.data.trueDartResult1 )\n            this.p = this.fromOperation.td1;\n        else\n            this.p = this.fromOperation.td3;\n\n            /*\n        //if this.basePoint is a point... (if a curve, this is the midpoint)\n        if ( this.basePoint.p )\n            this.p = this.fromOperation.applyOperationToPoint( this.basePoint.p );\n\n        var operation = this.fromOperation;\n        var applyOperationToPointFunc = function( p ) {\n            return operation.applyOperationToPoint( p );\n        };\n\n        //else if this.basePoint.curve is a GeoSpline...\n        if ( this.basePoint.curve instanceof GeoSpline )\n        {\n            //so we get this captured and can just pass the function around\n            this.curve = this.basePoint.curve.applyOperation( applyOperationToPointFunc );\n        }\n        else if ( this.basePoint.line instanceof GeoLine ) //untested?\n        {\n            this.line = this.basePoint.line.applyOperation( applyOperationToPointFunc );\n        }\n        //TODO we might also have operated on an arc, circle, ellipse? Some might required a different approach that needs to be aligned with original behaviour\n\n        //This line would be useful if the operation, or operation result is selected. \n        //this.operationLine = new GeoLine(this.basePoint.p, this.p);\n        */\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust( this.p );\n    }\n\n\n    getColor() {\n        return this.basePoint.getColor();\n    }\n\n    \n    getLineStyle() {\n        return this.basePoint.getLineStyle();\n    }\n\n\n    draw( g, drawOptions ) {\n\n        if ( this.p )\n            this.drawDot( g, drawOptions );\n\n        //if ( this.line )\n        //    this.drawLine( g, drawOptions ); \n            \n        if ( this.p )\n            this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'Dart point from ' + this.refOf( this.fromOperation );\n    }\n\n\n    setDependencies( dependencies ) {\n        //dependencies.add( this, this.basePoint );\n\n        //TODO add a dependency on D1/D3 depeending on\n        dependencies.add( this, this.fromOperation );\n    }    \n\n}\n","//(c) Copyright 2019 Jason Dore\n//https://github.com/MrDoo71/PatternEditor\n\nclass Pattern {\n\n    constructor (data, options ) {\n        this.data = data;\n        this.options = options;\n        this.patternData = data.pattern;\n        this.variable = {};\n        this.measurement = {};\n        this.units = this.patternData.units ? this.patternData.units : \"cm\";\n        this.wallpapers = data.wallpaper;\n        this.patternNumberAndName = ( this.patternData.patternNumber ? this.patternData.patternNumber + \" \": \"\" ) + this.patternData.name;\n        this.bounds = new Bounds();\n        this.visibleBounds = new Bounds();\n\n        if ( typeof this.patternData.measurement !== \"undefined\" )\n        {\n            for (var a = 0; a < this.patternData.measurement.length; a++) {\n                var m = this.patternData.measurement[a];\n                var measurementUnits = this.units;\n\n                //TODO test this variable that is a simple value...            \n                if (typeof m.value !== \"undefined\") \n                {\n                    m.constant = m.value;\n                    m.value = function () {\n                        return this.constant; \n                    };\n                    m.html = function() {\n                        return this.name + \": \" + this.constant + \" \" + this.units;\n                    };                    \n                }\n                else\n                {\n                    m.expression = new Expression( m.expression, this, null );\n                    m.value = function () {\n                        return this.expression.value(); \n                    };\n                    m.html = function(asFormula) {\n                        return this.name + \": \" + this.expression.html( asFormula );\n                    };\n                }\n                this.measurement[ m.name ] = m;\n                m.isMeasurement = true;\n            }\n        }        \n        \n        if ( typeof this.patternData.variable !== \"undefined\" )\n        {\n            //Register all variable before calculating their values in to deal with dependencies.\n            for (var a = 0; a < this.patternData.variable.length; a++) {\n                var v = this.patternData.variable[a];\n                this.variable[ v.name ] = v;\n                v.isVariable = true;\n            }\n\n            //Now the variable are all registered, calculate their values.\n            for (var a = 0; a < this.patternData.variable.length; a++) { \n                var inc = this.patternData.variable[a];   \n                //TODO test this variable that is a simple value...            \n                if (typeof inc.constant !== \"undefined\") \n                {\n                    inc.value = function () {\n                        return this.constant;\n                    };\n                    inc.html = function() {\n                        return this.name + \": \" + this.constant + ( this.isOverridden ? \" (custom)\" : \"\" ) \n                    };\n                }\n                else\n                {\n                    inc.expression = new Expression( inc.expression, this, null );\n                    inc.value = function () {\n                        return this.expression.value();\n                    };\n                    inc.html = function(asFormula) {\n                        return this.name + \": \" + this.expression.html( asFormula ) + \" = \" + Number.parseFloat( this.value() ).toPrecision(4) ;\n                    };\n                }\n            }\n        }        \n\n        this.patternPieces = [];\n        for( var i=0; i<this.patternData.patternPiece.length; i++ )\n        {\n            this.patternPieces.push( new PatternDrawing( this.patternData.patternPiece[i], this ) );\n        }   \n\n        this.analyseDependencies();\n    }\n\n\n    //Return the pattern local equivalent of this number of mm\n    getPatternEquivalentOfMM( mm )\n    {\n        return this.units === \"mm\" ? mm \n                                   : this.units === \"cm\" ? mm/10 \n                                                         : mm/25.4;\n    }\n\n\n    analyseDependencies() {\n        //Now build up dependency links\n        this.dependencies = { \n            dependencies: [], \n            add: function ( source, target ) { \n\n                if (( ! source ) || ( ! target ))\n                    return;\n\n                if (   ( target && typeof target.expression === \"object\" )\n                    && ( ! target.isMeasurement )\n                    && ( ! target.isVariable ) )\n                {\n                    if ( target.expression.addDependencies )\n                        target.expression.addDependencies( source, this );\n                    else\n                        console.log(\"Failed to add dependency for expression. Presumably due to earlier errors. \"); //nb. the expression is likely the original data, not our expression object\n                }\n                else if (   ( target instanceof DrawingObject )\n                         || ( target.isMeasurement )\n                         || ( target.isIncrement ) \n                         || ( target.isVariable ) \n                         )\n                    this.dependencies.push( { source: source, target: target } ); \n            }  \n        };\n        \n        if ( this.variable )\n        {\n            for( var i in this.variable )\n            {\n                var v = this.variable[i];\n                if ( v.expression ) \n                    v.expression.addDependencies( v, this.dependencies );\n            }\n        }    \n    \n        for( var j=0; j< this.patternPieces.length; j++ )\n        {\n            var piece = this.patternPieces[j];\n            for (var a = 0; a < piece.drawingObjects.length; a++) \n            {\n                var dObj = piece.drawingObjects[a];\n                dObj.setDependencies( this.dependencies );\n            }\n        }\n        //TODO use a d3.map of a d3.set when we build up the data and then convert it to an array\n        //so that we can remove duplicates.\n    }\n\n\n    getVariable(name) {\n        if (typeof name === \"object\")\n            return name;\n        return this.variable[name];\n    }\n\n    getMeasurement(name) {\n        if (typeof name === \"object\")\n            return name;\n        var m = this.measurement[name];\n\n        if ( !m )\n            throw \"Measurment not found:\" + name;\n\n        return m;\n    }\n\n    getObject( name )\n    {\n        for( var j=0; j< this.patternPieces.length; j++ )\n        {\n            var piece = this.patternPieces[j];\n            var obj = piece.getObject( name, true /*restrict search to this piece*/ );\n            if ( obj )\n                return obj;\n        }\n        return null;\n    }\n\n\n    getDate() {\n        const t = new Date();\n        const date = ('0' + t.getDate()).slice(-2);\n        const month = ('0' + (t.getMonth() + 1)).slice(-2);\n        const year = t.getFullYear();\n        return `${year}-${month}-${date}`;\n    }\n}","//(c) Copyright 2023 Jason Dore\n//https://github.com/MrDoo71/PatternEditor\n\nclass Group {\n\n    constructor (data, patternPiece) {\n        this.data = data;\n        this.patternPiece = patternPiece;\n        this.name = data.name;\n        this.visible = data.visible;\n        this.update = data.update;\n        this.contextMenu = data.contextMenu;\n        this.members = [];\n\n        if ( this.data.member )\n            this.data.member.forEach( function(m){\n                var dObj = this.patternPiece.getObject( m, true );\n                if ( dObj )\n                {\n                    this.members.push( dObj );\n                    dObj.setIsMemberOfGroup( this );\n                }     \n            },this);\n    }\n}","//(c) Copyright 2023 Jason Dore\n//https://github.com/MrDoo71/PatternEditor\n\nclass Piece {\n\n    constructor (data, patternPiece) {\n        this.data = data;\n        this.patternPiece = patternPiece;\n        this.name = data.name;\n        this.detailNodes = data.detailNode;\n        this.internalPaths = data.internalPath;\n        this.dataPanels = data.dataPanel;\n        //this.update = data.update;\n        //this.contextMenu = data.contextMenu;\n        this.nodesByName = {};\n        this.calculated = false;\n\n        if (( ! this.detailNodes ) || ( this.detailNodes.length === 0))\n        {\n            console.log(\"Piece \" + this.name + \" has no nodes.\" );\n            return;\n        }\n\n        this.detailNodes.forEach( \n            function(n) { \n                var dObj =  this.patternPiece.getObject( n.obj, true );//this.drawing[ n.obj ]; \n                if ( dObj ) \n                {\n                    this.nodesByName[ n.obj ] = n;\n                    n.dObj = dObj;\n                    if ( ! n.reverse )\n                        n.reverse = false;\n                }\n                else\n                {\n                    console.log(\"Couldn't match piece node to drawing object: \", n.obj );\n                }\n\n                //TODO also populate dObj.usedByPieces\n                //dObj.setUsedByPiece( this );\n            }, this ); \n\n        var resolve = function( objName, b ) {\n            return patternPiece.getObject( objName, b );\n        };\n\n        if ( this.internalPaths )\n            this.internalPaths.forEach( \n                function(ip) { \n\n                    if ( ! ip.node )\n                        return; \n\n                    ip.nodes = [];\n                    ip.node.forEach(\n                        function(n) {\n                            var dObj = resolve( n, true );\n                            if ( dObj ) \n                                this.nodes.push( dObj );\n                            else\n                                console.log(\"Couldn't match internal path node to drawing object: \", n );\n                        }, ip );\n                }, this );             \n                \n        if ( this.dataPanels )\n            for( var i in this.dataPanels )\n            {\n                var panel = this.dataPanels[i];\n                if ( panel.center ) \n                    panel.center = resolve( panel.center, true );\n                if ( panel.topLeft ) \n                    panel.topLeft = resolve( panel.topLeft, true );\n                if ( panel.bottomRight ) \n                    panel.bottomRight = resolve( panel.bottomRight, true );\n                if ( panel.orientation === undefined )\n                    panel.orientation = \"\";\n                if ( panel.quantity === undefined )\n                    panel.quantity = \"\";\n                if ( panel.annotation === undefined )\n                    panel.quantity = \"\";\n                if ( panel.onFold === undefined )\n                    panel.onFold = false;\n                if ( panel.foldPosition === undefined )\n                    panel.foldPosition = \"\";\n            }\n\n        this.defaultSeamAllowance = this.patternPiece.newFormula( data.seamAllowanceWidth );\n        if ( typeof this.defaultSeamAllowance === \"object\" )\n            this.defaultSeamAllowance = this.defaultSeamAllowance.value();\n\n        //this.calculate();\n\n        if ( this.name === this.patternPiece.pattern.data.options.targetPiece )\n        {\n            this.patternPiece.pattern.data.options.targetPiece = this;\n            //this.highlight = true;\n        }\n    }\n\n\n    calculate()\n    {\n        this.calculated = true;\n        console.log(\"*********\");\n        console.log(\"Prepare piece: \" + this.name );\n        var nObj;\n        var previousP; //not adjusted for seam allowance\n        var previousDirectionDeg; //same for SA and not SA        \n\n        console.log(\"Pass 1 - direction and skipped nodes\" );\n        //Initial preparation, cut up any curves at notches, reverse curves if necessary, work out\n        //which points don't lead to any progress around the curve. \n        for (var a = 0; a < this.detailNodes.length+1; a++)   //+1 because we circle right around to the start\n        {  \n            var n = this.detailNodes[ ( a == this.detailNodes.length ) ? 0 : a ]; //circle back to the first object at the end. \n            var pn = this.detailNodes[ a-1 < 0 ? a-1+this.detailNodes.length : a-1 ]; \n            var nn = this.detailNodes[ a+1 >= this.detailNodes.length ? a+1-this.detailNodes.length : a+1 ];\n            var dObj = n.dObj;\n            var nObj = nn.dObj;\n\n            //A point can specify before and after SA. The point will have a line drawn to it from the previous position.\n            //This line should have a sa of n.before. \n\n            if ( ! (( dObj.curve instanceof GeoSpline ) || ( dObj.arc instanceof GeoArc )) )\n            {\n                if ( typeof n.before !== \"undefined\" )\n                    n.sa1 = 1.0 * n.before; //TODO formulas?\n                else \n                    n.sa1 = this.defaultSeamAllowance;\n\n                if ( typeof n.after !== \"undefined\" ) //string\n                    n.sa2 = 1.0 * n.after; //TODO formulas?\n                else\n                    n.sa2 = this.defaultSeamAllowance;\n            }\n         \n            //if ( a == this.detailNodes.length )\n            //    console.log(\"Closing path\");\n\n            if ( a === 0 ) //Note if first node is curve, then it could be done at the start. \n            {\n                if ( dObj.curve instanceof GeoSpline )\n                    previousP = dObj.curve.pointAlongPathFraction(100); //this wouldn't be correct if the curve needed splitting, i.e. if this is a node on a curve\n                else\n                    previousP = dObj.p;\n\n                console.log( \"Start at \" + n.obj + \" delay drawing starting at \" + previousP.toString() );\n            }\n            else \n            {                \n                if (    ( dObj.curve instanceof GeoSpline ) \n                     || ( dObj.arc instanceof GeoArc )\n                     || ( dObj.arc instanceof GeoEllipticalArc ) )\n                {\n                    console.log( \"Curve \" + n.obj + \" previous:\" + pn.obj + \" next:\" + nn.obj );\n\n                    var nObjCurveOrArc = nObj.curve instanceof GeoSpline ? nObj.curve\n                                                                         : ( nObj.arc instanceof GeoArc || nObj.arc instanceof GeoEllipticalArc ) ? nObj.arc : undefined; //instanceof GeoArc\n\n                    var nextP = nObjCurveOrArc ? nObjCurveOrArc.pointAlongPathFraction( nn.reverse?100:0 ) \n                                               : nObj.p;\n\n                    var dObjCurve = dObj.curve instanceof GeoSpline ? dObj.curve\n                                                                    : ( dObj.arc instanceof GeoArc || dObj.arc instanceof GeoEllipticalArc ) ? dObj.arc.asGeoSpline() : undefined; \n\n                    //What if previousP and/or nextP isn't on the spline? TODO allow for one of them to be, and one not to be\n                    var curveSegment;\n                    try {\n                        curveSegment = dObjCurve.splineBetweenPoints( previousP, nextP );\n                        //We found both points, and so we can work out the forward/reverse automatically\n\n                        //This would work generically for arcs and curves as curveSegment.pointAlongPathFraction(0); //and get these to be remembered\n                        var correctDirection = curveSegment.nodeData[0].point.equals( previousP );\n\n                        if ( ! correctDirection )\n                        {\n                            //maybe it doesn't match completely? \n                            //This would work generically for arcs and curves as curveSegment.pointAlongPathFraction(\n                            var lineToStart = new GeoLine( previousP, curveSegment.nodeData[0].point );\n                            var lineToEnd = new GeoLine( previousP, curveSegment.nodeData[ curveSegment.nodeData.length-1 ].point );\n                            if ( lineToStart.getLength() < lineToEnd.getLength() )\n                                correctDirection = true;\n                        }\n\n                        if ( (! correctDirection) != n.reverse )\n                            console.log(\"ERROR: Correct direction:\" + correctDirection + \" reverse?\" + n.reverse );\n\n                        if ( ! correctDirection )  //or we could use n.reverse\n                        {\n                            curveSegment = curveSegment.reverse();\n                            console.log( \"Spline reversed.\");\n                        }\n\n                        //If we find 0 or 1 points, then we have to trust the forward/reverse flag. \n\n                    } catch ( e ) {\n                        console.log( \"Piece: \" + this.name + \" previous and/or next nodes not on curve:\" + n.obj );\n                        //This is not an issue, it just means we're not clipping the start/end of the curve\n\n                        var curveSegment;\n                        \n                        if ( n.reverse )\n                            curveSegment = (new GeoSpline( [...dObjCurve.nodeData] )).reverse();\n                        else \n                            curveSegment = dObjCurve;\n\n                        //NOW INTERSECT WITH start and end separately. \n                        try {\n                            var cut = curveSegment.cutAtPoint( previousP );\n                            if ( cut && cut.afterPoint )\n                            {\n                                curveSegment = cut.afterPoint;\n                            }\n                            else \n                            {\n                                //insert an explicit point for the implicit one, otherwise we'll be confused about direction\n                                console.log(\"Adding explit node for an implict start of curve\");\n                                var curveStartPoint = curveSegment.nodeData[0].point;\n                                var line = new GeoLine( previousP, curveStartPoint );\n                                var anglePreviousPThisP = line.angleDeg();\n                                var newNode = { obj: n.obj + \"_implicit_start\",\n                                                point: curveStartPoint,\n                                                line: line,\n                                                directionBeforeDeg: anglePreviousPThisP,\n                                                directionAfterDeg: anglePreviousPThisP,\n                                                skipPoint: false, \n                                                dObj: { p: curveStartPoint }};\n                                this.detailNodes.splice( a, 0, newNode );        \n                                a++;\n                            }\n                        } catch ( e2 ) {\n                        }\n\n                        try {\n                            var cut = curveSegment.cutAtPoint( nextP );\n                            if ( cut && cut.beforePoint )\n                                curveSegment = cut.beforePoint;\n                        } catch ( e2 ) {\n                        }\n                    }\n\n                    //Note, don't skip a point just because it is co-incident with the start of a curve\n                    //because the start of a curve has its own directionBeforeDeg, and yet the point in relation\n                    //to the previous point may be a different angle. \n\n                    previousP = curveSegment.pointAlongPathFraction(1);\n                    n.directionBeforeDeg = curveSegment.entryAngleDeg();\n                    n.directionAfterDeg = curveSegment.exitAngleDeg(); //or curveSegmentToDraw?\n                    n.curveSegment = curveSegment;\n                }\n                else if ( dObj.p )\n                {\n                    console.log( \"Other node \" + n.obj + \" previous:\" + pn.obj + \" next:\" + nn.obj );\n\n                    var thisP = dObj.p;\n\n                    var line = new GeoLine( previousP, thisP );\n                    //Is this the same point\n                    var samePoint = false;                    \n                    if ( thisP.equals( previousP ) )\n                        samePoint = true;\n                    else\n                    {\n                        //we could measure the distance and say its the same point if it is very very close\n                        console.log(\"Distance from previousP to thisP \" + line.getLength() );\n                        if ( line.getLength() < 0.05 )\n                            samePoint = true;\n                    }\n\n                    if ( ( samePoint ) && ( a == this.detailNodes.length ) ) //we've cycled back to the first node. \n                    {\n                        n.point = thisP;\n                        n.line = line;\n\n                        //if ( n.directionBeforeDeg === undefined )\n                        //    n.directionBeforeDeg = n.directionAfterDeg;\n\n                        //if ( n.directionBeforeDeg === undefined )\n                            n.directionBeforeDeg = pn.directionAfterDeg;     \n                            n.directionAfterDeg = n.directionBeforeDeg;\n\n                        n.skipPoint = false; \n                    }\n                    else if ( ! samePoint ) //not the same point\n                    {\n                        console.log( \"Line to \" + n.obj );//+ \" startAt:\" + pn.obj + \" endAt:\" + nn.obj );\n                        n.point = thisP;\n                        n.line = line;\n                        var anglePreviousPThisP = (new GeoLine( previousP, thisP )).angleDeg();\n                        previousP = thisP;\n\n                        //if ( ! pn.directionAfterDeg )\n                        //    pn.directionAfterDeg = anglePreviousPThisP;\n\n                        n.directionBeforeDeg = anglePreviousPThisP;\n                        n.directionAfterDeg = anglePreviousPThisP;\n                        n.skipPoint = false; \n                    }\n                    else //same point\n                    {\n                        //A point on a spline is a way of controlling the before/after seam allowance\n                        console.log(\"Same point, no progress\");\n                        n.directionBeforeDeg = pn.directionAfterDeg;\n                        n.point = thisP; //even if skipping, we may need this for notches\n                        n.skipPoint = true; \n                    }\n                }\n                // else if ( dObj.line instanceof GeoLine )\n                // {\n                //     //TODO! this needs testing, is this even allowed? \n                //     console.log(\"Line in piece, not allowed! \" + n.obj );\n                //     n.line = dObj.line;\n                //     n.point = dObj.line.p2;\n                //     n.directionBeforeDeg = n.line.angleDeg();\n                //     n.directionAfterDeg = n.directionBeforeDeg\n                //     n.skipPoint = false; \n                // }\n\n\n                if ( pn.directionAfterDeg === undefined )\n                {\n                    pn.directionAfterDeg = n.directionBeforeDeg;\n\n                    if ( pn.directionBeforeDeg === undefined )  \n                        pn.directionBeforeDeg = pn.directionAfterDeg;                      \n                }\n\n                if ( n.skipPoint )\n                  console.log(\"Index:\" + a + \" skip\" );\n                else\n                  console.log(\"Index:\" + a + \" ends at \" + previousP.toString() + \", direction \" + Math.round(n.directionAfterDeg) );\n            }                    \n        };\n\n        console.log(\"**********************\");\n        console.log(\"Pass 2 - add seam allowance\");\n        var currentSeamAllowance = this.defaultSeamAllowance;\n        for (var a = 0; a < this.detailNodes.length; a++) {\n\n            var n = this.detailNodes[ a ];\n\n            if ( typeof n.sa1 != \"undefined\" )\n                currentSeamAllowance = n.sa1;\n\n            //console.log(\"Node \" + a + \" n.sa1:\" + n.sa1 + \" currentSeamAllowance:\" + currentSeamAllowance );                \n\n            n.tangentAfterDeg = n.directionAfterDeg + 90;\n            if ( n.tangentAfterDeg >= 360 ) //TODO >= ?\n                n.tangentAfterDeg -= 360;     \n\n            n.tangentBeforeDeg = n.directionBeforeDeg + 90;\n                if ( n.tangentBeforeDeg >= 360 ) //TODO >= ?\n                    n.tangentBeforeDeg -= 360;     \n\n            if ( n.skipPoint )\n            {\n                console.log( \"Node:\" + a + \" \" + n.obj + \" skip\");\n                n.pointEndSA = n.point.pointAtDistanceAndAngleDeg( currentSeamAllowance, n.tangentBeforeDeg );\n                if ( typeof n.sa2 !== \"undefined\" )\n                    currentSeamAllowance = n.sa2;\n                continue;\n            }\n    \n            var debugSA = \"\";\n    \n            if ( n.curveSegment )\n            {    \n\n                var parallelCurves = n.curveSegment.parallelCurve( currentSeamAllowance );\n\n                n.curveSegment = parallelCurves.baseCurve; //if we've added nodes to the curve, this would add them to the base curve too\n                n.curveSegmentSA = parallelCurves.offsetCurve;\n                if ( n.curveSegmentSA === n.curveSegment )\n                {\n                    //we copied the reference to the curve, but we'll might be meddling with the in/out points, so we need a copy\n                    n.curveSegmentSA = new GeoSpline( [...n.curveSegmentSA.nodeData]  );\n                }\n                n.pointStartSA = n.curveSegmentSA.pointAlongPathFraction(0);\n                n.pointEndSA = n.curveSegmentSA.pointAlongPathFraction(1);\n\n                debugSA = \" A:\" + n.pointStartSA.toString() + \" B:\" + n.pointStartSA.toString()                 \n            }\n            else\n            {\n                if ( currentSeamAllowance === 0 )\n                    n.pointStartSA = n.line.p1;\n                else\n                    n.pointStartSA = n.line.p1.pointAtDistanceAndAngleDeg( currentSeamAllowance, n.tangentBeforeDeg );\n\n                if ( typeof n.tangentAfterDeg !== \"undefined\" )\n                {\n                    if ( currentSeamAllowance === 0 )\n                        n.pointEndSA = n.line.p2;\n                    else\n                        n.pointEndSA = n.line.p2.pointAtDistanceAndAngleDeg( currentSeamAllowance, n.tangentAfterDeg ); //SA1 seems more compatible? \n                }\n                //Note if directionBeforeDeg==directionAfterDeg then there is effectively 1 point, and no intersection is necessary\n\n                n.lineSA = new GeoLine( n.pointStartSA, n.pointEndSA );\n\n                debugSA = \" A:\" + n.pointStartSA.toString() + \" B:\" + n.pointEndSA.toString() \n            }\n\n            console.log( \"Node:\" + a + \" \" + n.obj + \n                         \" directionBeforeDeg:\" + ( n.directionBeforeDeg === undefined ? \"undefined\" : Math.round(n.directionBeforeDeg) ) + \n                         \" directionAfterDeg:\" + ( n.directionAfterDeg === undefined ? \"undefined\" : Math.round(n.directionAfterDeg) ) +\n                         \" sa:\" + ( currentSeamAllowance ) +\n                         ( n.curveSegment ? \" curvesegment\" : n.line ? \" line\" : \" UNKNOWN\" ) + \" \" + debugSA);\n            pn = n;\n\n            if ( typeof n.sa1 === \"undefined\" )\n                n.sa1 = currentSeamAllowance;\n\n            if ( typeof n.sa2 !== \"undefined\" )\n                currentSeamAllowance = n.sa2;\n        }\n        console.log(\"**********************\");\n        console.log(\"**********************\");\n        console.log(\"Pass 3 - intersects\");\n\n        var pn = this.detailNodes[ this.detailNodes.length-1 ];\n        if ( pn.skipPoint )\n            pn = this.detailNodes[ this.detailNodes.length-2 ]; \n\n        for (var a = 0; a < this.detailNodes.length; a++) {\n\n            var n = this.detailNodes[ a ];\n            var nn = this.detailNodes[ a+1 >= this.detailNodes.length ? a+1-this.detailNodes.length : a+1 ];\n\n            if ( n.skipPoint )\n                continue;\n\n            //Now extend or trim lines and curves so that they intersect at the required points. \n            //See docs/intersectionsWithChangingSeamAllowance.svg\n\n            var sa1 = pn.sa1;\n            var sa2 = n.sa1;\n\n            var angleChange = n.directionBeforeDeg - pn.directionAfterDeg;\n            if ( angleChange < -180 )\n                angleChange += 360;\n            else if ( angleChange > 180 )\n                angleChange -= 360;\n\n            if ( Math.abs( angleChange ) > 179.99 )\n            {\n                console.log(\"Complete change of direction? n.obj:\" + n.obj + \" withPrevious:\" + pn.obj  );\n            }\n\n            if (    ( ( Math.abs( angleChange ) > 0.1 ) || ( sa2 != sa1 ) ) //must be at an angle change, or an sa change //TODO 0.01 ? \n                 && ( Math.abs( angleChange ) < 179.99 )\n                )\n            try {                \n                //Our intersect could be external, in which case it will be a small, straight extension to each existing path, OR\n                //our intersect could be internal, in which case each path needs to be shortened slightly.  It is this latter type\n                //that requires us to care about where curves intersection. \n\n                //+ve a left hand bend, the SAs collapse into each other\n                //-ve a right hand bend, the SAs need some filler \n\n                console.log(\"Need to do an intersection, n.obj:\" + n.obj + \" withPrevious:\" + pn.obj + \" directionChange:\" + angleChange + \" sa1:\" + sa1 + \" sa2:\" + sa2 ) ;\n\n\n                //matingAngle - the angle at which the change in SA perfectly tallies with the change in direction\n                var matingAngle = 0; //if sa2==sa1 then matingAngle == 0\n                \n                if (sa1 > sa2)\n                    matingAngle = Math.acos( sa2/sa1 ) * 360 / 2 / Math.PI;\n\n                if (sa2 > sa1)\n                    matingAngle = Math.acos( sa1/sa2 ) * 360 / 2 / Math.PI;\n\n                //Nb. if the smaller sa is zero, then the matingAngle is 90. \n\n                var matingAngle2 = - matingAngle; //for where angleChange < 0, i.e. right hand bend\n\n                //If moving from sa1 > sa2\n                //   then for angleChange >= matingAngle (60deg) then we just intersect the lines, neither needs extending\n                //        for matingAngle2 < angleChange < matingAngle then we need to add a bend to sa1\n                //        for angleChange <= matingAngle2 we extend both lines and intersect, or can determine the intesection point through trig.  \n                //\n                //If moving from sa1 < sa2 \n                //  then for angleChange >= matingAngle then we just intersect the lines, neither needs extending\n                //           -matingAngle < angleChange < matingAngle then we need to add a bend to sa2\n                //           angleChange <=  matingAngle we extend both lines and intersect, or can determine the intesection point through trig.  \n                //\n                //Therefore the only difference between these cases is which we add the bend to. \n\n                var trailingPath = pn.lineSA ? pn.lineSA : pn.curveSegmentSA;\n                var leadingPath = n.lineSA ? n.lineSA : n.curveSegmentSA;\n\n                if ( angleChange >= matingAngle )\n                {\n                    console.log( \"Angle change > \" + matingAngle + \" therefore just do intersects\" );\n                    //then we just intersect the lines/curves, neither needs extending, both need clipping\n                    var intersect = this.intersect( trailingPath,  leadingPath );\n                    trailingPath = this.clipEnd( trailingPath, intersect );\n                    leadingPath = this.clipStart( leadingPath, intersect );\n                    pn.pointEndSA = intersect;    \n                    n.pointStartSA = intersect;            \n                }\n                else if ( angleChange > matingAngle2 ) //&& angleChange < matingAngle (as we've just done that)\n                {\n                    console.log( \"Angle change between \" + matingAngle2 + \" and \" + matingAngle + \" need to cater for special cases\" );\n\n                    //add a bend if there is a change in sa\n                    if ( sa1 > sa2 )\n                    {\n                        //add the bend to the trailling piece, at least to the difference (sa1-sa2)\n                        if ( angleChange > 0 ) //left-hand\n                        {\n                            //add the bend, length=(sa1-sa2), and then intersect\n                            var reducedSAPoint = pn.pointEndSA.pointAtDistanceAndAngleDeg( (sa1-sa2), pn.directionAfterDeg-90 );\n                            var saChangeLine = new GeoLine( pn.pointEndSA, reducedSAPoint );\n                            var intersect = this.intersect( saChangeLine, leadingPath );\n                            leadingPath = this.clipStart( leadingPath, intersect );\n                            pn.reducedSAPoint = intersect;\n                            n.pointStartSA = intersect;\n                        }\n                        else //right-hand\n                        {\n                            //add the bend, with a calculated length and then just join to the leading piece. \n                            //a = acos( sa2/sa1 )\n                            var sa1Overlap = sa2 / Math.cos( angleChange / 360 * 2 * Math.PI );\n                            var reducedSAPoint = pn.pointEndSA.pointAtDistanceAndAngleDeg( sa1-sa1Overlap, pn.directionAfterDeg-90 );\n                            pn.reducedSAPoint = reducedSAPoint;\n                            //leadingPath - nothing to do, we'll just join with a line from reducedSAPoint to its start.\n                            //pn.pointEndSA unchanged;    \n                            //n.pointStartSA unchanged\n                        }\n                        \n                    }\n                    else if ( sa2 > sa1 )\n                    {\n                        //add the bend to the leading piece, at least (sa2-sa1)\n                        if ( angleChange > 0 ) //left hand\n                        {\n                            //use sa2-sa1 and intersect with the trailing line\n                            var increasingSAPoint = n.pointStartSA.pointAtDistanceAndAngleDeg( (sa2-sa1), n.directionBeforeDeg-90 );\n                            var saChangeLine = new GeoLine( n.pointStartSA, increasingSAPoint );\n                            var intersect = this.intersect( saChangeLine, trailingPath );\n                            trailingPath = this.clipEnd( trailingPath, intersect );\n                            pn.pointEndSA = intersect;\n                            n.increasingSAPoint = intersect;\n                            //n.pointStartSA = intersect;\n                        }\n                        else //right hand\n                        {\n                            //add a calculated length bend to the leading piece and just join the path to it. \n                            var sa2overlap = sa1 / Math.cos( angleChange / 360 * 2 * Math.PI );\n                            var increasingSAPoint = n.pointStartSA.pointAtDistanceAndAngleDeg( sa2-sa2overlap, n.directionBeforeDeg-90 );\n                            //trailingPath - nothing to do\n                            //pn.pointEndSA no change\n                            //n.pointStartSA no change\n                            n.increasingSAPoint = increasingSAPoint;\n                        }\n                    }\n                }\n                else\n                {\n                    console.log( \"Angle change less than \" + matingAngle2 + \" need to intersect extensions\" );\n\n                    //we extend both lines and intersect\n                    var trailExtensionLine = new GeoLine( pn.pointEndSA, pn.pointEndSA.pointAtDistanceAndAngleDeg( 10, pn.directionAfterDeg ) );\n                    var leadingExtensionLine = new GeoLine( n.pointStartSA.pointAtDistanceAndAngleDeg( -10, n.directionBeforeDeg ), n.pointStartSA );\n                    var intersect = trailExtensionLine.intersect( leadingExtensionLine );\n\n                    console.log( \"Intersect at \" + intersect.toString() );\n\n                    if ( trailingPath instanceof GeoSpline )\n                    {\n                        trailingPath.nodeData.push(  {  inControlPoint:   intersect,\n                                                        point:            intersect,\n                                                        outControlPoint:  undefined } );\n                        trailingPath.nodeData[ trailingPath.nodeData.length-2 ].outControlPoint = intersect;\n                    }\n                    else\n                    {\n                        trailingPath = new GeoLine( pn.pointStartSA, intersect ); //this is still just a straight line as we extended it straight\n                    }\n\n                    if ( leadingPath instanceof GeoSpline )\n                    {\n                        leadingPath.nodeData.unshift( { inControlPoint:   undefined,\n                                                        point:            intersect,\n                                                        outControlPoint:  intersect } );\n                        leadingPath.nodeData[1].inControlPoint = intersect;\n                    }\n                    else\n                    {\n                        leadingPath = new GeoLine( intersect, n.pointEndSA );                    \n                    }\n\n                    pn.pointEndSA = intersect;\n                    n.pointStartSA = intersect;\n                }        \n\n                if ( trailingPath instanceof GeoSpline )\n                    pn.curveSegmentSA = trailingPath;\n                else\n                    pn.lineSA = trailingPath;\n\n                if ( leadingPath instanceof GeoSpline )\n                    n.curveSegmentSA = leadingPath;\n                else\n                    n.lineSA = leadingPath;\n                \n\n            } catch ( e ) {\n                console.log(\"No intersect pn:\" + pn.obj + \" n:\" + n.obj );\n            } \n\n            pn = n;                     \n        }\n        console.log(\"**********************\");\n\n    }\n\n\n    intersect( trailingPath, leadingPath )\n    {\n        var trailingPathSI = trailingPath.asShapeInfo();\n        var leadingPathSI = leadingPath.asShapeInfo();        \n        var intersect;\n        try {\n            var intersections = Intersection.intersect(trailingPathSI, leadingPathSI);\n            intersect = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n\n            if ( intersections.length > 1 )\n                console.log( \"Intersections found (A). \" + intersections.length );\n\n        } catch ( e ) {\n            console.log( \"No intersections found (A). \" + pn.obj + \" and \" + n.obj );\n\n            try { \n                var intersections = Intersection.intersect( leadingPathSI, leadingPathSI );\n                intersect = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n                if ( intersections.length > 1 )\n                    console.log( \"Intersections found (B). \" + intersections.length );\n            } catch ( e ) {\n                console.log( \"No intersections found (B). \" + pn.obj + \" and \" + n.obj );\n            }\n        }\n        return intersect; //OR THROW? \n    }\n\n\n    clipEnd( trailingPath, intersect )\n    {\n        if ( trailingPath instanceof GeoSpline )\n        {\n            //TODO if cutAtPoint doesn't work we could go back to our original non-extended curve and just extend that in a straight line to our intersect point\n            return trailingPath.cutAtPoint( intersect ).beforePoint;\n        }\n        else\n        {\n            return new GeoLine( trailingPath.p1, intersect );\n        }\n    }\n\n\n    clipStart( leadingPath, intersect ) \n    {\n        if ( leadingPath instanceof GeoSpline )\n        {\n            //TODO if cutAtPoint doesn't work we could go back to our original non-extended curve and just extend that in a straight line to our intersect point\n            var split = leadingPath.cutAtPoint( intersect );\n            return split.afterPoint ? split.afterPoint : split.beforePoint;\n        }\n        else\n        {\n            return new GeoLine( intersect, leadingPath.p2 );\n        }\n    }\n\n\n    drawSeamLine( g, useExportStyles ) \n    {\n        if ( ! this.calculated )\n            this.calculate();\n\n        console.log(\"Time to draw seam line: \", this.name );\n\n        var p = g.append(\"path\")\n                 .attr(\"id\",\"seam line - \" + this.name )\n                 .attr(\"class\", \"seamline\" )\n                 .attr(\"d\", this.svgPath( false ) )\n                 .attr(\"stroke-dasharray\", \"2,0.2\" )\n                 .attr(\"stroke-width\", ( this.getStrokeWidth()/2) ); //TODO this has to be set according to scale;\n\n        if ( useExportStyles )\n            p.attr(\"fill\", \"none\" )\n             .attr(\"stroke\", \"#929292\");\n    }\n\n\n    drawSeamAllowance( g, useExportStyles ) \n    {\n        if ( ! this.calculated )\n            this.calculate();\n\n        console.log(\"Time to draw seam allowance: \", this.name );\n\n        var p = g.append(\"path\")\n                 .attr(\"id\",\"seam allowance - \" + this.name )\n                 .attr(\"class\", \"seamallowance\" )\n                 .attr(\"d\", this.svgPath( true ) )\n                 .attr(\"stroke-width\", this.getStrokeWidth() ); //TODO this has to be set according to scale\n\n        if ( useExportStyles )\n            p.attr(\"fill\", \"none\")\n             .attr(\"stroke\", \"black\");\n    } \n\n\n    drawNotches( g, useExportStyles  )\n    {\n        if ( ! this.detailNodes )\n            return;\n\n        if ( ! this.calculated )\n            this.calculate();\n\n        var notches = g.append(\"g\").attr(\"id\",\"notches\");\n        console.log(\"*********\");\n        console.log(\"notches: \" + this.name );\n\n        var pn = this.detailNodes[ this.detailNodes.length -1 ];\n\n        var strokeWidth = this.getStrokeWidth();\n\n        for (var a = 0; a < this.detailNodes.length; a++) \n        {\n            var n = this.detailNodes[ a ];\n\n            if ( typeof n.notch === \"undefined\" )\n                continue;\n\n            const notchType = n.notch;\n            const notchAngle = n.notchAngle === undefined ? 0 : n.notchAngle;\n            const notchCount = n.notchCount === undefined ? 1 : n.notchCount;\n            const notchLength = n.notchLength === undefined ? 0.25 : n.notchLength;\n            const notchWidth  = n.notchWidth === undefined ? 0.25 : n.notchWidth;      \n            const tangentDeg = n.pointEndSA ? (new GeoLine( n.point, n.pointEndSA)).angleDeg() : n.tangentAfterDeg;\n\n            //TODO if no SA, then create a point at an internal tangent\n            var path = \"\";\n\n            //One notch : 0    \n            //Two notches : -0.5 +0.5    0-1  1-1   n-(c/2)+0.5\n            //Three notches : -1 0 +1 \n            for( var i = 0;  i < notchCount; i++ )\n            {\n                const offset = i-(notchCount/2)+0.5;\n                const roundForSVG = this.roundForSVG;\n                const drawNotch = function( p ) {\n                    var start = p;\n                    if ( offset != 0 )\n                    {\n                        const offsetAmount = offset * notchWidth;\n                        start = start.pointAtDistanceAndAngleDeg( offsetAmount, tangentDeg + 90 );\n                    }\n                    var end = start.pointAtDistanceAndAngleDeg( notchLength, tangentDeg + 180 + notchAngle );\n\n                    path += \"M\" + roundForSVG( start.x ) + \",\" + roundForSVG( start.y ) + \" L\" + roundForSVG( end.x ) + \",\" + roundForSVG( end.y );\n                }\n\n                drawNotch( n.point );\n                if ( n.pointEndSA )\n                    drawNotch( n.pointEndSA );\n\n\n            }\n\n            //TODO should we connect these D3 data-wise to the notches\n            var p = notches.append(\"path\")\n                .attr(\"d\", path )\n                .attr(\"class\", \"notch\" )\n                .attr(\"stroke-width\", strokeWidth); //TODO this has to be set according to scale\n\n            if ( useExportStyles )\n                p.attr(\"fill\", \"none\")\n                    .attr(\"stroke\", \"black\");\n        };\n    }    \n\n\n    drawInternalPaths( g, useExportStyles  )\n    {\n        var internalPathsGroup = g.append(\"g\")\n                                  .attr(\"id\",\"internal paths\");        \n        var strokeWidth = Math.round( this.getStrokeWidth()/2 * 10000 )/10000;\n\n        if ( this.internalPaths )\n            this.internalPaths.forEach( \n                function(ip) { \n                    if ( ip.nodes )\n                        this.drawInternalPath( internalPathsGroup, ip, strokeWidth, useExportStyles );\n                }, this );   \n    }\n\n\n    drawInternalPath( internalPathsGroup, internalPath, strokeWidth, useExportStyles )\n    {\n        var path = undefined;\n\n        var previousP;\n        for  (var a=0; a<internalPath.nodes.length; a++ )\n        {\n            var n = internalPath.nodes[ a ];\n            \n            var curve = undefined;\n\n            if (( n.arc instanceof GeoArc ) || ( n.arc instanceof GeoEllipticalArc ))\n                curve = n.arc.asGeoSpline();\n            else if ( n.curve instanceof GeoSpline )\n                curve = n.curve;\n\n            if ( curve )\n            {\n                if ( previousP )\n                {\n                    const cut = curve.cutAtPoint( previousP );\n                    curve = cut.afterPoint ? cut.afterPoint : cut.beforePoint;\n                }\n\n                var nextNode = a+1 < internalPath.nodes.length ? internalPath.nodes[ a+1 ] : undefined;\n                if (( nextNode ) && ( nextNode.p ))\n                {\n                    const cut = curve.cutAtPoint( nextNode.p );\n                    curve = cut.beforePoint;\n                }\n\n                path = curve.svgPath( path );\n                previousP = curve.pointAlongPathFraction(1);\n            }\n            else\n            {\n                path = this.lineTo( path, n.p );\n                previousP = n.p;\n            }\n        }\n\n        var p = internalPathsGroup.append(\"path\")\n            .attr(\"d\", path )\n            .attr(\"class\", \"internalpath\" )\n            .attr(\"fill\", \"none\")\n            //.attr(\"class\", internalPath.lineStyle )\n            .attr(\"stroke-width\", strokeWidth); //TODO this has to be set according to scale\n\n        if ( useExportStyles )\n            p.attr(\"stroke\", \"black\");\n\n        if ( internalPath.lineStyle ) \n        {\n            var dasharray = undefined;\n            switch( internalPath.lineStyle )\n            {\n                case \"dotLine\":        dasharray = \"0.25 0.25\"; break;\n                case \"dashLine\":       dasharray = \"1 0.25\"; break;\n                case \"dashDotLine\":    dasharray = \"1 0.25 0.25 0.25\"; break;\n                case \"dashDotDotLine\": dasharray = \"1 0.25 0.25 0.25 0.25 0.25\"; break;\n            }\n        \n            if ( dasharray )\n                p.attr(\"stroke-dasharray\", dasharray );  \n        }\n    }\n\n\n    drawMarkings( g, useExportStyles )\n    {\n        var lineSpacing = 1.2;\n        var fontSize = this.patternPiece.pattern.getPatternEquivalentOfMM(8); //8mm equiv\n        var align = \"start\";\n\n        if ( this.dataPanels )\n        for( var i in this.dataPanels )\n        {\n            var panel = this.dataPanels[i];\n\n            if ( ! panel.dataItem )\n                continue;\n\n            var x = undefined;\n            var y = undefined;\n            if ( typeof panel.topLeft === \"object\" )\n            {\n                x = panel.topLeft.p.x;\n                y = panel.topLeft.p.y;\n            }\n            if ( typeof panel.center === \"object\" )\n            {\n                //TODO we need to center it!!\n                x = panel.center.p.x;\n                y = panel.center.p.y;\n                align = \"middle\";\n            }\n            if ( typeof panel.bottomRight === \"object\" )\n            {\n                x = panel.bottomRight.p.x;\n                y = panel.bottomRight.p.y;\n                align = \"end\";\n            }\n            if ( x === undefined ) \n            {\n                var bounds = new Bounds();\n                this.adjustBounds( bounds );\n                x = ( bounds.minX + bounds.maxX ) / 2;\n                y = ( bounds.minY + bounds.maxY ) / 2;\n                align = \"middle\";\n                y = y + (panel.dataItem.length * fontSize * lineSpacing / 2)\n            }\n\n            if ( align === \"middle\" )\n                y -= panel.dataItem.length * fontSize * lineSpacing / 2;\n            else if ( align === \"bottom\" )\n                y -= panel.dataItem.length * fontSize * lineSpacing;\n\n            var dataPanelGroup = g.append(\"text\")\n                                  .attr(\"id\",\"data panel:\" + panel.letter )\n                                  .attr(\"class\",\"patternlabel\")\n                                  .attr(\"transform\", \"translate(\" + x + \",\" + y + \")\" )\n                                  //.attr(\"text-anchor\", align ) //dominant-baseline=\"middle\"\n                                  .attr(\"font-size\", fontSize );\n\n            for( var j in panel.dataItem )\n            {\n                var dataItem = panel.dataItem[ j ];\n                var text = dataItem.text;\n\n                if ( text.includes( \"%date%\" ) )\n                    text = text.replace(\"%date%\", this.patternPiece.pattern.getDate() );\n\n                if ( text.includes( \"%pLetter%\" ) )\n                    text=text.replace( \"%pLetter%\", panel.letter );\n                \n                if ( text.includes( \"%pName%\" ) )\n                    text=text.replace( \"%pName%\", this.name );\n\n                if ( text.includes( \"%pOrientation%\" ) )\n                    text=text.replace( \"%pOrientation%\", panel.orientation );\n\n                if ( text.includes( \"%pQuantity%\" ) )\n                    text=text.replace( \"%pQuantity%\", panel.quantity );\n\n                if ( text.includes( \"%pAnnotation%\" ) )\n                    text=text.replace( \"%pAnnotation%\", panel.annotation );\n\n                if ( text.includes( \"%wOnFold%\" ) )\n                    text=text.replace( \"%wOnFold%\", panel.onFold ? \"on fold\" : \"\" );\n\n                if ( text.includes( \"%pFoldPosition%\" ) )\n                    text=text.replace( \"%pFoldPosition%\", panel.foldPosition );\n\n                if ( text.includes( \"%patternNumber%\" ) )\n                {\n                    var patternNumber = this.patternPiece.pattern.patternData.patternNumber;\n                    if ( patternNumber === undefined )\n                        patternNumber = \"\";\n                    text=text.replace( \"%patternNumber%\", patternNumber );\n                }\n\n                if ( text.includes( \"%patternName%\" ) )\n                    text=text.replace( \"%patternName%\", this.patternPiece.pattern.patternData.name );\n\n                dataPanelGroup.append(\"tspan\")\n                              .attr(\"x\", \"0\" )\n                              .attr(\"dy\", lineSpacing*fontSize )\n                              .attr(\"text-anchor\", align )\n                              //textLength - specify a size and the text will scale? \n                              //style=\"font-weight: bold;\"\n                              .text( text );\n                ;\n            }\n        }\n    }\n\n\n    convertMMtoPatternUnits( mm )\n    {\n        if ( this.patternPiece.pattern.units = \"cm\" )\n            return mm/10;\n        else if ( this.patternPiece.pattern.units = \"mm\" )\n            return mm;\n        else //inches\n            return mm/25.4;\n    }\n\n\n    getStrokeWidth( isOutline, isSelected )\n    {\n        if ( this.patternPiece.pattern.data.options.lifeSize ) \n            return this.patternPiece.pattern.getPatternEquivalentOfMM(0.4); //0.4mm equiv\n            \n        return Math.round( 1000 * ( isOutline ? 7.0 : ( isSelected ? 3.0 : 1.0 ) ) / scale / fontsSizedForScale ) /1000;\n    }\n\n\n    svgPath( withSeamAllowance )\n    {\n        if ( ! this.detailNodes )\n            return;\n\n        console.log(\"*********\");\n        console.log(\"svgPath: \" + this.name + \" seamAllowance:\" + withSeamAllowance );\n\n        var path = undefined;\n        var pn = this.detailNodes[ this.detailNodes.length -1 ];\n\n        for (var a = 0; a < this.detailNodes.length+1; a++) {  //+1 because we circle right around to the start\n\n            var n = this.detailNodes[ ( a == this.detailNodes.length ) ? 0 : a ]; //circle back to the first object at the end. \n            //var pn = this.detailNodes[ a-1 < 0 ? a-1+this.detailNodes.length : a-1 ]; \n            //var nn = this.detailNodes[ a+1 >= this.detailNodes.length ? a+1-this.detailNodes.length : a+1 ];\n         \n            if ( a == this.detailNodes.length )\n                console.log(\"Closing path\");\n\n            if ( n.skipPoint )\n                continue;\n\n            if ( withSeamAllowance )\n            {\n                if ( pn.reducedSAPoint ) //nb if !path then M rather than L as below? \n                    path = this.lineTo( path, pn.reducedSAPoint );\n\n                if ( n.increasingSAPoint ) //nb if !path then M rather than L as below? \n                    path = this.lineTo( path, n.increasingSAPoint );\n            }\n\n            if ( n.curveSegment )\n            {\n                var curveSegmentToDraw = withSeamAllowance ? n.curveSegmentSA : n.curveSegment;\n\n                path = curveSegmentToDraw.svgPath( path ) + \" \";\n            }\n            else\n            {\n                var thisP = withSeamAllowance ? n.pointEndSA : n.point;\n\n                if ( withSeamAllowance && n.pointStartSA )\n                {\n                    path = this.lineTo( path, n.pointStartSA );\n                }\n\n                path = this.lineTo( path, thisP );\n            }\n\n            pn = n;\n        };\n\n        //TODO actually close the SVG path? \n\n        console.log( \"Path: \" + path );\n\n        return path;        \n    }\n\n\n    lineTo( path, p )\n    {\n        if ( ! path )\n            path = \"M\" + this.roundForSVG( p.x ) + \",\" + this.roundForSVG( p.y ) + \" \";\n        else\n            path += \"L\" + this.roundForSVG( p.x ) + \",\" + this.roundForSVG( p.y ) + \" \";\n\n        return path;\n    }\n\n\n    adjustBounds( bounds, includeOffset )\n    {\n        if ( ! this.detailNodes )\n            return;\n\n        if ( ! this.calculated )\n            this.calculate();\n\n        var mx = includeOffset && this.data.mx ? this.data.mx : 0.0;\n        var my = includeOffset && this.data.my ? this.data.my : 0.0;\n\n        for (var a = 0; a < this.detailNodes.length; a++) {\n\n            var n = this.detailNodes[a];\n\n            if ( n.pointEndSA )\n                bounds.adjustToIncludeXY( n.pointEndSA.x + mx, n.pointEndSA.y + my );\n\n            if ( n.pointStartSA )\n                bounds.adjustToIncludeXY( n.pointStartSA.x + mx, n.pointStartSA.y + my );\n        }\n    }\n\n\n    roundForSVG( n )\n    {\n        return Math.round( n * 1000 ) / 1000;\n    }\n\n}","//(c) Copyright 2019 Jason Dore\n//https://github.com/MrDoo71/PatternEditor\n\n\n\nclass PatternDrawing {\n\n    constructor (data, pattern) {\n        this.data = data;\n        this.drawing = {};\n        this.pattern = pattern;\n\n        if (data) {\n            this.name = data.name;\n            this.drawingObjects = data.drawingObject;\n        }\n        else {\n            this.drawingObjects = [];            \n        }\n        this.bounds = new Bounds();\n        this.visibleBounds = new Bounds();\n        this.groups = [];\n        this.pieces = []; //aka details\n\n        if ( pattern ) //always true, except in some test harnesses\n        {\n            this.bounds.parent = pattern.bounds;\n            this.visibleBounds.parent = pattern.visibleBounds;\n        }\n\n        this.init();\n    }\n    \n    init() {\n        if (!this.data)\n            return;\n        //Take each drawingObject in the JSON and convert to the appropriate \n        //type of object.\n        for (var a = 0; a < this.drawingObjects.length; a++) {\n            var dObj = this.drawingObjects[a];\n            dObj = this.newDrawingObj(dObj);\n            if (dObj === null)\n                continue;\n            //    throw( \"Unknown objectType:\" + dObj.objectType );\n            this.drawingObjects[a] = dObj; //these are now the objects with methods\n\n\n            this.drawing[dObj.data.name] = dObj;\n            dObj.patternPiece = this;    \n            this.calculateObj(dObj);\n        }\n\n        //Take each group in the JSON and convert to an object. \n        //After this the isVisible() method on the drawingObject will work. \n        if ( this.data.group )\n            for (var a = 0; a < this.data.group.length; a++) {\n                this.groups[a] = new Group( this.data.group[a], this );\n            }\n        \n        if ( this.data.piece )\n            for (var a = 0; a < this.data.piece.length; a++) {\n                this.pieces[a] = new Piece( this.data.piece[a], this );\n            }\n\n        var options = this.pattern.data.options; \n        if ( options && ( typeof options.targetPiece === \"object\" ) )\n        {\n            options.targetPiece.adjustBounds( this.visibleBounds );\n        }\n        else if ( options && ( options.targetPiece === \"all\" ) ) //TODO also an array with specific multiple pieces specified\n        {\n            for (var a = 0; a < this.pieces.length; a++) {\n                this.pieces[a].adjustBounds( this.visibleBounds, true );\n            }\n        }\n        else\n        {\n            //This ensures the seam allowance is included in the bounds\n            if (( this.data.piece ) && ( ! options.skipPieces ))\n                for (var a = 0; a < this.data.piece.length; a++) {\n                    this.pieces[a].adjustBounds( this.visibleBounds  );\n                }\n\n            //Calculate the visible bounds            \n            this.drawingObjects.forEach( function(dObj){\n                if (   ( dObj.isVisible( options ) )\n                    && ( dObj.data.lineStyle !== \"none\" ) )         \n                    try {\n                        dObj.adjustBounds( this.visibleBounds );\n                    } catch ( e ) {\n                        console.log(\"Error adjusting bounds for \" + dObj.name + \" \", e );\n                    }\n            }, this) ;\n        }\n\n    }\n\n    \n    getObject(name, thisPieceOnly) {\n        if (typeof name === \"object\")\n            return name;\n\n        var objOnThisPiece = this.drawing[name];\n        if ( objOnThisPiece )\n            return objOnThisPiece;\n\n        //If we are finding a drawing object for a length etc. then we are allowed to reference other\n        //pieces.  And should ask the pattern for the object. But if we are here because we are scanning the whole pattern\n        //already then we shouldn't recurse back to the pattern.\n        if ( ! thisPieceOnly )\n            return this.pattern.getObject(name);\n    }\n\n    //TODO make this a static method of DrawingObject\n    newDrawingObj(dObj) {\n        if (dObj.objectType === \"pointSingle\")\n            return new PointSingle(dObj);\n        else if (dObj.objectType === \"pointEndLine\")\n            return new PointEndLine(dObj);\n        else if (dObj.objectType === \"pointAlongLine\")\n            return new PointAlongLine(dObj);\n        else if (dObj.objectType === \"pointAlongPerpendicular\")\n            return new PointAlongPerpendicular(dObj);\n        else if (dObj.objectType === \"pointAlongBisector\")\n            return new PointAlongBisector(dObj);            \n        else if (dObj.objectType === \"pointFromXandYOfTwoOtherPoints\")\n            return new PointFromXandYOfTwoOtherPoints(dObj);\n        else if (dObj.objectType === \"pointIntersectLineAndAxis\")\n            return new PointIntersectLineAndAxis(dObj);\n        else if (dObj.objectType === \"line\")\n            return new Line(dObj);\n        else if (dObj.objectType === \"pointLineIntersect\")\n            return new PointLineIntersect(dObj);\n        else if (dObj.objectType === \"pointIntersectArcAndAxis\")\n            return new PointIntersectArcAndAxis(dObj);\n        else if (dObj.objectType === \"pointIntersectArcAndLine\")\n            return new PointIntersectArcAndLine(dObj);\n        else if (dObj.objectType === \"perpendicularPointAlongLine\")\n            return new PerpendicularPointAlongLine(dObj);\n        else if (dObj.objectType === \"pointOfTriangle\")\n            return new PointOfTriangle(dObj);            \n        else if (dObj.objectType === \"pointShoulder\")\n            return new PointShoulder(dObj);            \n        else if (dObj.objectType === \"arcSimple\")\n            return new ArcSimple(dObj);\n        else if (dObj.objectType === \"arcElliptical\")\n            return new ArcElliptical(dObj);\n        else if (dObj.objectType === \"splineSimple\")\n            return new SplineSimple(dObj);\n        else if (dObj.objectType === \"splineUsingPoints\")\n            return new SplineUsingControlPoints(dObj);\n        else if (dObj.objectType === \"splinePathInteractive\")\n            return new SplinePathInteractive(dObj);\n        else if (dObj.objectType === \"splinePathUsingPoints\")\n            return new SplinePathUsingPoints(dObj);\n        else if (dObj.objectType === \"cutSpline\")   //SHOULD THIS BE pointCutSpline for consistency?\n            return new CutSpline(dObj);\n        else if (dObj.objectType === \"pointCutSplinePath\")\n            return new PointCutSplinePath(dObj);      \n        else if (dObj.objectType === \"pointCutArc\")\n            return new PointCutArc(dObj);                              \n        else if (dObj.objectType === \"pointIntersectCurves\")\n            return new PointIntersectCurves(dObj);      \n        else if (dObj.objectType === \"pointIntersectCurveAndAxis\")\n            return new PointIntersectCurveAndAxis(dObj);      \n        else if (dObj.objectType === \"pointIntersectArcs\")\n            return new PointIntersectArcs(dObj);      \n        else if (dObj.objectType === \"pointIntersectCircles\")\n            return new PointIntersectCircles(dObj);                  \n        else if (dObj.objectType === \"operationMove\")\n            return new OperationMove(dObj);                  \n        else if (dObj.objectType === \"operationRotate\")\n            return new OperationRotate(dObj);                  \n        else if (dObj.objectType === \"operationFlipByAxis\")\n            return new OperationFlipByAxis(dObj);                  \n        else if (dObj.objectType === \"operationFlipByLine\")\n            return new OperationFlipByLine(dObj);                  \n        else if (dObj.objectType === \"operationResult\")\n            return new OperationResult(dObj);                  \n        else if (dObj.objectType === \"pointFromArcAndTangent\")\n            return new PointFromArcAndTangent(dObj);                  \n        else if (dObj.objectType === \"pointFromCircleAndTangent\")\n            return new PointFromCircleAndTangent(dObj);                  \n        else if (dObj.objectType === \"trueDart\")\n            return new TrueDart(dObj);                              \n        else if (dObj.objectType === \"trueDartResult\")\n            return new TrueDartResult(dObj);                              \n        else \n        {\n            var fail = new PointSingle( {x:0, y:0, contextMenu:dObj.contextMenu } );\n            fail.error =  \"Unsupported drawing object type:\" + dObj.objectType;\n            return fail;\n        }\n        //throw( \"Unsupported drawing object type:\" + dObj.objectType );\n\n        return null;\n    }\n\n    newFormula(formula) {\n\n        var patternUnits = this.pattern.units;\n        var f = formula;\n        if (typeof formula.constant !== \"undefined\") {\n            f.value = function () {\n                return this.constant;\n            };\n            f.html = function() {\n                return this.constant;\n            };\n            f.htmlLength = function() {\n                var precision = patternUnits === \"mm\" ? 10.0 : 100.0;\n                var s = Math.round( precision * this.constant ) / precision;\n                return '<span class=\"const\">' + s + \" \" + patternUnits + '</span>';\n            };\n            f.htmlAngle = function() {\n                var s = Math.round( 10.0 * this.constant ) / 10.0;\n                return '<span class=\"const\">' + s + \"&#176;\" + '</span>';\n            };\n        }\n        else if (typeof formula.expression === \"object\") {\n            f.expression = new Expression( f.expression, this.pattern, this );\n            f.value = function (currentLength) {\n                return f.expression.value(currentLength);\n            };\n            f.html = function( asFormula, currentLength ) {\n                return f.expression.html( asFormula, currentLength );\n            };\n            f.htmlLength = function( asFormula, currentLength ) {\n                var s = f.expression.html( asFormula, currentLength );\n                if ( ! asFormula )\n                {\n                    var precision = patternUnits === \"mm\" ? 10.0 : 100.0;\n                    s = Math.round( precision * s ) / precision;\n                    s += \" \" + patternUnits;\n                }\n                return s;\n            };\n            f.htmlAngle = function( asFormula, currentLength ) {\n                var s = f.expression.html( asFormula, currentLength );\n                if ( ! asFormula )\n                {\n                    s = Math.round( 10.0 * s ) / 10.0;\n                    s += \"&#176;\"; //degrees\n                }\n                return s;\n            };\n        }\n        return f;\n    }\n\n    calculateObj(dObj) {\n\n        if (typeof dObj.calculate !== \"undefined\") {\n            \n            try {\n                dObj.calculate(this.bounds);\n\n            } catch (e) {\n                dObj.error = \"Calculation failed. \" + e;\n            }\n\n        }\n    }\n\n    pointSingle(data) {\n        data.objectType = \"pointSingle\";\n        var dObj = this.add( data );\n        return dObj;\n    }\n\n    add(data) {\nconsole.log(\"Add() is this used anywhere?\");\n\n        if (this.defaults) {\n            for (var d in this.defaults) {\n                if (typeof data[d] === \"undefined\")\n                    data[d] = this.defaults[d];\n            }\n        }\n        var dObj = this.newDrawingObj(data);\n        this.drawingObjects.push(dObj);\n        this.drawing[dObj.data.name] = dObj;\n        dObj.patternPiece = this;\n        this.calculateObj(dObj);\n        return dObj;\n    }\n\n    setDefaults(defaults) {\n        this.defaults = defaults;\n    }\n}\n\n","//(c) Copyright 2019-20 Jason Dore\n//\n//Inspired by the excellent Seamly2D/Valentina pattern drawing software.\n//This library is a ground up implementation in Javascript intended to be compatible with, but\n//not based on, the Seamly2D/Valentina pattern making systen in order to support the community\n//pattern sharing website https://my-pattern.cloud/ . \n//\n//Source maintained at: https://github.com/MrDoo71/PatternEditor\n\nvar selectedObject;\nvar linksGroup;\nvar fontsSizedForScale = 1;\nvar fontResizeTimer;\nvar updateServerTimer;\nvar timeOfLastTweak;\nvar doDrawingAndTable;\n\nfunction drawPattern( dataAndConfig, ptarget, graphOptions ) \n{\n    //Remove the svg if called by graph_kill\n    if ( dataAndConfig === null )\n    {\n        var parent = document.getElementById(ptarget).parentNode;\n        var child = document.getElementById(ptarget);\n        parent.removeChild(child);\n        return ;\n    } \n\n    //This is a graph initialisation\n\n    if ( ! dataAndConfig.options )\n        dataAndConfig.options = {};\n\n    var options = dataAndConfig.options;\n\n    options.interactionPrefix = graphOptions.interactionPrefix;\n\n    var targetdiv = d3.select( \"#\" + ptarget )\n                       .append( \"div\" )\n                       .attr( \"class\", \"pattern-editor\" );\n\n    var pattern;\n    try {\n        pattern = new Pattern( dataAndConfig, graphOptions );            \n    } catch ( e ) {\n        if ( ! options.thumbnail )\n            targetdiv.append(\"div\")\n                .attr( \"class\", \"alert alert-warning\" )\n                .text( \"Pattern draw failed.\");\n\n        console.log(\"Failed to load pattern: \", e );\n\n        try {\n            if (( options.returnSVG !== undefined ) && ( options.returnID ))\n            {\n                var kvpSet = newkvpSet(true);\n                kvpSet.add( 'svg', 'FAIL:' + e.message );\n                kvpSet.add( 'id', options.returnID ) ;\n                goGraph( options.interactionPrefix + ':' + options.returnSVG, fakeEvent(), kvpSet);\n            }\n        } catch ( f ) {\n        }\n        \n        return;\n    }\n        \n\n    if ( options.allowPanAndZoom === undefined )\n        options.allowPanAndZoom = true;\n\n    if ( options.showFormulas === undefined )\n        options.showFormulas = true;\n\n    if ( options.drawingTableSplit === undefined )\n        options.drawingTableSplit = 0.66;\n\n    if ( options.skipDrawing === undefined )\n        options.skipDrawing = false;\n\n    if ( options.skipPieces === undefined )\n        options.skipPieces = false;\n\n    if ( options.thumbnail === undefined )\n        options.thumbnail = false;\n\n    if ( options.interactive === undefined )\n        options.interactive = ! options.thumbnail;\n\n    if ( options.lastMixedSplit === undefined )\n        options.lastMixedSplit = options.drawingTableSplit > 0.0 && options.drawingTableSplit < 1.0 ? options.drawingTableSplit : 0.66;\n\n    if ( ! options.viewOption )\n        options.viewOption = [  { \"mode\":\"drawing\", \"icon\": \"icon-picture\",       \"drawingTableSplit\": 1.0 },\n                                { \"mode\":\"mixed\",   \"icon\": \"icon-columns\",       \"drawingTableSplit\": 0.5 },\n                                { \"mode\":\"table\",   \"icon\": \"icon-align-justify\", \"drawingTableSplit\": 0 } ];\n\n    // show menu on right-click.\n    var contextMenu = options.interactive && typeof goGraph === \"function\" ? function(d) {\n        if ( d.contextMenu )\n        {\n            d3.event.preventDefault() ;\n            var v = newkvpSet(false) ;\n            v.add(\"x\", d.x) ;   \n            v.add(\"y\", d.y) ;    \n            goGraph( graphOptions.interactionPrefix + ':' + d.contextMenu ,\n                    d3.event, \n                    v ) ;\n        }\n    } : undefined; //function(d){};     \n\n    options.layoutConfig = { drawingWidth: 400,\n                             drawingHeight: 600,\n                             drawingMargin: 0,\n                             tableWidth: 400,\n                             tableHeight: 600,\n                             tableMargin: 0 };\n\n    if ( ! options.translateX )                                           \n        options.translateX = 0;\n\n    if ( ! options.translateY )                                           \n        options.translateY = 0;\n\n    if ( ! options.scale )                                           \n        options.scale = 1;\n\n    options.setDrawingTableSplit = function( drawingTableSplit ) { //can be called with a decimal (0.0 - 1.0), a mode (\"drawing\",\"mixed\",\"table\"), or nothing.\n\n        //TODO if going full-screen and not specifying a split here, then keep the table the same width and give all extra space to the drawing\n        \n        if ( drawingTableSplit === undefined )\n            drawingTableSplit = this.drawingTableSplit;\n        else if ( drawingTableSplit === \"drawing\" )\n            drawingTableSplit = 1.0;\n        else if ( drawingTableSplit === \"mixed\" )\n            drawingTableSplit = this.lastMixedSplit ? this.lastMixedSplit : 0.5;\n        else if ( drawingTableSplit === \"table\" )\n            drawingTableSplit = 0.0;\n\n        if ( drawingTableSplit < 0.05 ) \n        {\n            drawingTableSplit = 0.0;\n            this.drawingTableSplitMode = \"table\";\n        }\n        else if ( drawingTableSplit > 0.95 ) \n        {\n            drawingTableSplit = 1.0;\n            this.drawingTableSplitMode = \"drawing\";\n        }\n        else\n        {\n            this.drawingTableSplitMode = \"mixed\";\n            this.lastMixedSplit = drawingTableSplit;\n        }\n\n        var availableWidth = ( options.maxWidth ) ? options.maxWidth : Math.round( window.innerWidth - 30 -32 ); //30 for resize bar & 32 for scroll bars as not all systems hide scroll bars\n        var availableHeight = ( options.maxHeight ) ? options.maxHeight : Math.round( window.innerHeight - targetdiv.node().getBoundingClientRect().top -60/*controlpanel buttons height*/);\n        if ( this.fullWindow )\n        {\n            availableWidth -= 32; //left & right padding \n            availableHeight -= 30;\n        }\n\n        //console.log(\"setDrawingTableSplit availableWidth:\" + availableWidth + \" fullWindow:\" + this.fullWindow + \" drawingWidth:\" + this.layoutConfig.drawingWidth );\n        this.layoutConfig.drawingWidth = availableWidth * drawingTableSplit;\n        this.layoutConfig.tableWidth   = availableWidth * (1-drawingTableSplit);\n        this.layoutConfig.drawingHeight = availableHeight;\n        this.layoutConfig.tableHeight = availableHeight;\n        console.log(\"setDrawingTableSplit split:\" + drawingTableSplit + \" availableWidth:\" + availableWidth + \" fullWindow:\" + this.fullWindow + \" drawingWidth:\" + this.layoutConfig.drawingWidth );\n        \n        if ( this.sizeButtons )\n        {\n            var drawingTableSplitMode = this.drawingTableSplitMode;\n            this.sizeButtons.selectAll(\"button\")\n                        .data( this.viewOption )\n                        //.enter()\n                        //.append(\"button\")\n                        .attr( \"class\",  function(d) { \n                            return d.mode == drawingTableSplitMode ? \"btn btn-primary\" : \"btn btn-default\" } );\n        }\n\n        if ( this.drawingTableSplit != drawingTableSplit )\n        {\n            this.drawingTableSplit = drawingTableSplit; //so we can call this without a parameter when toggling full size. \n            if ( this.updateServer ) \n                this.updateServer(); \n        }\n    };    \n\n    options.updateServer = graphOptions.interactionPrefix && options.update ? function( k, x, y ) {\n        if ( k )\n        {\n//TODO shouldn't this be this. rather than options.  ???\n\n            if (    (options.translateX == x)\n                 && (options.translateY == y)\n                 && (options.scale == k) )\n                 return;\n\n            options.translateX = x;\n            options.translateY = y;\n            options.scale = k;\n        }\n\n        if ( $(\"div.popover\").length )\n        {\n            console.log(\"Skipping server update as there is an overlay form. \" );\n            return;\n        }\n\n        console.log(\"Update server with pan: \" + x + \",\" + y + \" & zoom:\" + k + \" & options\");\n        var kvpSet = newkvpSet(true) ;\n        kvpSet.add('fullWindow', options.fullWindow ) ;\n        kvpSet.add('drawingTableSplit', options.drawingTableSplit ) ;\n        kvpSet.add('scale', options.scale ) ;\n        kvpSet.add('translateX', options.translateX ) ;\n        kvpSet.add('translateY', options.translateY ) ;        \n        goGraph( options.interactionPrefix + ':' + options.update, fakeEvent(), kvpSet) ;    \n    } : undefined;\n\n    if ( options.fullWindow )\n        targetdiv.node().classList.add(\"full-page\");\n\n    options.setDrawingTableSplit( options.drawingTableSplit ); //shouln't cause a server update\n\n    var focusDrawingObject = ! options.interactive ? undefined : function( d, scrollTable )\n    {\n        if (    ( d3.event) \n             && ( d3.event.originalTarget )\n             && ( d3.event.originalTarget.className === \"ps-ref\" )\n             && ( selectedObject == d )\n             )\n        {\n            selectedObject = d.patternPiece.getObject( d3.event.originalTarget.innerHTML );\n            scrollTable = true;\n        }\n        else if (    ( d3.event) \n                  && ( d3.event.srcElement )\n                  && ( d3.event.srcElement.className === \"ps-ref\" )\n                  && ( selectedObject == d )\n             )\n        {\n            selectedObject = d.patternPiece.getObject( d3.event.srcElement.innerHTML );\n            scrollTable = true;\n        }\n        else\n        {\n            selectedObject = d;\n        }\n\n        for( var j=0; j< pattern.patternPieces.length; j++ )\n            for( var i=0; i< pattern.patternPieces[j].drawingObjects.length; i++ )\n            {\n                var a = pattern.patternPieces[j].drawingObjects[i];\n                var g = a.drawingSvg;\n                if ( g )\n                {\n                    var strokeWidth = a.getStrokeWidth( false, (selectedObject==a) );\n\n                    g.selectAll( \"line\" )\n                     .attr(\"stroke-width\", strokeWidth );\n\n                    g.selectAll( \"path\" )\n                     .attr(\"stroke-width\", strokeWidth );\n\n                    g.selectAll( \"ellipse\" )\n                     .attr(\"stroke-width\", strokeWidth );\n                }\n                //else //this can happen e.g. because a group is hidden\n                //    console.log(\"No drawing object for \" + a.data.name );\n            }        \n\n        var graphdiv = targetdiv;\n        //Remove any existing highlighting in the table. \n        $(graphdiv.node()).find( \".j-active\" ).removeClass(\"j-active\").removeClass(\"j-active-2s\");\n        $(graphdiv.node()).find( \".source\" ).removeClass(\"source\");\n        $(graphdiv.node()).find( \".target\" ).removeClass(\"target\");\n        //$(graphdiv.node()).find( \".j-outline.j-outline-active\" ).removeClass(\"j-outline-active\");\n        //$(this).addClass(\"j-active\"); //highlight the object in the drawing\n\n        //d, the drawing object we clicked on, has a direct reference to its representation in the table\n        if ( selectedObject )\n        {\n            if ( selectedObject.tableSvg ) //should always be set unless there has been a problem\n                selectedObject.tableSvg.node().classList.add(\"j-active\");\n\n            if ( selectedObject.drawingSvg )\n                selectedObject.drawingSvg.node().classList.add(\"j-active\");\n\n            if ( selectedObject.outlineSvg )\n            {\n                selectedObject.outlineSvg.node().classList.add(\"j-active\");\n                var selectedObjectToAdjustAfter2Secs = selectedObject; //The user may have clicked on something else within 2 seconds\n                //the blush will only last 2 seconds anyway, but if we don't do this then a second click whilst it is the active one doesn't repeat the blush\n                setTimeout( function(){ selectedObjectToAdjustAfter2Secs.outlineSvg.node().classList.add(\"j-active-2s\");}, 2000 );\n            }\n        }\n\n        //Set the css class of all links to \"link\" \"source link\" or \"target link\" as appropriate.\n        if ( linksGroup )\n            linksGroup.selectAll(\"path.link\") //rename .link to .dependency\n            .attr(\"class\", function( d ) {                         \n                if ( d.source == selectedObject ) \n                {\n                    d.target.tableSvg.node().classList.add(\"source\");\n\n                    if ( d.target.outlineSvg ) //if it errored this will be undefined\n                        d.target.outlineSvg.node().classList.add(\"source\");\n\n                    //d.target.tableSvg.each( function() { $(this).addClass(\"source\"); } );\n                    return \"source link\";\n                }\n                if ( d.target == selectedObject ) \n                {\n                    d.source.tableSvg.node().classList.add(\"target\");\n\n                    if ( d.source.outlineSvg ) //if it errored this will be undefined\n                        d.source.outlineSvg.node().classList.add(\"target\");\n\n                    //d.source.tableSvg.each( function() { $(this).addClass(\"target\"); } );\n                    return \"target link\";\n                }\n                return \"link\"; \n            } )\n            .each( function( d ) { \n                if (( d.source == selectedObject ) || ( d.target == selectedObject ))\n                    d3.select(this).raise();\n             } );\n\n        //Scroll the table to ensure that d.tableSvg is in view.    \n        if (( scrollTable ) && ( selectedObject ))\n        {\n            if ( selectedObject.tableSvg )\n            {\n                var table = d3.select(\"div.pattern-table\");\n                table.transition()\n                     .duration(500)\n                     .tween(\"uniquetweenname\", scrollTopTween( selectedObject.tableSvg.node().__data__.tableSvgY - ( table.node().getBoundingClientRect().height /2) ));\n            }\n            else\n                console.log( \"Cannot scroll table, no tableSvg - \" + selectedObject.data.name );\n        }\n    };\n\n    var controls;\n    if (( ! options.hideControls ) && ( options.interactive ))\n        controls = doControls( targetdiv, options, pattern );\n\n    var drawingAndTableDiv = targetdiv.append(\"div\");\n    \n    if ( ! options.thumbnail ) \n        drawingAndTableDiv.attr(\"class\", \"pattern-main\")\n\n    doDrawingAndTable = function( retainFocus ) {\n                                    if ( options.layoutConfig.drawingWidth )\n                                        doDrawing( drawingAndTableDiv, pattern, options, contextMenu, controls, focusDrawingObject );\n                                    else\n                                        drawingAndTableDiv.select(\"svg.pattern-drawing\").remove();\n                                                                            \n                                    if (   ( options.layoutConfig.drawingWidth )\n                                        && ( options.layoutConfig.tableWidth ) )\n                                        doResizeBar( drawingAndTableDiv, options );    \n                                    else\n                                        drawingAndTableDiv.select(\"div.pattern-editor-resize\").remove();\n\n                                    if ( options.layoutConfig.tableWidth )\n                                        doTable( drawingAndTableDiv, pattern, options, contextMenu, focusDrawingObject );\n                                    else\n                                        drawingAndTableDiv.select(\"div.pattern-table\").remove();\n\n                                    if ( retainFocus )\n                                        //e.g. if doing show/hide functions button\n                                        focusDrawingObject( selectedObject, true );\n                                };\n\n    doDrawingAndTable();                   \n    \n    if (( options.returnSVG !== undefined ) && ( options.returnID ))\n    {\n        var serializer = new XMLSerializer();\n        var xmlString = serializer.serializeToString( targetdiv.select('svg.pattern-drawing').node());        \n        var thisHash = CryptoJS.MD5( xmlString ).toString();\n        if ( options.currentSVGhash !== thisHash )\n        {\n            var kvpSet = newkvpSet(true);\n            kvpSet.add( 'svg', xmlString );\n            kvpSet.add( 'id', options.returnID ) ;\n            goGraph( options.interactionPrefix + ':' + options.returnSVG, fakeEvent(), kvpSet);\n        }\n        else\n        {\n            console.log(\"Current thumbnail is still valid.\");\n        }\n    }\n\n    if ( ! options.interactive )\n        return;\n\n    var errorFound = false;\n    var firstDrawingObject;\n    for( var j=0; j< pattern.patternPieces.length; j++ )\n    {\n        for( var i=0; i< pattern.patternPieces[j].drawingObjects.length; i++ )\n        {\n            var a = pattern.patternPieces[j].drawingObjects[i];\n\n            if (( firstDrawingObject === undefined ) && ( a.isVisible( options ) ))\n                firstDrawingObject = a;\n\n            if ( a.error )\n            {\n                focusDrawingObject(a, true);\n                errorFound = true;\n                break;\n            }\n        }\n        if ( errorFound )\n            break;\n    }\n\n    //if not focussing on an error then see if there is a recently edited item to focus on. \n    if ( ! errorFound )\n    {\n        if ( options.focus ) \n        {\n            var a = pattern.getObject( options.focus );\n\n            if ( ! a )\n            try {\n                a = pattern.getMeasurement( options.focus );\n            } catch (e){\n            }\n\n            if ( ! a )\n                a = pattern.getVariable( options.focus );\n\n            if ( a )\n                focusDrawingObject(a, true);\n        }\n        else\n        {\n            focusDrawingObject(firstDrawingObject, true);\n        }\n    }\n}\n\n\nfunction doResizeBar( graphdiv, editorOptions )\n{\n    var layoutConfig = editorOptions.layoutConfig;\n    var drag = d3.drag()\n    .on(\"start\", function(r) {\n        console.log(\"dragStart\");\n        var rg = d3.select(this);        \n        r.initialX = d3.event.x;\n        r.resizeBarBaseStyle = rg.attr(\"style\");\n    })\n    .on(\"drag\", function(r) {\n        console.log(\"drag\");\n        var rg = d3.select(this);       \n        rg.attr(\"style\", r.resizeBarBaseStyle + \" left:\" + ( d3.event.x - r.initialX ) + \"px;\" ); \n    })\n    .on(\"end\", function(r){\n        console.log(\"dragEnd: \" + d3.event.x + \" (\" + ( d3.event.x - r.initialX ) + \")\" );\n        console.log( \"layoutConfig:\" + layoutConfig ); \n        var rg = d3.select(this);       \n        rg.attr(\"style\", r.resizeBarBaseStyle ); \n        var newDrawingWidth = layoutConfig.drawingWidth + ( d3.event.x - r.initialX );\n        var newTableWidth  = layoutConfig.tableWidth - ( d3.event.x - r.initialX );\n        editorOptions.setDrawingTableSplit( newDrawingWidth / ( newDrawingWidth + newTableWidth) );\n        doDrawingAndTable();\n    });\n\n    var layoutConfig = editorOptions.layoutConfig;\n    var height = layoutConfig.drawingHeight;\n\n    graphdiv.select( \"div.pattern-editor-resize\" ).remove();\n    graphdiv.selectAll( \"div.pattern-editor-resize\" )\n            .data( [ editorOptions ] )\n            .enter()\n            .append(\"div\")\n            .attr(\"class\", \"pattern-editor-resize\")\n            .attr(\"style\", \"height:\" + height + \"px;\" )\n            .call( drag );\n}\n\n\nfunction doControls( graphdiv, editorOptions, pattern )\n{\n    if ( ! editorOptions )\n        return;\n\n    var controls = graphdiv.append(\"div\").attr(\"class\", \"pattern-editor-controls\")\n\n    if (    ( editorOptions.viewOption )\n         && ( typeof editorOptions.viewOption === \"object\" ) //allow viewOption=\"drawing\" to prevent display if these buttons\n         && ( editorOptions.viewOption.length > 1 ) )\n    {\n        editorOptions.sizeButtons = controls.append(\"div\").attr(\"class\", \"btn-group view-options\");\n        editorOptions.sizeButtons.selectAll(\"button\")\n                    .data( editorOptions.viewOption )\n                    .enter()\n                    .append(\"button\")\n                    .attr( \"class\",  function(d) { return d.mode == editorOptions.drawingTableSplitMode ? \"btn btn-primary\" : \"btn btn-default\" } )\n                    .html(function(d) { return '<i class=\"' + d.icon + '\"></i>'; })\n                    .on(\"click\", function(d) {\n                        d3.event.preventDefault();\n                        editorOptions.setDrawingTableSplit( d.mode );\n                        doDrawingAndTable();\n                        //$(this).parent().find(\"button\").removeClass(\"btn-primary\").addClass(\"btn-default\");\n                        //$(this).addClass(\"btn-primary\");\n                    } );\n                    //TODO set the selected button to button-primary\n    }\n\n    if ( editorOptions.includeFullPageOption )\n    {\n        var toggleFullScreen = function() {\n            d3.event.preventDefault();\n\n            if ( graphdiv.classed(\"full-page\") ) \n            {\n                graphdiv.node().classList.remove(\"full-page\");\n                editorOptions.fullWindow = false;\n            }\n            else\n            {\n                graphdiv.node().classList.add(\"full-page\");\n                editorOptions.fullWindow = true;\n            }\n\n            editorOptions.setDrawingTableSplit();\n\n            if ( editorOptions.updateServer ) \n                editorOptions.updateServer();\n\n            doDrawingAndTable();\n        };\n\n        var fullPageButton = controls.append(\"button\")\n                                     .attr(\"class\", \"btn btn-default toggle-full-page\")\n                                     .html( '<i class=\"icon-fullscreen\" />' )\n                                     .attr(\"title\",\"Toggle full screen\")\n                                     .on(\"click\", toggleFullScreen );\n    }\n\n    //Zoom to fit. \n    if ( editorOptions.allowPanAndZoom )\n    {\n        var zoomToFitButton = controls.append(\"button\")\n                                     .attr(\"class\", \"btn btn-default zoom-to-fit\")\n                                     .html( '<i class=\"icon-move\" />' )\n                                     .attr(\"title\",\"Zoom to fit\");\n                                     //.on(\"click\", zoomToFit );\n    }    \n\n    if ( editorOptions.downloadOption )\n    {\n        var downloadFunction = function() {\n            var serializer = new XMLSerializer();\n            var xmlString = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\r\\n\" + serializer.serializeToString( graphdiv.select(\"svg.pattern-drawing\").node() );\n            //var imgData = 'data:image/svg+xml;base64,\\n' + btoa(xmlString);\n            var imgData = 'data:image/svg+xml;charset=utf-8,\\n' + encodeURIComponent(xmlString);\n            \n\n            d3.select(this)\n                          .attr( \"href-lang\", \"image/svg+xml; charset=utf-8\" )\n                          .attr( \"href\", imgData )\n                          .attr( \"download\", pattern.patternNumberAndName +  ( editorOptions.targetPiece.name ? \" - \" + editorOptions.targetPiece.name : \"\" ) + \" \" + pattern.getDate() + \".svg\" );\n        };\n\n        var downloadLink = controls.append(\"a\")\n                                     .attr(\"class\", \"btn btn-default download\")\n                                     .html( '<i class=\"icon-download\"></i> Download' )\n                                     .attr(\"title\",\"Download\")\n                                     .on(\"click\", downloadFunction );\n    }    \n\n    if ( editorOptions.interactive )\n    {\n        var toggleShowFormulas = function() {\n            d3.event.preventDefault();\n            editorOptions.showFormulas = ! editorOptions.showFormulas;\n            $(this).children(\"i\").attr(\"class\",editorOptions.showFormulas ? \"icon-check\" : \"icon-check-empty\" );\n            doDrawingAndTable( true /*retain focus*/ );\n        };\n\n        var optionMenuToggle = function() {\n            d3.event.preventDefault();\n            var $optionMenu = $( \"#optionMenu\");\n            if ( $optionMenu.is(\":visible\")) $optionMenu.hide(); else $optionMenu.show();\n        }\n\n        var optionMenu = controls.append(\"div\").attr(\"class\",\"pattern-popup\")\n                                 .append(\"div\").attr(\"id\",\"optionMenu\" ); //.css(\"display\",\"visible\")\n        optionMenu.append(\"button\").html( '<i class=\"icon-remove\"></i>' ).on(\"click\", optionMenuToggle );\n\n        pattern.patternPieces.forEach( function(pp) {\n            if ( ! pp.groups.length )\n                return;\n            var groupOptionsForPiece = optionMenu.append(\"section\");\n            groupOptionsForPiece.append(\"h2\").text( pp.name );\n            pp.groups.forEach( function(g) {\n                var groupOption = groupOptionsForPiece.append(\"div\").attr(\"class\",\"group-option\");\n                var toggleGroup = function() {\n                    g.visible = ! g.visible;  \n\n                    if(( typeof goGraph === \"function\" ) && ( g.update ))\n                    {\n                        var kvpSet = newkvpSet(true) ;\n                        kvpSet.add('visible', g.visible ) ;\n                        goGraph(editorOptions.interactionPrefix + ':' + g.update, fakeEvent(), kvpSet) ;    \n                    }\n\n                    return g.visible;\n                };\n                groupOption.append( \"i\" ).attr(\"class\",  g.visible ? 'icon-eye-open' :'icon-eye-close' )\n                           .on( \"click\", function() { \n                                            d3.event.preventDefault();\n                                            var visible = toggleGroup();\n                                            d3.select(this).attr(\"class\",visible ? \"icon-eye-open\" : \"icon-eye-close\" );\n                                            doDrawingAndTable( true /*retain focus*/ );\n                                } );\n                groupOption.append( 'span' )\n                           .text(g.name );\n                if (( g.contextMenu ) && ( typeof goGraph === \"function\" ))\n                groupOption.append( \"i\" ).attr(\"class\",  \"icon-ellipsis-horizontal k-icon-button\" )           \n                           .on( \"click\", function() { \n                            d3.event.preventDefault();\n                            var v = newkvpSet(false) ;\n                            goGraph( editorOptions.interactionPrefix + ':' + g.contextMenu, d3.event, v );\n                            } );\n            });\n        });\n\n        optionMenu.append(\"div\").attr(\"class\",\"formula-option\").html( '<i class=\"icon-check\"></i>show formulas' ).on(\"click\", toggleShowFormulas );\n\n        if ( ! ( editorOptions.targetPiece && editorOptions.lifeSize ) ) //&& ! downloadOption ? \n            controls.append(\"button\")\n                    .attr(\"class\",\"btn btn-default toggle-options\").html( '<i class=\"icon-adjust\"></i>' )\n                    .attr(\"title\",\"Group/formula visibility\").on(\"click\", optionMenuToggle );\n    } //options menu to show/hide groups and show/hide formula\n\n    if ( pattern.wallpapers )\n    {\n        initialiseWallpapers( pattern, editorOptions.interactionPrefix );\n\n        var wallpaperMenuToggle = function() {\n            d3.event.preventDefault();\n            var $wallpaperMenu = $( \"#wallpapersMenu\");\n            if ( $wallpaperMenu.is(\":visible\")) $wallpaperMenu.hide(); else $wallpaperMenu.show();\n        }\n\n        var wallpaperMenu = controls.append(\"div\").attr(\"class\",\"pattern-popup\")\n                                    .append(\"div\").attr(\"id\",\"wallpapersMenu\" ); \n        wallpaperMenu.append(\"button\").html( '<i class=\"icon-remove\"></i>' ).on(\"click\", wallpaperMenuToggle );\n            \n        var wallpaperListSection = wallpaperMenu.append(\"section\");\n        wallpaperListSection.append(\"h2\").text( \"Wallpapers\" );\n        wallpaperListSection = wallpaperListSection.append(\"ul\");\n        wallpaperListSection.selectAll(\"li\")\n            .data( pattern.wallpapers )\n            .enter()\n            .append(\"li\")\n            .attr( \"class\", function(w) { return w.hide ? 'wallpaper-hidden' : null; } )\n            .each( function(wallpaper,i){                \n                var wallpaperDiv = d3.select(this);\n\n                \n                wallpaperDiv.append( \"span\" ).html( function(w) { return w.hide ? '<i class=\"icon-eye-close\"/>' : '<i class=\"icon-eye-open\"/>' } )\n                                           .on(\"click\", function(w) { d3.event.preventDefault(); d3.event.stopPropagation();\n                                                                      w.hide = ! w.hide; \n                                                                      d3.select(this).html( w.hide ? '<i class=\"icon-eye-close\"/>' : '<i class=\"icon-eye-open\"/>' );\n                                                                      d3.select(this.parentNode).attr( \"class\", w.hide ? 'wallpaper-hidden' : null );\n                                                                      w.updateServer();\n                                                                      var wallpaperGroups = graphdiv.select( \"g.wallpapers\");\n                                                                      doWallpapers( wallpaperGroups, pattern );                                                              \n                                                                     } );\n                wallpaperDiv.append( \"span\" ).html( function(w) { return w.editable ? '<i class=\"icon-unlock\"/>' : w.allowEdit ? '<i class=\"icon-lock\"/>' : '<i class=\"icon-lock disabled\"/>' } )\n                                           .on(\"click\", function(w) { d3.event.preventDefault(); d3.event.stopPropagation();\n                                                                      if ( w.allowEdit )\n                                                                      {\n                                                                        w.editable = ! w.editable; \n                                                                        d3.select(this).html( w.editable ? '<i class=\"icon-unlock\"/>' : '<i class=\"icon-lock\"/>' );\n                                                                        var wallpaperGroups = graphdiv.select( \"g.wallpapers\");\n                                                                        doWallpapers( wallpaperGroups, pattern );                                                              \n                                                                      }\n                                                                     } );\n                wallpaperDiv.append( \"span\" ).text( wallpaper.filename ? wallpaper.filename : wallpaper.imageurl );\n                                                                     //icon-lock icon-unlock icon-move icon-eye-open icon-eye-close\n            });            \n\n        controls.append(\"button\").attr(\"class\",\"btn btn-default toggle-options\").html( '<i class=\"icon-camera-retro\"></i>' ).attr(\"title\",\"Wallpapers\").on(\"click\", wallpaperMenuToggle );\n    } //wallpapers button    \n\n    return controls;\n}\n\n\nfunction initialiseWallpapers( pattern, interactionPrefix )\n{    \n    var updateServer = ( typeof goGraph === \"function\" ) ? function(e) {\n        var kvpSet = newkvpSet(true) ;\n        kvpSet.add('offsetX', this.offsetX ) ;\n        kvpSet.add('offsetY', this.offsetY ) ;\n        kvpSet.add('scaleX', this.scaleX * defaultScale ) ;\n        kvpSet.add('scaleY', this.scaleY * defaultScale ) ;\n        kvpSet.add('opacity', this.opacity ) ;\n        kvpSet.add('visible', ! this.hide ) ;\n        goGraph(interactionPrefix + ':' + this.update, fakeEvent(), kvpSet) ;    \n    } : function(e){};\n\n    var wallpapers = pattern.wallpapers; \n    for( var i=0; i<wallpapers.length; i++ )\n    {\n        var w = wallpapers[i];\n\n        if ( ! w.initialised )\n        {\n            //A 720px image is naturally 10in (at 72dpi)\n            //If our pattern as 10in across then our image should be 10 units.\n            //If our pattern was 10cm across then our image should be 25.4 units and we would expect to need to specify a scale of 1/2.54\n            var defaultScale = 72;\n            if ( pattern.units === \"cm\" )\n            {\n                defaultScale = 72 / 2.54;\n            }\n            else if ( pattern.units === \"mm\" )\n            {\n                defaultScale = 72 / 25.4;\n            }\n            w.scaleX = w.scaleX / defaultScale /*dpi*/; //And adjust by pattern.units\n            w.scaleY = w.scaleY / defaultScale /*dpi*/;\n            w.hide = ( w.visible !== undefined ) && (! w.visible );\n            w.allowEdit = ( w.allowEdit === undefined ) || ( w.allowEdit );\n            \n            //w.dimensionsKnown = dimensionsKnown;\n            $(\"<img/>\") // Make in memory copy of image to avoid css issues\n                .attr(\"src\", w.imageurl )\n                .attr(\"data-wallpaper\", i)\n                .on( \"load\", function() {\n                    //seems like we can't rely on closure to pass w in, it always   points to the final wallpaper\n                    w = wallpapers[ this.dataset.wallpaper ];\n                    w.width = this.width;   // Note: $(this).width() will not\n                    w.height = this.height; // work for in memory images.\n                    //console.log( \"jquery Image loaded w.imageurl \" + w.imageurl + \" width:\" + w.width + \" height:\" + w.height);\n                    //console.log( \"Wallpaper dimensions known. Image loaded w.imageurl width:\" + w.width + \" height:\" + w.height );\n                    if ( w.image )\n                    {\n                        //console.log( \" setting d3Image dimentions.\" );\n                        d3.select( w.image ).attr(\"width\", w.width );        \n                        d3.select( w.image ).attr(\"height\", w.height );        \n                    }\n                });\n                \n            if ( updateServer )\n                w.updateServer = updateServer;\n\n            w.initialised = true;\n        }    \n    }\n}\n\n\n//http://bl.ocks.org/humbletim/5507619\nfunction scrollTopTween(scrollTop) \n{\n    return function() {\n        var i = d3.interpolateNumber(this.scrollTop, scrollTop);\n        //console.log( \"function1: \", this.scrollTop, \" - \", scrollTop );\n        return function(t) { \n            this.scrollTop = i(t); \n            //console.log( \"function2: \", this.scrollTop );\n        };\n    }\n}\n  \n\n//Do the drawing... (we've added draw() to each drawing object.\nfunction doDrawing( graphdiv, pattern, editorOptions, contextMenu, controls, focusDrawingObject )\n{\n    var layoutConfig = editorOptions.layoutConfig;\n    var margin = editorOptions.lifeSize ? pattern.getPatternEquivalentOfMM(5) : 0;\n    if ( margin )\n    {\n        pattern.visibleBounds.minX = Math.round( ( pattern.visibleBounds.minX - margin ) * 1000 ) / 1000;\n        pattern.visibleBounds.minY = Math.round( ( pattern.visibleBounds.minY - margin ) * 1000 ) / 1000;\n        pattern.visibleBounds.maxX = Math.round( ( pattern.visibleBounds.maxX + margin ) * 1000 ) / 1000;\n        pattern.visibleBounds.maxY = Math.round( ( pattern.visibleBounds.maxY + margin ) * 1000 ) / 1000;\n    }\n    var width =  layoutConfig.drawingWidth;\n    var height = layoutConfig.drawingHeight;\n    var patternWidth = pattern.visibleBounds.maxX - pattern.visibleBounds.minX;\n    var patternHeight = pattern.visibleBounds.maxY - pattern.visibleBounds.minY;\n\n    graphdiv.select(\"svg.pattern-drawing\").remove();\n\n    var svg;\n    \n    if ( editorOptions.lifeSize )\n    {\n        //The margin needs to at least be 0.5 * strokewidth so tha that strokes arnt clipped. \n        var margin = pattern.getPatternEquivalentOfMM(5);\n        patternWidth = Math.round( ( patternWidth + margin ) * 1000 ) / 1000;\n        patternHeight = Math.round( ( patternHeight + margin ) * 1000 ) / 1000;\n        svg = graphdiv.append(\"svg\")\n                      .attr(\"class\", \"pattern-drawing\" )\n                      .attr(\"viewBox\", pattern.visibleBounds.minX + \" \" + pattern.visibleBounds.minY + \" \" + patternWidth + \" \" + patternHeight );\n\n        if ( editorOptions.lifeSize )\n        {\n            svg.attr(\"width\", patternWidth + pattern.units )\n               .attr(\"height\", patternHeight + pattern.units );\n        }                      \n    }\n    else\n    {\n        svg = graphdiv.append(\"svg\")\n                       .attr(\"class\", \"pattern-drawing\" )\n                       .attr(\"width\", width + ( 2 * margin ) )\n                       .attr(\"height\", height + ( 2 * margin ));\n\n        if ( editorOptions.thumbnail )\n            svg.attr(\"viewBox\", 0 + \" \" + 0 + \" \" + (width + ( 2 * margin )) + \" \" + (height + ( 2 * margin )) );\n    }\n\n    var transformGroup1 = svg.append(\"g\"); //This gets used by d3.zoom\n\n    //console.log( \"Pattern bounds minX:\" + pattern.bounds.minX + \" maxX:\" + pattern.bounds.maxX );\n    //console.log( \"Pattern bounds minY:\" + pattern.bounds.minY + \" maxY:\" + pattern.bounds.maxY );\n\n    //transformGroup2 scales from calculated positions in pattern-space (e.g. 10 representing 10cm) to\n    //pixels available. So 10cm in a 500px drawing has a scale of 50. \n    var transformGroup2;\n\n    if ( editorOptions.lifeSize )// || ( editorOptions.thumbnail ))\n    {\n        scale = 1;\n        transformGroup2 = transformGroup1; //we don't need another group\n    }\n    else\n    {\n        var scaleX = width / patternWidth;                   \n        var scaleY = height / patternHeight;           \n        \n        if ( ( isFinite( scaleX ) ) && ( isFinite( scaleY ) ) )\n            scale = scaleX > scaleY ? scaleY : scaleX;\n        else if ( isFinite( scaleX ) )\n            scale = scaleX;\n        else\n            scale = 1;\n\n        transformGroup2 = transformGroup2 = transformGroup1.append(\"g\").attr(\"transform\", \"scale(\" + scale + \",\" + scale + \")\");\n    }\n\n    //console.log( \"scale:\" + scale + \" patternWidth:\" + patternWidth + \" width:\" + width );\n\n    //centralise horizontally                            \n    var boundsWidth = pattern.visibleBounds.maxX - pattern.visibleBounds.minX;\n    var availableWidth = width / scale;\n    var offSetX = ( availableWidth - boundsWidth ) /2;\n\n    //transformGroup3 shifts the position of the pattern, so that it is centered in the available space. \n    var transformGroup3 = transformGroup2.append(\"g\")                               \n                                         .attr(\"class\", editorOptions.thumbnail ? \"pattern thumbnail\" : \"pattern\");                           \n\n    if ( editorOptions.downloadOption )  \n        transformGroup3.attr(\"id\", pattern.patternNumberAndName )\n        \n    if ( ! editorOptions.lifeSize )\n        transformGroup3.attr(\"transform\", \"translate(\" + ( ( -1.0 * ( pattern.visibleBounds.minX - offSetX ) ) ) + \",\" + ( ( -1.0 * pattern.visibleBounds.minY ) ) + \")\");    \n\n    if ( pattern.wallpapers )\n    {\n        var wallpaperGroups = transformGroup2.append(\"g\")\n                                             .attr(\"class\",\"wallpapers\")\n                                             .attr(\"transform\", \"translate(\" + ( ( -1.0 * ( pattern.visibleBounds.minX - offSetX ) ) ) + \",\" + ( ( -1.0 * pattern.visibleBounds.minY ) ) + \")\")   \n                                             .lower();\n        doWallpapers( wallpaperGroups, pattern );\n    }\n     \n    //Clicking on an object in the drawing should highlight it in the table.\n    var onclick = ! editorOptions.interactive ? undefined : function(d) {\n        d3.event.preventDefault();\n        focusDrawingObject(d,true);\n    };\n\n    for( var j=0; j< pattern.patternPieces.length; j++ )\n    {\n        var patternPiece = pattern.patternPieces[j];\n\n        var skipDrawing = editorOptions.skipDrawing;\n\n        if ( ! skipDrawing )\n        {\n            var outlineGroup = ! editorOptions.interactive ? undefined : transformGroup3.append(\"g\").attr(\"class\",\"j-outline\");\n            var drawingGroup = transformGroup3.append(\"g\").attr(\"class\",\"j-drawing\");\n\n            if ( editorOptions.interactive )\n            {\n                const drawingOptions = { \"outline\": false, \n                                         \"label\": (! editorOptions.hideLabels),\n                                         \"dot\":  (! editorOptions.hideLabels) };\n                var a = drawingGroup.selectAll(\"g\");    \n                a = a.data( patternPiece.drawingObjects );\n                a.enter()\n                .append(\"g\")\n                .on(\"contextmenu\", contextMenu)\n                .on(\"click\", onclick)\n                .on('touchstart', function() { \n                    this.touchStartTime = new Date(); \n                    if ( event ) event.preventDefault();\n                })\n                .on('touchend',function(d) {    \n                    const endTime = new Date(); \n                    const duration = endTime - this.touchStartTime;\n                    if ( event ) event.preventDefault();\n                    if (( duration > 400) || ( selectedObject === d ))\n                    { \n                        //console.log(\"long touch, \" + (duration) + \" milliseconds long\");\n                        contextMenu(d);\n                    }\n                    else {\n                        //console.log(\"regular touch, \" + (duration) + \" milliseconds long\");\n                        onclick(d);\n                    }                    \n                })\n                .each( function(d,i) {\n                    var g = d3.select( this );                        \n                    if (   ( typeof d.draw === \"function\" ) \n                        && ( ! d.error )\n                        && ( d.isVisible( editorOptions ) ) )\n                    try {\n                        d.draw( g, drawingOptions );\n                        d.drawingSvg = g;                 \n                    } catch ( e ) {\n                        d.error = \"Drawing failed. \" + e;\n                    }\n                });\n            }\n            else //thumbnail\n            {\n                //In order to have the minimum SVG then don't create a group for each drawing object. \n                const drawingOptions = { \"outline\": false, \n                                         \"label\": (! editorOptions.hideLabels),\n                                         \"dot\":  (! editorOptions.hideLabels) };\n                drawingGroup.selectAll(\"g\")\n                    .data( patternPiece.drawingObjects )\n                    .enter()\n                    .each( function(d,i) {\n                    var g = d3.select( this );                        \n                    if (   ( typeof d.draw === \"function\" ) \n                        && ( ! d.error )\n                        && ( d.isVisible( editorOptions ) ) )\n                    try {\n                        d.draw( g, drawingOptions );\n                    } catch ( e ) {\n                        d.error = \"Drawing failed. \" + e;\n                    }\n                });\n            }\n\n            if ( outlineGroup )\n            {\n                outlineGroup.selectAll(\"g\") \n                .data( patternPiece.drawingObjects )\n                .enter()\n                .append(\"g\")\n                .on(\"contextmenu\", contextMenu)\n                .on(\"click\", onclick)\n                .on('touchstart', function() { \n                    this.touchStartTime = new Date(); \n                    if ( event ) event.preventDefault();\n                })\n                .on('touchend',function(d) {    \n                    const endTime = new Date(); \n                    const duration = endTime - this.touchStartTime;\n                    if ( event ) event.preventDefault();\n                    if (( duration > 400) || ( selectedObject === d ))\n                    { \n                        //console.log(\"long touch, \" + (duration) + \" milliseconds long\");\n                        contextMenu(d);\n                    }\n                    else {\n                        //console.log(\"regular touch, \" + (duration) + \" milliseconds long\");\n                        onclick(d);\n                    }                    \n                })                \n                .each( function(d,i) {\n                    var g = d3.select( this );\n                    if (   ( typeof d.draw === \"function\" ) \n                        && ( ! d.error )\n                        && ( d.isVisible( editorOptions ) ) )\n                    {\n                        d.draw( g, { \"outline\": true, \"label\": false, \"dot\":true } );\n                        d.outlineSvg = g;\n                    }\n                });\n            }\n        }\n\n        var pieceGroup = transformGroup3.append(\"g\").attr(\"class\",\"j-pieces\");\n\n        if ( ! editorOptions.skipPieces )\n        {\n            var pg = pieceGroup.selectAll(\"g\");    \n            pg = pg.data( patternPiece.pieces );\n            pg.enter()\n            .append(\"g\")        \n            //.on(\"contextmenu\", contextMenu)\n            //.on(\"click\", onclick)\n            .each( function(p,i) {\n                var g = d3.select( this );\n                g.attr(\"id\", p.name );\n\n                //if doing an export of multiple pieces then take the piece.mx/my into account\n                if ( editorOptions.targetPiece === \"all\" ) //OR AN ARRAY WITH >1 length\n                {\n                    g.attr(\"transform\", \"translate(\" + ( 1.0 * p.data.mx ) + \",\" +  (1.0 * p.data.my ) + \")\");    \n                }\n\n                if (   ( typeof p.drawSeamLine === \"function\" ) )\n                {\n                    const simplify = ( editorOptions.thumbnail ) && ( editorOptions.targetPiece === \"all\" );\n                    const useExportStyles = editorOptions.downloadOption;\n\n                    p.drawSeamAllowance( g, useExportStyles ); //do this first as it is bigger and we want it underneath in case we fill \n                    p.drawSeamLine( g, useExportStyles );\n                    p.drawInternalPaths( g, useExportStyles );\n                    if ( ! simplify )\n                    {\n                        p.drawNotches( g, useExportStyles );\n                        p.drawMarkings( g, useExportStyles );\n                    }\n                    p.svg = g;\n                }\n            });\n        }\n    };\n\n    var updateServerAfterDelay = function()\n    {\n        //Lets only update the server if we've stopped panning and zooming for > 1s.\n        timeOfLastTweak = (new Date()).getTime();\n        if ( ! updateServerTimer )\n        {\n            var updateServerTimerExpired = function () {\n\n                updateServerTimer = null;          \n                //console.log(\"Zoom update server timer activated. TimeOfLastTweak:\" + timeOfLastTweak + \" Now:\" + (new Date()).getTime());\n\n                if ( (new Date()).getTime() >= ( timeOfLastTweak + 500 ) )\n                {\n                    var zt = d3.zoomTransform( transformGroup1.node() );\n                    if ( editorOptions.updateServer )\n                        editorOptions.updateServer( zt.k, zt.x, zt.y );\n                }\n                else\n                    updateServerTimer = setTimeout(updateServerTimerExpired, 500);\n            }\n\n            updateServerTimer = setTimeout(updateServerTimerExpired, 500);\n        }           \n    };\n\n    var zoomed = function() {\n        transformGroup1.attr(\"transform\", d3.event.transform);\n\n        var currentScale = d3.zoomTransform( transformGroup1.node() ).k; //do we want to scale 1-10 to 1-5 for fonts and linewidths and dots?\n        if (   ( currentScale > (1.1*fontsSizedForScale) )\n            || ( currentScale < (0.9*fontsSizedForScale) )\n            || ( currentScale == 1 ) || ( currentScale == 8 ) )\n        {\n            if ( ! fontResizeTimer )\n            {\n                fontResizeTimer = setTimeout(function () {      \n                    fontResizeTimer = null;          \n                    fontsSizedForScale = d3.zoomTransform( transformGroup1.node() ).k;\n                    //console.log( \"Resize for \" + fontsSizedForScale);\n\n                    for( var j=0; j< pattern.patternPieces.length; j++ )\n                    {\n                        var patternPiece = pattern.patternPieces[j];\n                \n                        for( var i=0; i< patternPiece.drawingObjects.length; i++ )\n                        {\n                            var a = patternPiece.drawingObjects[i];\n                            var g = a.drawingSvg;                            \n                            if ( g )\n                            {\n                                var labelPosition = a.labelPosition();\n\n                                if ( labelPosition )\n                                {\n                                    g.selectAll( \"text.labl\" )\n                                    .attr(\"font-size\", labelPosition.fontSize + \"px\")\n                                    .attr(\"x\", labelPosition.labelX )\n                                    .attr(\"y\", labelPosition.labelY );\n\n                                    g.selectAll( \"line.labelLine\" )\n                                    .attr(\"x2\", labelPosition.labelLineX )\n                                    .attr(\"y2\", labelPosition.labelLineY );\n                                }\n\n                                const fontSize = Math.round( 1300 / scale / fontsSizedForScale )/100;\n                                g.selectAll( \"text.length\" )\n                                 .attr(\"font-size\", fontSize + \"px\");\n\n                       \n                                g.selectAll( \"circle\" )\n                                .attr(\"r\", Math.round(400 / scale / fontsSizedForScale)/100 );\n\n                                {\n                                    var strokeWidth = a.getStrokeWidth( false, (selectedObject==a) );\n\n                                    g.selectAll( \"line\" )\n                                        .attr( \"stroke-width\", strokeWidth );\n\n                                    g.selectAll( \"path\" )\n                                        .attr( \"stroke-width\", strokeWidth );            \n\n                                    g.selectAll( \"ellipse\" )\n                                        .attr( \"stroke-width\", strokeWidth );            \n                                }\n                            }\n\n                            g = a.outlineSvg;\n                            if ( g )\n                            {\n                                var strokeWidth = a.getStrokeWidth( true );\n\n                                g.selectAll( \"line\" )\n                                 .attr( \"stroke-width\", strokeWidth );\n\n                                g.selectAll( \"path\" )\n                                 .attr( \"stroke-width\", strokeWidth );           \n\n                                g.selectAll( \"ellipse\" )\n                                 .attr( \"stroke-width\", strokeWidth );           \n\n                                g.selectAll( \"circle\" )\n                                    .attr(\"r\", Math.round( 1200 / scale / fontsSizedForScale )/100 );\n                            }\n                        }        \n\n                        //TODO for each piece also scale their stroke width\n\n                        \n                    }\n                }, 50);         \n            }\n        }\n        updateServerAfterDelay();         \n    };           \n\n    fontsSizedForScale = 1; //the starting scale of transformGroup1.\n    if ( editorOptions.allowPanAndZoom )\n    {\n        //TODO just the fontsize needs setting initially to take editorOptions.scale into account\n\n        var transform = d3.zoomIdentity.translate(editorOptions.translateX, editorOptions.translateY).scale(editorOptions.scale);\n        var zoom = d3.zoom()\n                    .extent([[0, 0], [width, height]])\n                    .scaleExtent([0.5, 32])\n                    .on(\"zoom\", zoomed);\n        svg.call( zoom)\n           .call(zoom.transform, transform);\n\n        fontsSizedForScale = editorOptions.scale;\n\n        if ( controls) \n        controls.select( \".zoom-to-fit\" ).on( \"click\", function() \n        {\n            d3.event.preventDefault();\n\n            //Reset transformGroup1 to 0,0 and scale 1\n            svg.call(zoom)\n               .call(zoom.transform, d3.zoomIdentity);\n            \n            if ( editorOptions.updateServer )\n            {\n                var zt = d3.zoomTransform( transformGroup1.node() );\n                editorOptions.updateServer( zt.k, zt.x, zt.y );\n            }\n        } );        \n    }\n}\n\n\nfunction doWallpapers( wallpaperGroups, pattern )\n{\n    var visibleWallpapers = [];\n    for( var i=0; i<pattern.wallpapers.length; i++ )\n    {\n        var w = pattern.wallpapers[i];\n\n        if ( ! w.hide )\n            visibleWallpapers.push( w );\n    }\n\n    var drag = d3.drag()\n        .on(\"start\", function(wallpaper) {\n            //var wallpaperG = d3.select(this);\n            //if ( ! wallpaper.editable )\n            //    return;\n            wallpaper.offsetXdragStart = wallpaper.offsetX - d3.event.x;\n            wallpaper.offsetYdragStart = wallpaper.offsetY - d3.event.y;\n        })\n        .on(\"drag\", function(wallpaper) {\n            //if ( ! wallpaper.editable )\n            //    return;\n            var wallpaperG = d3.select(this);        \n            wallpaper.offsetX = wallpaper.offsetXdragStart + d3.event.x;\n            wallpaper.offsetY = wallpaper.offsetYdragStart + d3.event.y;\n            wallpaperG.attr(\"transform\", \"translate(\" + wallpaper.offsetX + \",\" + wallpaper.offsetY + \") \" + \" scale(\" + wallpaper.scaleX + \",\" + wallpaper.scaleY + \" )\" );\n        })\n        .on(\"end\", function(wallpaper){\n            wallpaper.updateServer( d3.event );\n        });\n\n    wallpaperGroups.selectAll(\"g\")\n                    .data( visibleWallpapers, function(d){return d.filename} )\n                    //.filter(function(w){return !w.hide;})\n                    .enter()\n                    .append(\"g\")\n                    .attr( \"class\", function(w){ return w.editable ? \"wallpaper editable\" : \"wallpaper\" } )\n                    .attr(\"transform\", function(wallpaper) { return  \"translate(\" + ( wallpaper.offsetX ) + \",\" + ( wallpaper.offsetY ) + \")\"\n                                                                    + \" scale(\" + wallpaper.scaleX + \",\" + wallpaper.scaleY + \")\" } )\n                    .append( \"image\" )\n                    //.on( \"load\", function(w) {\n                    //    console.log(\"d3 image loaded\");\n                    //})\n                    .attr( \"href\", function(w) { return w.imageurl } )\n                    .attr( \"opacity\", function(w) { return w.opacity } )\n                    .each( function(w){\n                        //Set this up so that we can later use dimensionsKnown()\n                        console.log(\"** added d3 image and setting w.image width:\" + w.width + \" height:\" + w.height );\n                        w.image = this; \n                        //if we know the dimensions already, set them! (Safari needs this on showing a hidden wallpaper)\n                        d3.select(this).attr( \"width\",w.width);\n                        d3.select(this).attr( \"height\",w.height);\n                    } );\n\n    wallpaperGroups.selectAll(\"g\")\n                    .data( visibleWallpapers, function(d){return d.filename} )\n                    .exit().remove();\n\n    var resize = d3.drag()\n                    .on(\"start\", function(wallpaper) {\n                        wallpaper.offsetXdragStart = d3.event.x - wallpaper.width;\n                        wallpaper.offsetYdragStart = d3.event.y - wallpaper.height;\n                        //console.log(\"start offsetXdragStart:\" + wallpaper.offsetXdragStart );\n                    })\n                    .on(\"end\", function(wallpaper) {\n                        var wallpaperG = d3.select(this.parentNode);\n                        var circle = d3.select(this);\n                        var rect = wallpaperG.select(\"rect\");\n                        var ratio = circle.attr(\"cx\") / wallpaper.width;     \n                        var scaleXbefore = wallpaper.scaleX;                   \n                        wallpaper.scaleX = wallpaper.scaleX * ratio; //fixed aspect?\n                        wallpaper.scaleY = wallpaper.scaleY * ratio;\n                        //console.log( \"cx:\" + circle.attr(\"cx\") + \" image:\" + wallpaper.width + \"  ratio:\" + ratio + \"  scaleXbefore:\" + scaleXbefore + \"  scaleXNow:\" + wallpaper.scaleX );\n                        wallpaperG.attr(\"transform\", \"translate(\" + wallpaper.offsetX + \",\" + wallpaper.offsetY + \") \" + \" scale(\" + wallpaper.scaleX + \",\" + wallpaper.scaleY + \" )\" );\n                        circle.attr(\"cx\", wallpaper.width )\n                              .attr(\"cy\", wallpaper.height );\n                        rect.attr(\"width\", wallpaper.width )\n                            .attr(\"height\", wallpaper.height );\n                        wallpaper.updateServer( d3.event );\n                    } )\n                    .on(\"drag\", function(wallpaper) {\n                        var wallpaperG = d3.select(this.parentNode);\n                        var circle = d3.select(this);\n                        var rect = wallpaperG.select(\"rect\");\n                        var newX = d3.event.x - wallpaper.offsetXdragStart;\n                        var newY = d3.event.y - wallpaper.offsetYdragStart;\n                        //console.log(\"drag d3.event.x:\" + d3.event.x + \"  newX:\" + newX );\n                        if ( true ) //fixed aspect\n                        {\n                            var ratioX = newX / wallpaper.width;\n                            var ratioY = newY / wallpaper.height;\n                            var ratio = (ratioX+ratioY)/2.0;\n                            newX = ratio * wallpaper.width;\n                            newY = ratio * wallpaper.height;\n                        }\n                        circle.attr(\"cx\", newX )\n                                .attr(\"cy\", newY );\n                        rect.attr(\"width\", newX )\n                            .attr(\"height\", newY );\n                    });\n\n    //Add a resizing boundary to each editable wallpaper.                 \n    wallpaperGroups.selectAll(\"g\")\n                    .data( visibleWallpapers,function(d){return d.filename} )\n                    //.filter(function(w){return !w.hide;})\n                    .each( function(w,i) {\n                        var g = d3.select(this);\n                        //This worked on Firefox and Chrome, but not Safari.\n                        //var box = g.node().getBBox();\n                        //w.width = box.width;\n                        //w.height = box.height;\n\n                        if ( w.editable )\n                        {\n                            g.append(\"rect\")\n                            .attr(\"x\",0)\n                            .attr(\"y\",0)\n                            .attr(\"stroke\", \"red\")\n                            .attr(\"fill\", \"none\")\n                            .attr(\"width\", w.width)\n                            .attr(\"height\", w.height);\n    \n                            g.append( \"circle\") \n                            .attr(\"cx\", function(w) { return w.width } )\n                            .attr(\"cy\", function(w) { return w.height } )\n                            .attr(\"r\", 10 / scale / w.scaleX / fontsSizedForScale )\n                            .attr(\"fill\", \"red\")\n                            .call(resize);\n                            \n                            g.call(drag);\n                        }\n                        else\n                        {\n                            g.select(\"rect\").remove();\n                            g.select(\"circle\").remove();\n                            g.on(\".drag\", null );\n                        }\n                    } );\n    //resize(wallpaperGroups.selectAll(\"g > circle\"));            \n}\n\n\nfunction doTable( graphdiv, pattern, editorOptions, contextMenu, focusDrawingObject )\n{\n    var patternPiece1 = pattern.patternPieces[0];\n    var layoutConfig = editorOptions.layoutConfig;\n    var margin = layoutConfig.tableMargin;//25; \n    var width =  layoutConfig.tableWidth;//400;\n    var height = layoutConfig.tableHeight;//600;\n    var minItemHeight = 30; //should not be required\n    var itemMargin = 8;\n    var itemWidth = width *3/4;\n    var ypos = 0;\n    var seq = 1; //TODO get these in the XML as data?\n    var asFormula = editorOptions.showFormulas; \n\n    var onclick = function(d) {\n        d3.event.preventDefault();\n        focusDrawingObject(d,false);\n    }\n\n    graphdiv.select(\"div.pattern-table\").remove();\n\n    var combinedObjects = [];\n\n    //TODO ? a mode where we don't include measurements and variables in the table.\n    if ( pattern.measurement )\n    {\n        for( var m in pattern.measurement )\n            combinedObjects.push( pattern.measurement[m] );\n    }\n\n    if ( pattern.variable )\n    {\n        for( var i in pattern.variable )\n            combinedObjects.push( pattern.variable[i] );\n    }\n\n    for( var j=0; j< pattern.patternPieces.length; j++ )\n    {\n        combinedObjects = combinedObjects.concat( pattern.patternPieces[j].drawingObjects);\n    }\n\n    var svg = graphdiv.append(\"div\")\n                      .attr(\"class\", \"pattern-table\")\n                      .style( \"height\", height +\"px\" )    \n                      .append(\"svg\")\n                      .attr(\"width\", width + ( 2 * margin ) )\n                      .attr(\"height\", minItemHeight * combinedObjects.length );    \n\n    var a = svg.selectAll(\"g\");\n    a = a.data( combinedObjects );\n    a.enter()        \n    .append(\"g\")\n    .each( function(d,i) {\n\n        var divHeight = function(that) {\n\n            //this - the dom svg element\n            //that - the data object\n\n            var h = $(this).find( \"div.outer\" ).height();\n            \n            if ( h < minItemHeight )\n                return minItemHeight;\n\n            return h;\n        };\n\n        var g = d3.select( this );\n\n        var classes = \"j-item\";\n\n        if ( d.isMeasurement )\n            classes += \" j-measurement\";\n        else if ( d.isVariable )\n            classes += \" j-variable\";\n        else if ( ! d.isVisible( editorOptions ) ) //is a drawing object\n            classes += \" group-hidden\"; //hidden because of groups\n\n        d.tableSvg = g;\n        d.tableSvgX = itemWidth;\n        d.tableSvgY = ypos + ( 0.5 * minItemHeight );\n\n        var fo = g.append( \"foreignObject\" )\n        .attr( \"x\", 0 )\n        .attr( \"y\", function (d) { \n             return ypos;\n         } )\n         .attr( \"width\", itemWidth  );\n\n        var html;\n        try {\n            html = d.html( asFormula );\n            if (d.error)\n                html += '<div class=\"error\">' + d.error + '</div>';\n        } catch ( e ) {\n            html = '<div class=\"error\">Failed to generate description.</div>';\n\n            if ( ! d.error )\n                d.error = \"Failed to generate description.\";\n        }\n\n        if ( d.error )\n            classes += \" error\";\n\n        g.attr( \"class\", classes ) ;    \n\n         var div = fo.append( \"xhtml:div\" )\n           .attr(\"class\",\"outer\")\n           .append( \"xhtml:div\" )\n           .attr(\"class\",\"desc\")\n           .html( html );\n\n        fo.attr( \"height\", 1 ); //required by firefox otherwise bounding rects returns nonsense\n        fo.attr( \"height\", divHeight );\n\n        g.attr( \"height\", divHeight )\n        .attr( \"y\", function (d) { \n                                    //Get the height of the foreignObject.\n                                    var h = this.childNodes[0].getBoundingClientRect().height;\n                                    ypos += h + itemMargin; \n                                    //console.log(\"y: \" + ypos );\n                                    return ypos } )\n\n        g.on(\"contextmenu\", contextMenu)\n         .on(\"click\", onclick )\n         .on('touchstart', function() { \n            this.touchStartTime = new Date(); \n            if ( event ) event.preventDefault();\n         })\n         .on('touchend',function(d) {    \n            const endTime = new Date(); \n            const duration = endTime - this.touchStartTime;\n            if ( event ) event.preventDefault();\n            if (( duration > 400) || ( selectedObject === d ))\n            { \n                //console.log(\"long touch, \" + (duration) + \" milliseconds long\");\n                contextMenu(d);\n            }\n            else {\n                //console.log(\"regular touch, \" + (duration) + \" milliseconds long\");\n                onclick(d);\n            }                    \n         });\n    }); //.each\n        \n    svg.attr(\"height\", ypos );    \n\n    linksGroup = svg.append(\"g\")\n                    .attr(\"class\", \"links\");\n\n    //Links area is width/4 by ypos.            \n    var linkScale = (width/4) / Math.log( Math.abs( ypos /30 ) );   \n\n    drawLinks( pattern, linkScale );\n}\n\n\nfunction drawLinks( pattern, linkScale ) {\n    var linkData = pattern.dependencies.dependencies;\n    \n    linksGroup.selectAll(\"path.link\") //rename .link to .dependency\n                    .data(linkData)\n                    .enter().append(\"path\")\n                    .attr(\"class\", \"link\" )\n                    .attr(\"d\", function( link ) {\n                        var x0 = link.source.tableSvgX, y0 = link.source.tableSvgY,\n                            x1 = link.target.tableSvgX, y1 = link.target.tableSvgY;\n                    \n                        var dx = x0 - x1,\n                            dy = y0 - y1,\n                            l = Math.log( Math.abs(dy /30 ) ) * linkScale;\n                    \n                        var path = d3.path();\n                        path.moveTo( x0, y0 );\n                        path.bezierCurveTo( x0+l , y0, x1+l, y1, x1, y1 );\n                        return path;                      \n                    } );\n}\n\n\n/*\n * Curve that connects items in the table.\n */\nfunction curve(link) {\n    var x0 = link.source.tableSvgX, y0 = link.source.tableSvgY,\n        x1 = link.target.tableSvgX, y1 = link.target.tableSvgY;\n\n    var dx = x0 - x1,\n        dy = y0 - y1,\n        l = Math.log( Math.abs(dy /30 ) ) * 50;\n\n    var path = d3.path();\n    path.moveTo( x0, y0 );\n    path.bezierCurveTo( x0+l , y0, x1+l, y1, x1, y1 );\n    return path;                      \n}\n\n//TODO move to kinodbglue\nfunction newkvpSet(noRefresh)\n{\n    var kvp = { } ;\n    kvp.kvps = new Array() ;\n\n    kvp.add = function (k, v)\n    {\n        this.kvps.push ( {k: k, v: v} ) ;\n    } ;\n\n    kvp.toString = function (p)\n    {\n        var r = '' ;\n\n        for (var i = 0 ; i < this.kvps.length ; i++)\n        {\n            r += '&' + p + this.kvps[i].k + '=' + this.kvps[i].v ;\n        }\n\n        return r ;\n    } ;\n\n    if (noRefresh)\n        kvp.add(\"_noRefresh\", -1) ;\n\n    return kvp ;\n}\n\n//TODO move to kinodbglue\nfunction fakeEvent(location, x, y)\n{\n    var pXY = {x: 0, y: 0} ;\n    \n    if (location !== undefined)\n    {\n        pXY = getElementXY(location) ;\n        pXY.x = Math.round(pXY.x + x) ;\n        pXY.y = Math.round(pXY.y + y) ;\n    }\n    else\n    {\n        pXY.x = Math.round(x) ;\n        pXY.y = Math.round(y) ;\n    }\n    \n    // event to satisfy goGraph's requirements\n    return { target: location, pageX: 0, pageY: 0, processedXY: pXY } ;\n}\n\n\nexport{ PatternDrawing, doDrawing, doTable, drawPattern  };","//(c) Copyright 2019 Jason Dore\n//\n//Inspired by the excellent Seamly2D/Valentina pattern drawing software.\n//This library is a ground up implementation in Javascript intended to be compatible with, but\n//not based on, the Seamly2D/Valentina pattern making systen in order to support the community\n//pattern sharing website https://my-pattern.cloud/ . \n//\n//Source maintained at: https://github.com/MrDoo71/PatternEditor\n\nclass Expression {\n\n    constructor(data, pattern, patternPiece) {\n        this.dataDebug = data;\n        //this.operation = data.operation;// ? data.operation : data.operationType ;\n        this.pattern = pattern;\n        this.patternPiece = patternPiece;\n\n        //divide, multiply etc. and functions too\n        if (typeof data.parameter !== \"undefined\") \n        {\n            this.params = data.parameter;\n            for (var a = 0; a < this.params.length; a++) {\n                var p = this.params[a];\n                this.params[a] = new Expression(p, pattern, patternPiece);\n            }            \n        }\n\n        if (typeof data.integerValue !== \"undefined\") \n        {\n            this.constant = data.integerValue;\n            this.value = this.constantValue; //the method constantValue()\n        }\n        else if (typeof data.decimalValue !== \"undefined\") \n        {\n            this.constant = data.decimalValue;\n            this.value = this.constantValue; //the method constantValue()\n        }\n        //else \n        //if (this.operation === \"Variable\") \n        //{\n            else if (  typeof data.keyword !== \"undefined\" )\n            {\n                this.variable = data.keyword;\n                this.value = this.keywordValue;\n            }\n            else if ( typeof data.variable !== \"undefined\")\n            {\n                this.variable = pattern.getVariable( data.variable );\n                this.value = this.variableValue;\n            }\n            else if ( data.measurement )\n            {\n                this.variable = pattern.getMeasurement( data.measurement );\n                this.value = this.measurementValue;\n            }\n            else if ( data.variableType === \"angleOfLine\" )\n            {\n                this.drawingObject1 = patternPiece.getObject( data.drawingObject1 );\n                this.drawingObject2 = patternPiece.getObject( data.drawingObject2 );\n                this.function = data.variableType;\n                this.value = this.functionValue;\n            }\n            else if ( data.variableType === \"lengthOfLine\" )\n            {\n                this.drawingObject1 = patternPiece.getObject( data.drawingObject1 );\n                this.drawingObject2 = patternPiece.getObject( data.drawingObject2 );\n                this.function = data.variableType;\n                this.value = this.functionValue;\n            }\n            else if (    ( data.variableType === \"lengthOfSplinePath\" )\n                      || ( data.variableType === \"lengthOfSpline\" )\n                      || ( data.variableType === \"angle1OfSpline\" )\n                      || ( data.variableType === \"angle2OfSpline\" ) )\n            {\n                if ( data.drawingObject1 && data.drawingObject2 )\n                {\n                    //This shouldn't find an object, otherwise we'd have passed it as a single drawingObject.\n                    this.drawingObject = patternPiece.getObject( \"Spl_\" + data.drawingObject1 + \"_\" + data.drawingObject2 );\n\n                    //at least one of these will be an intersect on a curve, or position along a curve, otherwise they are end points of the curve. \n                    if ( ! this.drawingObject )\n                    {\n                        this.drawingObject1 = patternPiece.getObject( data.drawingObject1 );\n                        this.drawingObject2 = patternPiece.getObject( data.drawingObject2 );\n                        //one of these will be a Spline, the other will be an intersection point on it, or distance along it. \n\n                        //We're not the whole spline, just a segment of it. \n\n                        var drawingObjectDefiningSpline = (    ( this.drawingObject1.data.objectType === \"pointIntersectArcAndAxis\" )               \n                                                            || ( this.drawingObject1.data.objectType === \"pointCutSplinePath\" ) \n                                                            || ( this.drawingObject1.data.objectType === \"cutSpline\" ) ) \n                                                          ? this.drawingObject1\n                                                          : this.drawingObject2;\n\n                        if ( drawingObjectDefiningSpline.arc )                             \n                            this.splineDrawingObject = drawingObjectDefiningSpline.arc;\n                        else if ( drawingObjectDefiningSpline.splinePath )                             \n                            this.splineDrawingObject = drawingObjectDefiningSpline.splinePath;\n                        else if ( drawingObjectDefiningSpline.curve )                             \n                            this.splineDrawingObject = drawingObjectDefiningSpline.curve;\n                        else\n                            throw \"Path not found.\";\n\n                        //console.log(\"Function \" + data.variableType + \" this.drawingObject1.data.objectType:\" + this.drawingObject1.data.objectType + \" this.drawingObject2.data.objectType:\" + this.drawingObject2.data.objectType + \" splineDrawingObject:\" + this.splineDrawingObject );\n\n                        //The other drawing object will either be the start or end of this curve, OR another intersect on the same curve. \n                    }\n                }\n                else\n                    //this is the spline drawing object itself, the curve comes directly from it. \n                    this.drawingObject = patternPiece.getObject( data.drawingObject1 );\n\n                if (( data.segment ) && ( parseInt(data.segment) !== 0 ))\n                    this.segment = parseInt(data.segment);\n\n                this.function = data.variableType;\n                this.value = this.functionValue;\n            }            \n            else if ( data.variableType === \"lengthOfArc\" )\n            {\n                this.drawingObject = patternPiece.getObject( data.drawingObject1 );\n                this.arcSelection = data.arcSelection;\n                this.function = data.variableType;\n                this.value = this.functionValue;\n            }            \n            else if ( data.variableType === \"radiusOfArc\" )\n            {\n                this.drawingObject = patternPiece.getObject( data.drawingObject1 );\n\n                if ( data.radiusSelection === \"ellipticalArcRadius1\" )\n                    this.radiusSelection = 1;\n                else if ( data.radiusSelection === \"ellipticalArcRadius2\" )\n                    this.radiusSelection = 2;\n                else\n                    this.radiusSelection = null;\n\n                this.function = data.variableType;\n                this.value = this.functionValue;\n            }            \n            else if ( typeof data.variableType !== \"undefined\" )\n                throw \"Unsupported variableType:\" + data.variableType;\n        //}\n        else if ( typeof data.functionName !== \"undefined\" )\n        {\n            this.function = data.functionName;\n            this.value = this.functionValue;\n            //having done the parameters earlier. \n        }\n        else if ( typeof data.operation !== \"undefined\" )\n        {\n            //add, multiply etc.\n            this.operation = data.operation;\n            this.value = this.operationValue;\n        }\n        //Don't throw, we still need to continue with setting up the expression so we can describe what is wrong. \n        //else throw \"Unsupported expression.\" ;\n    }\n\n    \n    variableValue() {\n        return this.variable.value();\n    }    \n\n\n    measurementValue() {\n        //console.log(\"Measurement units \" + this.variable.units );\n        //console.log(\"Pattern units \" + this.pattern.units );\n        var measurementUnits = this.variable.units;\n        var patternUnits = this.pattern.units;\n        if ( measurementUnits === patternUnits )\n            return this.variable.value();\n\n        var mm = 1;\n        if ( measurementUnits === \"cm\" )\n            mm = 10;\n        else if ( measurementUnits === \"inch\" )\n            mm = 25.4;\n\n        var pp = mm;\n\n        if ( patternUnits === \"cm\" )\n            pp = mm / 10;\n        else if ( patternUnits === \"inch\" )\n            pp = mm / 25.4;\n\n        return pp * this.variable.value();\n    }    \n\n\n    functionValue(currentLength) {\n        if ( this.function === \"angleOfLine\" )\n        {\n            var point1 = new GeoPoint( this.drawingObject1.p.x, this.drawingObject1.p.y );\n            var point2 = new GeoPoint( this.drawingObject2.p.x, this.drawingObject2.p.y );\n            var line = new GeoLine( point1, point2 );\n            var deg = line.angleDeg();\n            if ( deg < 0 )\n                deg += 360; \n            return deg;\n        }\n        else if ( this.function === \"lengthOfLine\" )\n        {\n            var point1 = new GeoPoint( this.drawingObject1.p.x, this.drawingObject1.p.y );\n            var point2 = new GeoPoint( this.drawingObject2.p.x, this.drawingObject2.p.y );\n            var line = new GeoLine( point1, point2 );\n            //console.log( \"lengthOfLine \" + this.drawingObject1.data.name + this.drawingObject2.data.name + \" = \" + line.getLength() );\n            return line.getLength();\n        }\n        else if (    ( this.function === \"lengthOfSplinePath\" )\n                  || ( this.function === \"lengthOfSpline\" ) )\n        {\n            if ( ! this.drawingObject ) \n            {\n                //how far along the spline is each drawingObject (one is likely at the start or end)\n                //create a copy of the spline with the intersection point added (where along the line if it has multiple nodes? the place where the line length doesn't grow).\n                //https://pomax.github.io/bezierinfo/#splitting\n                return    this.splineDrawingObject.curve.pathLengthAtPoint( this.drawingObject2.p )\n                        - this.splineDrawingObject.curve.pathLengthAtPoint( this.drawingObject1.p );\n                //TODO. or we could use, though they amound to a similar thing. \n               //     return this.splineDrawingObject.curve.splineBetweenPoints( this.drawingObject1.p, this.drawingObject2.p ).pathLength();\n            }\n\n            if (    ( this.function === \"lengthOfSplinePath\" )\n                 && ( this.segment ) )\n                 return this.drawingObject.curve.pathLength( this.segment );\n\n            return this.drawingObject.curve.pathLength();\n        }\n        else if (    ( this.function === \"angle1OfSpline\" )\n                  || ( this.function === \"angle2OfSpline\" ) )\n        {\n            var spline;\n            if ( this.drawingObject ) //the simple case, we are looking at the start/end of a path (not a point along the line, but could be a segment)\n            {\n                spline = this.drawingObject.curve;\n                if ( this.segment )\n                    spline = spline.pathSegment( this.segment );\n            }\n            else\n            {\n                //this.splineDrawingObject is our spl or splpath, and drawingObject1 and drawingObject2 are either its ends, or intersection/pointalong\n                //and we may also have a segment?\n                spline = this.splineDrawingObject.curve;\n                spline = spline.splineBetweenPoints( this.drawingObject1.p, this.drawingObject2.p );\n            }\n\n            if ( this.function === \"angle1OfSpline\" )\n                return spline.nodeData[0].outAngle;\n            else //angle2OfSpline\n                return spline.nodeData[ spline.nodeData.length-1 ].inAngle;\n        }\n        else if ( this.function === \"lengthOfArc\" )\n        {\n            if ( this.arcSelection === \"wholeArc\")\n                return this.drawingObject.arc.pathLength();\n            else\n            {\n                //this.drawingObject is a cut object\n                var arcDrawingObject = this.drawingObject.curve ? this.drawingObject.curve : this.drawingObject.arc;\n\n                //where in the arc is this.drawingObject.curve?\n                var radiusToIntersectLine = new GeoLine( arcDrawingObject.center.p, this.drawingObject.p );\n                var angleToIntersectRad = radiusToIntersectLine.angle;\n                if ( this.arcSelection === \"beforeArcCut\")\n                {\n                    if ( arcDrawingObject.arc instanceof GeoEllipticalArc )\n                    {\n                        //else elliptical arc: from the arc's start angle to this cut angle. \n                        const cutArc = arcDrawingObject.arc.clone();\n                        cutArc.angle2 = radiusToIntersectLine.angleDeg() - cutArc.rotationAngle;\n                        if ( cutArc.angle2 < 0 )\n                            cutArc.angle2 += 360;\n                        return cutArc.pathLength();\n                    }\n                    else //if arc\n                    {\n                        var arcStartAngleRad = arcDrawingObject.angle1.value() / 360 * 2 * Math.PI;\n                        var segmentRad = angleToIntersectRad-arcStartAngleRad;                    \n                        var length = radiusToIntersectLine.length * segmentRad; //because circumference of a arc is radius * angle (if angle is expressed in radians, where a full circle would be Math.PI*2 )\n\n                        //console.log( \"beforeArcCut \" + this.drawingObject.data.name + \" = \" + length );\n                        return length;\n                    }                    \n                }\n                else //afterArcCut\n                {\n                    if ( arcDrawingObject.arc instanceof GeoEllipticalArc )\n                    {\n                        const cutArc = arcDrawingObject.arc.clone();\n                        cutArc.angle1 = radiusToIntersectLine.angleDeg()  - cutArc.rotationAngle;\n                        if ( cutArc.angle1 < 0 )\n                            cutArc.angle1 += 360;\n                        return cutArc.pathLength();\n                    }\n                    else //if arc\n                    {\n                        var arcEndAngleRad = arcDrawingObject.angle2.value() / 360 * 2 * Math.PI;\n                        var segmentRad = arcEndAngleRad - angleToIntersectRad;\n                        var length = radiusToIntersectLine.length * segmentRad;\n                        return length;\n                    }\n                }\n            }\n        }    \n        else if ( this.function === \"radiusOfArc\" )\n        {\n            if ( this.radiusSelection === 1 )\n                return this.drawingObject.radius1.value();\n            else if ( this.radiusSelection === 2 )\n                return this.drawingObject.radius2.value();\n            else\n                return this.drawingObject.radius.value();\n        }\n        else if  ( this.function === \"sqrt\" )\n        {\n            var p1 = this.params[0].value(currentLength);\n            return Math.sqrt( p1 ); \n        }\n        else if  ( this.function === \"-\" )\n        {\n            var p1 = this.params[0].value(currentLength);\n            return -p1; \n        }\n        else if ( this.function === \"min\" )\n        {\n            var p1 = this.params[0].value(currentLength);\n            var p2 = this.params[1].value(currentLength);\n            return Math.min( p1, p2 );\n        }\n        else if ( this.function === \"max\" )\n        {\n            var p1 = this.params[0].value(currentLength);\n            var p2 = this.params[1].value(currentLength);\n            return Math.max( p1, p2 );\n        }\n        else if ( this.function === \"sin\" )\n        {\n            var p1 = this.params[0].value(currentLength);\n            return Math.sin( p1 * Math.PI / 180 );\n        }\n        else if ( this.function === \"cos\" )\n        {\n            var p1 = this.params[0].value(currentLength);\n            return Math.cos( p1 * Math.PI / 180 );\n        }\n        else if ( this.function === \"tan\" )\n        {\n            var p1 = this.params[0].value(currentLength);\n            return Math.tan( p1 * Math.PI / 180 );\n        }\n        else if ( this.function === \"asin\" )\n        {\n            var p1 = this.params[0].value(currentLength);\n            return Math.asin( p1 ) * 180 / Math.PI;\n        }\n        else if ( this.function === \"acos\" )\n        {\n            var p1 = this.params[0].value(currentLength);\n            return Math.acos( p1 ) * 180 / Math.PI;\n        }\n        else if ( this.function === \"atan\" )\n        {\n            var p1 = this.params[0].value(currentLength);\n            return Math.atan( p1 ) * 180 / Math.PI;\n        }        \n        else throw (\"Unknown function: \" + this.function );\n    }\n    \n\n    constantValue() {\n        return this.constant;\n    }\n\n\n    operationValue(currentLength) {\n\n        if (typeof this.params[0].value !== \"function\")\n            throw \"expression p1 not valid\";\n\n        if ( this.operation !== \"()\" )    \n        {\n            if (typeof this.params[1].value !== \"function\")\n                throw \"expression p2 not valid\";\n        }\n\n        if (this.operation === \"+\")\n            return this.params[0].value(currentLength) + this.params[1].value(currentLength);\n\n        else if (this.operation === \"-\")\n            return this.params[0].value(currentLength) - this.params[1].value(currentLength);\n\n        else if (this.operation === \"*\")\n            return this.params[0].value(currentLength) * this.params[1].value(currentLength);\n\n        else if (this.operation === \"/\")\n            return this.params[0].value(currentLength) / this.params[1].value(currentLength);\n            \n        else if (this.operation === \"==\")\n            return this.params[0].value(currentLength) == this.params[1].value(currentLength);\n\n        else if (this.operation === \"!=\")\n            return this.params[0].value(currentLength) != this.params[1].value(currentLength);\n\n        else if (this.operation === \"<\")\n            return this.params[0].value(currentLength) < this.params[1].value(currentLength);\n\n        else if (this.operation === \"<=\")\n            return this.params[0].value(currentLength) <= this.params[1].value(currentLength);\n            \n        else if (this.operation === \">\")\n            return this.params[0].value(currentLength) > this.params[1].value(currentLength);\n\n        else if (this.operation === \">=\")\n            return this.params[0].value(currentLength) >= this.params[1].value(currentLength);\n\n        else if (this.operation === \"()\")\n            return this.params[0].value(currentLength);\n\n        else if  ( this.operation === \"^\" )\n        {\n            var p1 = this.params[0].value(currentLength);\n            var p2 = this.params[1].value(currentLength);\n            return Math.pow( p1, p2 );\n        }    \n        else if (this.operation === \"?\")\n        {\n            var conditionTestResult = this.params[0].value(currentLength);\n            if ( conditionTestResult )\n                return this.params[1].value(currentLength);\n            else\n                return this.params[2].value(currentLength);\n        }\n\n\n        throw (\"Unknown operation: \" + this.operation);\n    }\n\n\n    keywordValue(currentLength) {\n        if (this.variable === \"CurrentLength\")\n            return currentLength;\n        throw (\"Unknown keyword: \" + this.variable);\n    }\n\n\n    nameWithPopupValue( name ) {\n        try {\n            return '<span title=\"' + ( Math.round( this.value() * 1000 ) / 1000 ) + ' ' + this.pattern.units + '\">' + name + '</span>';\n        } catch ( e ) {\n            return \"ERROR1:\" + name;\n        }\n    }\n\n\n    html( asFormula, currentLength, parentPrecedence ) {\n\n        if ( ! asFormula )\n        {\n            try { \n                return this.value( currentLength );\n                //return Number.parseFloat( this.value( currentLength ) ).toPrecision(4); \n            } catch ( e ) {\n                return \"???\"\n            }\n        }\n\n        if ( this.variable )\n        {\n            if (this.variable === \"CurrentLength\")\n                return this.nameWithPopupValue( \"CurrentLength\" );\n\n            return this.nameWithPopupValue( this.variable.name );\n        }\n\n        if ( this.constant !== undefined )\n            return this.constant;\n\n        if ( this.function )\n        {\n            if ( this.function === \"lengthOfLine\" )\n                return this.nameWithPopupValue( \"lengthOfLine(\" + this.drawingObject1.ref() + \", \" + this.drawingObject2.ref() + \")\" );\n\n            if ( this.function === \"angleOfLine\" )\n                return this.nameWithPopupValue( \"angleOfLine(\" + this.drawingObject1.ref() + \", \" + this.drawingObject2.ref() + \")\" );\n\n            if (   ( this.function === \"lengthOfSpline\" )\n                || ( this.function === \"lengthOfSplinePath\" ) )\n            {\n                if ( ! this.drawingObject )\n                    return this.nameWithPopupValue( this.function + \"( curve:\" + this.splineDrawingObject.ref() + \", from:\" + this.drawingObject1.ref() + \", to:\" + this.drawingObject2.ref() + \")\" );\n                \n                return this.nameWithPopupValue( this.function + \"(\" + this.drawingObject.ref() + (this.segment?\", segment:\" + this.segment:\"\") + \")\" );\n            };\n\n            if (    ( this.function === \"angle1OfSpline\" )\n                 || ( this.function === \"angle2OfSpline\" ))\n            {\n                if ( ! this.drawingObject )\n                    return this.nameWithPopupValue( this.function + \"( curve:\" + this.splineDrawingObject.ref() + \", at:\" +\n                                            ((( this.splineDrawingObject.startPoint == this.drawingObject1 ) || ( this.splineDrawingObject.endPoint == this.drawingObject1 ))\n                                            ? this.drawingObject2.ref() : this.drawingObject1.ref() ) + \")\" );\n\n                return this.nameWithPopupValue( this.function + \"(\" + this.drawingObject.ref() + \")\" );\n            };            \n\n            if ( this.function === \"lengthOfArc\" )\n            {\n                if ( ! this.drawingObject )\n                    return \"lengthOfArc( ??? )\";\n                \n                return this.nameWithPopupValue( \"lengthOfArc(\" + this.arcSelection + \" \" + this.drawingObject.ref() + \")\" );\n            };\n\n            if ( this.function === \"radiusOfArc\" )\n            {\n                if ( ! this.drawingObject )\n                    return \"radiusOfArc( ??? )\";\n                \n                return this.nameWithPopupValue( \"radiusOfArc(\" + this.drawingObject.ref() + ( this.radiusSelection ? \", radius-\" + this.radiusSelection : \"\" ) + \")\" );\n            };            \n\n            if ( this.function === \"-\" )\n            {\n                return ( \"-(\" + this.params[0].html( asFormula, currentLength ) + \")\" ); \n            }       \n            \n            if (    ( this.function === \"sqrt\" )\n                 || ( this.function === \"sin\" )\n                 || ( this.function === \"cos\" )\n                 || ( this.function === \"tan\" ) \n                 || ( this.function === \"asin\" )\n                 || ( this.function === \"acos\" )\n                 || ( this.function === \"atan\" ) )\n            {\n                return ( this.function + \"(\" + this.params[0].html( asFormula, currentLength ) + \")\" ); \n            }\n\n            return \"UNKNOWN FUNCTION TYPE\" + this.function;\n        }\n\n        if ( this.operation === \"?\" )\n        {\n            return this.params[0].html( asFormula, currentLength ) + \" ? \" +\n                   this.params[1].html( asFormula, currentLength ) + \" : \" +\n                   this.params[2].html( asFormula, currentLength );\n        }\n        else if ( this.operation ) \n        {\n            var useOperatorNotation = false;\n            var precedence = 0;\n\n            if (    (this.operation === \"+\") \n                 || (this.operation === \"-\") )\n            {\n                useOperatorNotation = \" \" + this.operation + \" \";\n                precedence = 3;\n            }\n            else if (    (this.operation === \"/\") \n                      || (this.operation === \"*\") ) \n            {\n                useOperatorNotation = \" \" + this.operation + \" \";\n                precedence = 4;\n            }\n            else if (    (this.operation === \"==\") \n                      || (this.operation === \"!=\") \n                      || (this.operation === \">=\") \n                      || (this.operation === \"<=\") \n                      || (this.operation === \">\") \n                      || (this.operation === \"<\") )\n            {\n                useOperatorNotation = \" \" + this.operation + \" \";\n                precedence = 2;\n            }\n            //power = 5\n            //ternary = 2\n\n            var t = ( useOperatorNotation || this.operation === \"()\" ? \"\" : this.operation );\n            \n            var useParenthesis = ( ( this.operation === \"()\" ) || ( precedence < parentPrecedence ) || (!useOperatorNotation) );\n\n            if ( useParenthesis )\n                t += \"(\";\n\n            var first = true;\n            for ( var p in this.params )\n            {\n                if ( ! first )\n                {\n                    if ( useOperatorNotation )\n                        t += useOperatorNotation;\n                    else\n                        t += \",\";\n                }\n                t += this.params[p].html( asFormula, currentLength, precedence );\n                first = false;\n            }\n\n            if ( useParenthesis )\n                t += \")\";\n\n            return t;\n        }\n\n        return \"???\";\n    };\n\n\n    //The dependencies of this expression need adding to the source drawingObject that uses this expression\n    addDependencies( source, dependencies ) \n    {\n        if ( typeof this.drawingObject1 !== \"undefined\" )\n            dependencies.add( source, this.drawingObject1 );\n\n        if ( typeof this.drawingObject2 !== \"undefined\" )\n            dependencies.add( source, this.drawingObject2 );\n\n        if ( typeof this.splineDrawingObject !== \"undefined\" )\n            dependencies.add( source, this.splineDrawingObject );\n\n        if ( typeof this.drawingObject !== \"undefined\" ) //e.g. lengthOfArc\n            dependencies.add( source, this.drawingObject );\n\n        //variable or measurement\n        if (    ( typeof this.variable !== \"undefined\")\n             && (    ( this.variable.isMeasurement  )\n                  || ( this.variable.isVariable  ) ) )\n            dependencies.add( source, this.variable );\n\n        //recurse into the expression parameters.\n        if ( this.params )\n        {       \n            for (var a = 0; a < this.params.length; a++) {\n                var p = this.params[a];\n                p.addDependencies( source, dependencies );\n            }\n        }\n    }\n}\n\n\n","//(c) Copyright 2019 Jason Dore\n//https://github.com/MrDoo71/PatternEditor\n\nclass Bounds {\n    \n    constructor() {\n        this.minX = undefined;\n        this.maxX = undefined;\n        this.minY = undefined;\n        this.maxY = undefined;\n    }\n\n    adjust(p) {\n\n        if (!p)\n            return; //e.g. an error\n\n        this.adjustToIncludeXY( p.x, p.y );\n    }\n\n    adjustToIncludeXY( x, y ) {\n\n        if (x !== undefined) {\n            if ((this.minX === undefined) || (x < this.minX))\n                this.minX = x;\n            if ((this.maxX === undefined) || (x > this.maxX))\n                this.maxX = x;\n        }\n\n        if (y !== undefined) {\n            if ((this.minY === undefined) || (y < this.minY))\n                this.minY = y;\n            if ((this.maxY === undefined) || (y > this.maxY))\n                this.maxY = y;\n        }\n\n        if ( this.parent )\n            this.parent.adjustToIncludeXY( x,y );\n    }\n\n    adjustForLine(line) {\n\n        if (!line)\n            return;\n\n        this.adjust(line.p1);\n        this.adjust(line.p2);\n    }\n\n    diagonaglLength() {\n\n        var deltaX = ( this.maxX - this.minX );\n        var deltaY = ( this.maxY - this.minY );\n    \n        return Math.sqrt( Math.pow(deltaX,2) + Math.pow(deltaY,2) );\n    }\n}\n\n\n","//(c) Copyright 2019 Jason Dore\n//\n//This library collates the various geometric calclulation requirements\n//of the drawing objects into a small number of primitives. \n//\n//This library then generally uses other libraries to perform those \n//geometric calculations where they are non trivial\n//(e.g. intersection of lines with splines).\n//\n//Source maintained at: https://github.com/MrDoo71/PatternEditor\n\n//If making improvements also research:\n//https://github.com/DmitryBaranovskiy/raphael/blob/v2.1.1/dev/raphael.core.js#L1837\n//https://github.com/jarek-foksa/path-data-polyfill/blob/master/path-data-polyfill.js\n\n//import { Intersection, Point2D, ShapeInfo } from 'kld-intersections/dist/index-esm.js';\nimport { Intersection, Point2D, ShapeInfo } from '../node_modules/kld-intersections/dist/index-esm.js';\n\n\n//An arc of a circle\nclass GeoArc {\n\n    //center\n    //radius\n    //angle1 - degrees!\n    //angle2 - degrees!\n\n    constructor( center, radius, angle1 /*deg*/, angle2 /*deg*/ ) {\n        this.center = center;\n        this.radius = radius;\n        this.angle1 = angle1;\n        this.angle2 = angle2;\n\n        //Correct 180-0 to 180-360\n        if ( this.angle2 < this.angle1 )\n            this.angle2+=360;\n    }\n\n    //https://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes F.6.4 Conversion from center to endpoint parameterization\n    //Hashed together from https://stackoverflow.com/questions/30277646/svg-convert-arcs-to-cubic-bezier and https://github.com/BigBadaboom/androidsvg/blob/5db71ef0007b41644258c1f139f941017aef7de3/androidsvg/src/main/java/com/caverock/androidsvg/utils/SVGAndroidRenderer.java#L2889\n    asGeoSpline() {\n\n        var angleStartRad = this.angle1 / 360.0 * 2.0 * Math.PI;\n        var angleEndRad = this.angle2 / 360.0 * 2.0 * Math.PI;\n        var angleExtentRad = angleEndRad - angleStartRad;\n        var numSegments =  Math.ceil( Math.abs(angleExtentRad) * 2.0 / Math.PI); \n        var angleIncrement = angleExtentRad / numSegments;\n\n        var controlLength = 4.0 / 3.0 * Math.sin(angleIncrement / 2.0) / (1.0 + Math.cos(angleIncrement / 2.0));\n\n        var nodeData = [];\n\n        var node = {};\n        nodeData.push( node );\n\n        for (var i=0; i<numSegments; i++)\n        {\n            var angle = angleStartRad + i * angleIncrement;\n\n            var dx = Math.cos(angle) * this.radius;\n            var dy = Math.sin(angle) * this.radius;\n\n            if ( ! node.point )\n                node.point = new GeoPoint( this.center.x + dx , this.center.y - dy );\n\n            node.outControlPoint = new GeoPoint( this.center.x + dx - controlLength * dy, this.center.y - dy - controlLength * dx );\n\n            angle += angleIncrement;\n            dx = Math.cos(angle) * this.radius;\n            dy = Math.sin(angle) * this.radius;\n\n            node = {};\n            nodeData.push( node );\n            node.inControlPoint = new GeoPoint( this.center.x + dx + controlLength * dy, this.center.y - dy + controlLength * dx );\n            node.point = new GeoPoint( this.center.x + dx, this.center.y - dy );\n        }\n\n        return new GeoSpline( nodeData );\n    }\n\n\n    splineBetweenPoints( previousP, nextP )\n    {\n        return this.asGeoSpline().splineBetweenPoints( previousP, nextP );\n    }\n\n\n    /**\n     * Get the points on this arc where the tangents that go through\n     * the specified point touch this arc.\n     * \n     * @param {*} pointOnTangent \n     */\n    getPointsOfTangent( pointOnTangent ) {\n        //There is a right angle triangle where\n        //hypotenous is the line tangent-arc.center - known length\n        //lines tangent-p and p-center form a right angle.   p-center has length arc.radius\n        //cos(i) = arc.radius / tangent-arc.center\n        var radius  = this.radius;\n        var h       = new GeoLine( this.center, pointOnTangent );\n        var hLength = h.length;\n        var angle   = Math.acos( radius/hLength ); //Would be an error if hLength < radius, as this means pointOnTangent is within the circle. \n        var totalAngleR;\n\n        var tangentTouchPoints = [ this.center.pointAtDistanceAndAngleRad( radius, h.angle - angle ),\n                                   this.center.pointAtDistanceAndAngleRad( radius, h.angle + angle ) ];        \n        \n        return tangentTouchPoints;\n    }\n\n\n    svgPath() {\n\n        //TODO if this is a full circle we should really generate an svg circle rather than using a path\n\n        var arcPath = d3.path();\n\n        //arcPath.arc( this.center.x, this.center.y, \n        //             this.radius, \n        //             -this.angle1 * Math.PI / 180, -this.angle2 * Math.PI / 180, true );        \n\n        var a2 = this.angle2;\n\n        if ( a2 < this.angle1 )\n            a2 += 360;\n\n        arcPath.arc( this.center.x, this.center.y, \n                    this.radius, \n                    -this.angle1 * Math.PI / 180, -a2 * Math.PI / 180, true );\n             \n\n                     //console.log( \"Could have used d3:\", arcPath.toString() );\n        return arcPath.toString();\n\n        //var a2 = this.angle2;\n        //if ( this.angle2 < this.angle1 )\n        //    a2 = a2 + 360;\n\n        //THIS NOT WORKING\n        //var svgParams = this.centeredToSVG( this.center.x, this.center.y, this.radius, this.radius, -this.angle1, a2-this.angle1, 0 );\n        //var path = \"M\" + svgParams.x + \",\" + svgParams.y \n        //     + \"A\" + svgParams.rx + \",\" + svgParams.ry \n        //     + \",\" + svgParams.xAxisAngle + \",\" + svgParams.largeArc + \",\" + svgParams.sweep + \",\"\n        //     + svgParams.x1 + \",\" + svgParams.y1 \n        //\n        //console.log( \"svgPath() - \", path );\n\n        //return path;\n    }    \n\n    \n    pointAlongPath( length ) {\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        if ( length > path.getTotalLength() )\n            length = path.getTotalLength();\n        var p = path.getPointAtLength( length );\n        //console.log(p);      \n        return new GeoPoint( p.x, p.y );\n    }        \n\n    \n    pointAlongPathFraction( fraction ) {\n\n        if ( fraction == 0 )\n        {\n            return this.center.pointAtDistanceAndAngleDeg( this.radius, this.angle1 );\n        }\n\n        if ( fraction == 1 )\n        {\n            return this.center.pointAtDistanceAndAngleDeg( this.radius, this.angle2 );\n        }\n\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        var l = path.getTotalLength();\n        var p = path.getPointAtLength( l * fraction );\n        //console.log(p);      \n        return new GeoPoint( p.x, p.y );\n    }         \n    \n    \n    pathLength() {\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        return path.getTotalLength();\n    }             \n\n\n    asShapeInfo() {  \n        if (( this.angle1 == 0 ) && ( this.angle2 == 360 ))\n            return ShapeInfo.circle( this.center.x, this.center.y, this.radius );\n\n        //ShapeInfo angles seem to go clockwise from East, rather than our anti-clickwise angles\n        var angle1 = 360-this.angle2;\n        var angle2 = 360-this.angle1;\n\n        if ( angle1 < 0 )\n        {\n            angle1 += 360;\n            angle2 += 360;\n        }\n\n        //if ( angle2 < 0 )\n        //    angle2 += 360;\n\n        if ( angle2 < angle1 )\n            angle2 += 360;\n\n        //if ( angle2 > 360 ) //the original angle1 was negative. \n        //{\n        //    angle1 -= 360;\n        //    angle2 -= 360;\n        //}\n\n        //if ( angle1 < 0 )\n        //angle1 = 0;\n\n        //if ( angle2 < 0 )\n        //angle2 = 0;\n\n       // if ( angle2 < angle1 )\n       // {\n       //     var t = angle2;\n       //     angle2 = angle1;\n       //     angle1 = t;\n       // }\n                \n        return ShapeInfo.arc( this.center.x, this.center.y, this.radius, this.radius, angle1 * Math.PI/180, angle2 * Math.PI/180 );\n    }    \n\n\n    applyOperation( pointTransformer ) {//apply a operationFlip or operationRotate to this GeoArc\n        var center2 = pointTransformer( this.center );\n\n        //s = the point on the arc that we start drawing\n        var s = this.center.pointAtDistanceAndAngleDeg( this.radius, this.angle1 );\n        var s2 = pointTransformer( s );\n        var s2line = new GeoLine( center2, s2 );\n        var startAngle2 = s2line.angleDeg();\n\n        //f = the point on the arc that we finish drawing\n        var f = this.center.pointAtDistanceAndAngleDeg( this.radius, this.angle2 );\n        var f2 = pointTransformer( f );\n        var f2line = new GeoLine( center2, f2 );\n        var finishAngle2 = f2line.angleDeg();\n\n        //Because we've flipped the start angle becomes the finish angle and vice verasa.\n        return new GeoArc(  center2, this.radius, finishAngle2 /*deg*/, startAngle2 /*deg*/  );\n    }\n\n\n    adjustBounds( bounds ) {\n\n        //An arc, between 70, and 100 degrees would be bounded by the start and stop\n        //points and the point at 90 degrees. \n        var startPoint = this.pointAlongPathFraction(0);\n        var endPoint = this.pointAlongPathFraction(0);\n        bounds.adjust( startPoint );\n        bounds.adjust( endPoint );\n\n        if (( this.angle1 < 90 ) && ( this.angle2 > 90 ))        \n            bounds.adjustToIncludeXY( this.center.x, this.center.y - this.radius ); //add N\n\n        if (( this.angle1 < 180 ) && ( this.angle2 > 180 ))        \n            bounds.adjustToIncludeXY( this.center.x - this.radius, this.center.y ); //add W\n\n        if (( this.angle1 < 270 ) && ( this.angle2 > 270 ))        \n            bounds.adjustToIncludeXY( this.center.x, this.center.y + this.radius ); //add S\n\n        if (( this.angle1 < 360 ) && ( this.angle2 > 360 ))        \n            bounds.adjustToIncludeXY( this.center.x + this.radius, this.center.y ); //add E\n    }\n}\n\n\n","//(c) Copyright 2019 Jason Dore\n//\n//This library collates the various geometric calclulation requirements\n//of the drawing objects into a small number of primitives. \n//\n//This library then generally uses other libraries to perform those \n//geometric calculations where they are non trivial\n//(e.g. intersection of lines with splines).\n//\n//Source maintained at: https://github.com/MrDoo71/PatternEditor\n\n//import { Intersection, Point2D, ShapeInfo } from 'kld-intersections/dist/index-esm.js';\n\nclass GeoEllipticalArc {\n\n    constructor( center, radius1, radius2, angle1, angle2, rotationAngle ) {\n        this.center = center;\n        this.radius1 = radius1;\n        this.radius2 = radius2;\n        this.angle1 = angle1;\n        this.angle2 = angle2;\n        this.rotationAngle = rotationAngle;\n    }\n\n\n    clone() {\n        return new GeoEllipticalArc( this.center, \n                                     this.radius1, \n                                     this.radius2, \n                                     this.angle1,  \n                                     this.angle2,\n                                     this.rotationAngle );\n    }\n\n    //https://observablehq.com/@toja/ellipse-and-elliptical-arc-conversion\n    //http://xahlee.info/js/svg_path_ellipse_arc.html\n    //https://observablehq.com/@toja/ellipse-and-elliptical-arc-conversion\n    getEllipsePointForAngle(cx, cy, rx, ry, phi, theta) {\n        const { abs, sin, cos } = Math;\n        \n        //https://en.wikipedia.org/wiki/Ellipse#Polar_form_relative_to_focus\n        const radius=   ( rx * ry )\n                      / Math.sqrt( Math.pow( rx * Math.sin( theta ),2 ) + Math.pow( ry * Math.cos( theta ), 2 ) ); \n\n        const M = radius * cos(theta),\n              N = radius * sin(theta);  \n\n        return { x: cx + cos(phi) * M - sin(phi) * N,\n                 y: cy + sin(phi) * M + cos(phi) * N };\n     }\n\n\n    //TODO based on SVG book, but corrected\n    centeredToSVG( cx, cy, rx, ry, thetaDeg/*arcStart*/, deltaDeg/*arcExtent*/, phiDeg/*x axis rotation*/ ) {\n        var theta, endTheta, phiRad;\n        var largeArc, sweep;\n        theta = thetaDeg * Math.PI / 180;\n        endTheta = ( thetaDeg + deltaDeg ) * Math.PI / 180;\n        phiRad = phiDeg * Math.PI / 180;\n\n        //console.log( \"centeredToSVG thetaDeg: \" + thetaDeg );\n        //console.log( \"centeredToSVG deltaDeg: \" + deltaDeg );\n        //console.log( \"centeredToSVG endThetaDeg: \" + ( thetaDeg + deltaDeg ) );\n        //console.log( \"centeredToSVG endTheta: \" + endTheta );\n\n        var start = this.getEllipsePointForAngle(cx, cy, rx, ry, phiRad, theta);\n        var end = this.getEllipsePointForAngle(cx, cy, rx, ry, phiRad, endTheta);\n\n        //console.log( \"3. centeredToSVG x0,y0: \" + x0 + \",\" + y0 );\n        //console.log( \"3. centeredToSVG x1,y1: \" + x1 + \",\" + y1 );\n\n        largeArc = ( deltaDeg > 180 ) || ( deltaDeg < -180 ) ? 1 : 0;\n        sweep = ( deltaDeg > 0 ) ? 0 : 1;\n         \n        return { x: start.x,\n                 y: start.y,\n                rx: rx,\n                ry: ry,\n                xAxisAngle: phiDeg,\n                largeArc: largeArc,\n                sweep: sweep,\n                x1: end.x,\n                y1: end.y };\n    }    \n\n\n    useSvgEllipse() {\n        //we can use <ellipse> if it is a full ellipse, otherwise we need to use an elliptical arc path\n        if (    ( this.angle1 === 0 ) \n             && ( this.angle2 === 360 ) )\n            return true;\n\n        return false;\n    }\n\n\n    svgPath() {\n        // 90->180   -90 -> -180     -90,-90\n        // 0->90   -0 +-90\n\n\n\n        var d2 = this.centeredToSVG( this.center.x, this.center.y, this.radius1, this.radius2, 360-(this.angle1), -(this.angle2 - this.angle1), -this.rotationAngle );\n        var path = \"M\" + d2.x + \",\" + d2.y;\n        path += \" A\" + d2.rx + \" \" + d2.ry;\n        path += \" \" + d2.xAxisAngle;\n        path += \" \" + d2.largeArc + \",0\";// + d2.sweep;\n        path += \" \" + d2.x1 + \",\" + ( d2.y1 + (((d2.y===d2.y1)&&(d2.x===d2.x1))?0.001:0)  ) + \" \"; //we need to start/stop on a slightly different point\n        //The fudge above that allows the path to work even for a full ellipse should never be needed as if it is a full ellipse useSvgEllipse() should return true.\n\n        //console.log( \"GeoEllipticalArc: \" + path );\n\n        return path;\n    }\n\n\n    asShapeInfo() {\n        //TEMPORARY ON TRIAL - THIS WORKS, SO ROTATE TRANSLATE \n        //              cx, cy, rx, ry. start, end   \n        if ( this.rotationAngle === 0 )\n            return ShapeInfo.arc( this.center.x, this.center.y, this.radius1, this.radius2, this.angle1/180*Math.PI, this.angle2/180*Math.PI)\n\n        var svgPath = this.svgPath();\n        //console.log( \"EllipticalArc.asShapeInfo() this might not work for intersections... \" + svgPath );\n        return ShapeInfo.path( svgPath );\n    }\n    \n\n    asGeoSpline() {\n\n        //Un-rotate this if it is rotated\n        if ( this.rotationAngle !== 0 )\n        {\n            var center = this.center;\n            var rotationAngle = this.rotationAngle;\n            var unrotator = function( p ) {\n                return p.rotate( center, -rotationAngle );\n            };\n            var unrotatedArc = this.applyOperation( unrotator );\n\n            var unrotatedSplines = unrotatedArc.asGeoSpline();\n\n            var rerotator = function( p ) {\n                return p.rotate( center, rotationAngle );\n            };\n\n            return unrotatedSplines.applyOperation( rerotator );\n        }\n\n        //We won't be a rotated elipse. \n\n        var angleStartRad = this.angle1 / 360.0 * 2.0 * Math.PI;\n        var angleEndRad = this.angle2 / 360.0 * 2.0 * Math.PI;\n        var angleExtentRad = angleEndRad - angleStartRad;\n        var numSegments =  Math.ceil( Math.abs(angleExtentRad) * 2.0 / Math.PI); \n        var angleIncrement = angleExtentRad / numSegments;\n\n        var controlLength = 4.0 / 3.0 * Math.sin(angleIncrement / 2.0) / (1.0 + Math.cos(angleIncrement / 2.0));\n\n        var nodeData = [];\n\n        var node = {};\n        nodeData.push( node );\n\n        for (var i=0; i<numSegments; i++)\n        {\n            var angle = angleStartRad + i * angleIncrement;\n\n            var dxr1 = Math.cos(angle) * this.radius1;\n            var dxr2 = Math.cos(angle) * this.radius2;\n            var dyr1 = Math.sin(angle) * this.radius1;\n            var dyr2 = Math.sin(angle) * this.radius2;\n\n            if ( ! node.point )\n                node.point = new GeoPoint( this.center.x + dxr1 , this.center.y - dyr2 );\n\n            node.outControlPoint = new GeoPoint( this.center.x + dxr1 - controlLength * dyr1, this.center.y - dyr2 - controlLength * dxr2 );\n\n            angle += angleIncrement;\n            dxr1 = Math.cos(angle) * this.radius1;\n            dxr2 = Math.cos(angle) * this.radius2;\n            dyr1 = Math.sin(angle) * this.radius1;\n            dyr2 = Math.sin(angle) * this.radius2;\n\n            node = {};\n            nodeData.push( node );\n            node.inControlPoint = new GeoPoint( this.center.x + dxr1 + controlLength * dyr1, this.center.y - dyr2 + controlLength * dxr2 );\n            node.point = new GeoPoint( this.center.x + dxr1, this.center.y - dyr2 );\n        }\n\n        return new GeoSpline( nodeData );        \n    }\n\n\n    pointAlongPathFraction( fraction ) {\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        var l = path.getTotalLength();\n        var p = path.getPointAtLength( l * fraction );\n        //console.log(p);      \n        return new GeoPoint( p.x, p.y );\n    }       \n\n\n    pointAlongPath( length ) {\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        var p = path.getPointAtLength( length );\n        //console.log(p);      \n        return new GeoPoint( p.x, p.y );\n    }       \n\n\n    pathLength() {\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        return path.getTotalLength();\n    }             \n\n\n    applyOperation( pointTransformer ) { //apply a operationFlip or operationRotate to this GeoEllipticalArc\n\n        var center2 = pointTransformer( this.center );\n\n        //Converted start and finishing angles are calculated identically to a circle\n        //It doesn't matter from this perspective whether we use radius1 or radius2\n\n        //s = the point on the arc that we start drawing\n        var s = this.center.pointAtDistanceAndAngleDeg( this.radius1, this.angle1 + this.rotationAngle );\n        var s2 = pointTransformer( s );\n        var s2line = new GeoLine( center2, s2 );\n        var startAngle2 = s2line.angleDeg();\n\n        //f = the point on the arc that we finish drawing\n        var f = this.center.pointAtDistanceAndAngleDeg( this.radius1, this.angle2 + this.rotationAngle );\n        var f2 = pointTransformer( f );\n        var f2line = new GeoLine( center2, f2 );\n        var finishAngle2 = f2line.angleDeg();\n\n        //don't abritrarily convert 360 to 0. \n        if (( finishAngle2 === 0 ) && ( this.angle2 === 360 ))\n            finishAngle2 = 360;\n\n        if (( startAngle2 === 0 ) && ( this.angle1 === 360 ))\n            startAngle2 = 360;\n\n        //Is this a good enough test?\n        var isFlip = ( this.angle1 < this.angle2 ) != ( startAngle2 < finishAngle2 );\n\n        //This is an ellipse, so we also need to adjust the ellipse rotation. \n        var r = this.center.pointAtDistanceAndAngleDeg( this.radius1, this.rotationAngle );\n        var r2 = pointTransformer( r );\n        var r2line = new GeoLine( center2, r2 );\n        var rotationAngle2 = r2line.angleDeg() + ( isFlip ? 180 : 0 );\n\n        // + 180;\n        if ( rotationAngle2 >= 360 )\n            rotationAngle2 -= 360;\n\n        //finally, start and finish point angles are defined with respect to the rotation angle\n        startAngle2 -= rotationAngle2;\n        finishAngle2 -= rotationAngle2;\n\n        //If we've flipped the start angle becomes the finish angle and vice versa.\n        return new GeoEllipticalArc( center2, this.radius1, this.radius2, isFlip ? finishAngle2 : startAngle2/*deg*/, isFlip ? startAngle2 : finishAngle2/*deg*/, rotationAngle2 /*deg*/ )\n    }\n\n\n    adjustBounds( bounds ) {\n        //TODO determine the bounds for a similar non-rotated ellipse\n        //and rotate\n\n        bounds.adjust( this.pointAlongPathFraction( 0 ) );\n        bounds.adjust( this.pointAlongPathFraction( 0.25 ) );\n        bounds.adjust( this.pointAlongPathFraction( 0.5 ) );\n        bounds.adjust( this.pointAlongPathFraction( 0.75 ) );\n        bounds.adjust( this.pointAlongPathFraction( 1 ) );\n    }\n}\n\n","//(c) Copyright 2019 Jason Dore\n//\n//This library collates the various geometric calclulation requirements\n//of the drawing objects into a small number of primitives. \n//\n//This library then generally uses other libraries to perform those \n//geometric calculations where they are non trivial\n//(e.g. intersection of lines with splines).\n//\n//Source maintained at: https://github.com/MrDoo71/PatternEditor\n\n//import { Intersection, Point2D, ShapeInfo } from 'kld-intersections/dist/index-esm.js';\n\n\n//A line\nclass GeoLine {\n\n    //p1;\n    //p2;\n\n    constructor( p1, p2 ) {\n\n        if ( ! p1 )\n            throw \"GeoLine p1 not defined.\";\n\n        if ( ! p2 )\n            throw \"GeoLine p2 not defined.\";\n\n        this.p1 = p1;//new GeoPoint( x1, y1 );\n        this.p2 = p2;//new GeoPoint( x2, y2 );\n    \n        this.deltaX = ( this.p2.x - this.p1.x ); //nb. +ve to the east from p1 to p2\n        this.deltaY = ( this.p2.y - this.p1.y ); //nb +ve to the south from p1 to p2\n    \n        this.length = Math.sqrt( Math.pow(this.deltaX,2) + Math.pow(this.deltaY,2) );\n\n        //angle is anti-clockwise starting east in radians\n        this.angle = Math.atan2( -this.deltaY, this.deltaX );\n\n        if ( this.angle < 0 )\n            this.angle = this.angle + (2 * Math.PI);          \n    \n        //alert( \"Line angle:\" + this.angle + \" (\" + ( this.angle / (2*Math.PI) * 360) + \"deg anti clockwise from east\" );\n    \n        this.slope  = ( this.deltaY / this.deltaX );\n        this.offset = this.p1.y - ( this.p1.x * this.slope ); //the y values where x = 0; the intersection of the line with the y-axis\n        //this line is generically: y = offset + ( x * slope )\n    }\n\n    //Return a GeoPoint for the intersection of this line with line2. \n    intersect( line2 ) {    \n        //intersection\n        //  // offset - line2.offset / ( line2.slope - slope ) = x\n\n        var swap = Math.abs( this.deltaX ) > Math.abs( line2.deltaX );\n        var line1s = swap ? this : line2; //this.p1.x < this.p2.x ? this : new GeoLine( this.p2, this.p1 );\n        var line2s = swap ? line2 : this; //line2.p1.x < line2.p2.x ? line2 : new GeoLine( line2.p2, line2.p1 );\n\n        var x, y;\n\n        if (    ( line2s.slope === Infinity ) \n             || ( line2s.slope === -Infinity )  )\n            x = line2s.p1.x;\n        else\n            x = ( line1s.offset - line2s.offset ) / ( line2s.slope - line1s.slope );\n\n        if ( line1s.slope === 0 )\n            y = line1s.p1.y;\n        else\n            y = line1s.p1.y + ( line1s.slope * ( x - line1s.p1.x ) );\n\n        return new GeoPoint(x,y);\n\n        //Using the Intersection libary requires that the finite lines intersect, rather than\n        //their infinite versions. \n        //var line1SI = this.asShapeInfo();\n        //var line2SI = line2.asShapeInfo();\n        //var intersections = Intersection.intersect(line1SI, line2SI);        \n        //intersections.points.forEach(console.log);    \n        //return new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n    }    \n\n\n    //Return a GeoPoint for where this line intersects the specified GeoArc, GeoEllipticalArc, or GeoSpline.\n    intersectArc( arc, alreadyTweaked ) { \n        //work around a bug where the arc spans 0 deg\n        if (    ( arc.angle1 < 0 ) \n             && ( arc.angle2 > 0 ) \n             && ( arc instanceof GeoArc ) ) //not an elliptical\n        {\n            try { \n                var arc1 = new GeoArc( arc.center, arc.radius, 0, arc.angle2 );\n                return this.intersectArc( arc1 );\n            } catch ( e ) {\n                var arc2 = new GeoArc( arc.center, arc.radius, arc.angle1 + 360, 360 );\n                return this.intersectArc( arc2 );\n            }\n        }\n        if (    ( arc.angle1 < 360 ) \n             && ( arc.angle2 > 360 ) \n             && ( arc instanceof GeoArc ) ) //not an elliptical\n        {\n            try { \n                var arc1 = new GeoArc( arc.center, arc.radius, 0, arc.angle2 -360 );\n                return this.intersectArc( arc1 );\n            } catch ( e ) {\n                var arc2 = new GeoArc( arc.center, arc.radius, arc.angle1, 360 );\n                return this.intersectArc( arc2 );\n            }\n        }\n\n        var arcSI,lineSI;\n\n        //nb there is a special case for GeoEllipticalArc where this.p1 == arc.center in \n        //which case a simple formula gives the intersect.\n\n        if (( arc instanceof GeoEllipticalArc ) && ( arc.rotationAngle !== 0 ))\n        {            \n            //console.log(\"elliptical arc \");\n            \n            //create an equivalent arc that is not rotated.\n            //create a new line, rotate the startpoint by -rotationAngle, the new lines angle should also be less by -rotationAngle\n            //finally rotate the intersect point back\n            var nrArc = new GeoEllipticalArc( arc.center,\n                                              arc.radius1,\n                                              arc.radius2, \n                                              arc.angle1, \n                                              arc.angle2,\n                                              0 );\n            var p1rotated = this.p1.rotate( arc.center, -arc.rotationAngle );\n            //var p2rotated = this.p2.rotate( arc.center, -arc.rotationAngle );\n            var bounds = new Bounds();\n            bounds.adjust( p1rotated );\n            arc.adjustBounds( bounds );\n            maxLineLength = bounds.diagonaglLength() * 1.25;\n            var lineRotated = new GeoLine( p1rotated, p1rotated.pointAtDistanceAndAngleDeg( maxLineLength/*infinite*/, (this.angleDeg() - arc.rotationAngle) ) );     \n            //var lineRotated = new GeoLine( p1rotated, p2rotated );\n            lineSI = lineRotated.asShapeInfo();\n            arcSI = nrArc.asShapeInfo();\n            \n            //var extendedLine = new GeoLine( lineRotated.p1.pointAtDistanceAndAngleRad( -1000/*infinite*/, lineRotated.angle ), lineRotated.p2 );\n            //lineSI = extendedLine.asShapeInfo();    \n        }\n        else\n        {\n            var bounds = new Bounds();\n            bounds.adjust( this.p1 );\n            //bounds.adjust( this.p2 );\n            arc.adjustBounds( bounds );\n            var maxLineLength = bounds.diagonaglLength() * 1.25;\n            \n            //This should be sufficient, extend our line forward enough that it should intersect...\n            //var extendedLine = new GeoLine( this.p1, this.p1.pointAtDistanceAndAngleRad( maxLineLength*10, this.angle ));\n\n            //Ensure that the line is long enough to intersect. \n            //var extendedLine = new GeoLine(  this.p1.pointAtDistanceAndAngleRad( -maxLineLength, this.angle ), this.p1.pointAtDistanceAndAngleRad( maxLineLength, this.angle ));  \n            var extendedLine = new GeoLine( this.p1, this.p1.pointAtDistanceAndAngleRad( maxLineLength, this.angle ));  \n\n            arcSI = arc.asShapeInfo();\n            lineSI = extendedLine.asShapeInfo();    \n        }\n    \n        var intersections = Intersection.intersect(arcSI, lineSI);\n        \n        //console.log( \"Intersections:\" );\n        //intersections.points.forEach(console.log);    \n\n        if ( intersections.points.length === 0 )\n        { \n            if ( ! alreadyTweaked )\n            {\n                //console.log( \"Failed for angle \", this.angle );\n                //console.log( \"PI:\", this.angle/Math.PI );\n                var lineTweaked = new GeoLine( this.p1, this.p1.pointAtDistanceAndAngleRad( this.length, this.angle + (Math.PI/180 * 0.0000000001) )); //Adding a billionth of a degree fixes the broken intersection issue.\n                return lineTweaked.intersectArc( arc, true );\n            }\n            throw \"No intersection with arc. \";\n        }\n\n        var whichPoint = 0;\n        if ( intersections.points.length > 1 )//-1;//0; //0 for G1 in headpattern. //intersections.points.length -1; //TODO do this properly\n        {            \n            if ( false )\n            {\n                //choose the point with the smallest angle. \n                var smallestAngle = 361;\n                for (var i = 0; i < intersections.points.length; i++) \n                {\n                    var pi = intersections.points[i];\n                    var p1pi = new GeoLine( arc.center, pi );\n                    console.log( i + \" \" + p1pi.angleDeg() );\n                    if ( p1pi.angleDeg() < smallestAngle )\n                    {\n                        smallestAngle = p1pi.angleDeg();\n                        whichPoint = i;\n                    }\n                }\n            }\n            else\n            {\n                //choose the first point we get to along the line. \n                var smallestDistance = undefined;\n                for (var i = 0; i < intersections.points.length; i++) \n                {\n                    var pi = intersections.points[i];\n                    var p1pi = new GeoLine( this.p1, pi );\n                    //console.log( i + \" \" + p1pi.length );\n                    if (    ( smallestDistance === undefined ) \n                         || (    ( Math.abs( p1pi.angle - this.angle ) < 0.0001 ) //rather than 180 deg the other way (allowing for rounding errors)\n                              && ( p1pi.length < smallestDistance ) ) )\n                    {\n                        smallestDistance = p1pi.length;\n                        whichPoint = i;\n                    }\n                }            \n            }\n        }\n\n        var intersect = new GeoPoint( intersections.points[whichPoint].x, intersections.points[whichPoint].y );\n\n        if (( arc instanceof GeoEllipticalArc ) && ( arc.rotationAngle !== 0 ))\n        {\n            intersect = intersect.rotate( arc.center, +arc.rotationAngle );\n        }\n\n        return intersect;\n    }\n\n\n    //Return a GeoLine having applied the operationFlip or operationRotate to this GeoLine.\n    applyOperation( pointTransformer ) {\n        var p1Transformed = pointTransformer( this.p1 );\n        var p2Transformed =  pointTransformer( this.p2 );\n        return new GeoLine( p1Transformed, p2Transformed );\n    }    \n\n\n    asShapeInfo() {\n        return ShapeInfo.line( this.p1.x, this.p1.y, this.p2.x, this.p2.y );\n    }\n\n\n    angleDeg() {\n        /*\n        var deltaX = (this.p2.x - this.p1.x);\n        var deltaY = -1 * (this.p2.y - this.p1.y); //-1 because SVG has y going downwards\n\n        //if ( deltaX === 0 )\n        //    return deltaY > 0 ? 90 : 270;\n\n        return Math.atan2( deltaY, deltaX ) * 180 / Math.PI;\n        */\n       return this.angle * 180 / Math.PI;\n    }\n\n\n    angleRad() {\n        return this.angle;\n    }\n\n\n    getLength() {\n        return this.length;\n    }\n\n\n    pointAlongPathFraction( fraction ) {\n        if ( fraction == 0 )\n            return this.p1;\n\n        if ( fraction == 100 )\n            return this.p2;\n\n        return new GeoPoint( ( this.p2.x - this.p1.x ) * fraction + this.p1.x,\n                             ( this.p2.y - this.p1.y ) * fraction + this.p1.y );\n    }\n}\n\n","//(c) Copyright 2019 Jason Dore\n//\n//This library collates the various geometric calclulation requirements\n//of the drawing objects into a small number of primitives. \n//\n//This library then generally uses other libraries to perform those \n//geometric calculations where they are non trivial\n//(e.g. intersection of lines with splines).\n//\n//Source maintained at: https://github.com/MrDoo71/PatternEditor\n\n//import { Intersection, Point2D, ShapeInfo } from 'kld-intersections/dist/index-esm.js';\n\n//A point\nclass GeoPoint {\n\n    //x;\n    //y;\n\n    constructor( x, y ) {\n        this.x = x;\n        this.y = y;\n\n        if ( isNaN( this.x ) )\n            throw \"GeoPoint x not a number.\";\n            \n        if ( isNaN( this.y ) )\n            throw \"GeoPoint y not a number.\";\n    }\n\n    line( point2 ) {    \n        throw \"this looks broken, two params, not four\";\n        return new GeoLine( this.x, this.y, point2.x, point2.y );\n    }\n\n\n    pointAtDistanceAndAngleRad( length, angle /*radians anti-clockwise from east*/ ) {        \n        var x = this.x + length * Math.cos( -1 * angle ); //TODO this is a guess!\n        var y = this.y + length * Math.sin( -1 * angle );   \n        return new GeoPoint( x, y );\n    }\n\n\n    pointAtDistanceAndAngleDeg( length, angle /*deg anti-clockwise from east*/ ) {        \n        return this.pointAtDistanceAndAngleRad( length, angle * Math.PI / 180 );\n    }\n\n\n    rotate( center, rotateAngleDeg ) {\n        //Convert degrees to radians\n        \n        var centerToSourceLine = new GeoLine( center, this );\n        var distance = centerToSourceLine.getLength();\n        var angle = centerToSourceLine.angleDeg() + rotateAngleDeg;\n\n        var result = center.pointAtDistanceAndAngleDeg( distance, angle );\n        return result;\n    }\n\n\n    asPoint2D() {\n        return new Point2D( this.x, this.y );\n    }\n\n\n    equals( p )\n    {\n        return this.x === p.x && this.y === p.y;\n    }\n\n\n    toString()\n    {\n        return \"(\" + Math.round(this.x*100)/100 + \",\" + Math.round(this.y*100)/100 + \")\";\n    }\n}\n\n","//(c) Copyright 2019 Jason Dore\n//\n//This library collates the various geometric calclulation requirements\n//of the drawing objects into a small number of primitives. \n//\n//This library then generally uses other libraries to perform those \n//geometric calculations where they are non trivial\n//(e.g. intersection of lines with splines).\n//\n//Source maintained at: https://github.com/MrDoo71/PatternEditor\n\n//import { Intersection, Point2D, ShapeInfo } from 'kld-intersections/dist/index-esm.js';\n\n\n\n\n\n\nclass GeoSpline {\n\n    //nodeData - an array of\n    //{ \n    //  inAngle  : deg\n    //  inLength : \n    //  point    : \n    //  outAngle : deg\n    //  outLength:  \n    //} \n\n    constructor( nodeData ) {\n        this.nodeData = nodeData;\n\n        for( var i in this.nodeData )\n        {\n            var n = this.nodeData[i];\n\n            if (( ! n.outControlPoint ) && ( typeof n.outAngle === \"number\" ) && ( typeof n.outLength === \"number\" ))\n                n.outControlPoint = n.point.pointAtDistanceAndAngleDeg( n.outLength, n.outAngle );\n\n            if (( ! n.inControlPoint ) && ( typeof n.inAngle === \"number\" ) && ( typeof n.inLength === \"number\" ))\n                n.inControlPoint = n.point.pointAtDistanceAndAngleDeg( n.inLength, n.inAngle );\n        }\n    }\n\n\n    applyOperation( pointTransformer ) { //apply a operationFlip or operationRotate to this GeoSpline\n        var nodeData = [];\n        for ( var i=0; i<this.nodeData.length; i++ )\n        {\n            var node = this.nodeData[i];\n\n            //Need a control point, not a length and angle. \n            var inPoint = node.inControlPoint;\n            var outPoint = node.outControlPoint;\n            \n            if ( ( ! inPoint ) && ( node.inLength !== undefined ) )            \n                inPoint = node.point.pointAtDistanceAndAngleDeg( node.inLength, node.inAngle );\n\n            if ( ( ! outPoint ) && ( node.outLength !== undefined ) )\n                outPoint = node.point.pointAtDistanceAndAngleDeg( node.outLength, node.outAngle );\n    \n            var inPointTransformed = inPoint === undefined ? undefined : pointTransformer( inPoint );\n            var outPointTransformed =  outPoint === undefined ? undefined : pointTransformer( outPoint );\n\n            nodeData.push( {inControlPoint:   inPointTransformed,\n                            point:            pointTransformer( node.point ),\n                            outControlPoint:  outPointTransformed } ) ;\n        }\n        return new GeoSpline( nodeData );\n    }\n\n\n    svgPath( continuePath ) {\n        var nodeData = this.nodeData;\n        var path = continuePath ? continuePath : \"\";\n        for ( var i=0; i<nodeData.length; i++ )\n        {\n            if ( i===0 )\n            {\n                path+= ( continuePath ? \"L\" : \"M\" ) + Math.round( nodeData[i].point.x *1000 )/1000 + \",\" + Math.round( this.nodeData[i].point.y *1000)/1000 ;\n            }\n            else\n            {\n                var controlPoint1 = ( typeof nodeData[i-1].outControlPoint !== \"undefined\" ) ? nodeData[i-1].outControlPoint\n                                                                                             : nodeData[i-1].point.pointAtDistanceAndAngleDeg( nodeData[i-1].outLength, nodeData[i-1].outAngle );\n\n                var controlPoint2 = ( typeof nodeData[i].inControlPoint !== \"undefined\" ) ? nodeData[i].inControlPoint\n                                                                                          : nodeData[i].point.pointAtDistanceAndAngleDeg( nodeData[i].inLength, nodeData[i].inAngle );\n\n                path += \"C\" + Math.round( controlPoint1.x * 1000 ) / 1000 + \",\" + Math.round( controlPoint1.y * 1000 ) / 1000 +\n                        \" \" + Math.round( controlPoint2.x * 1000 ) / 1000 + \",\" + Math.round( controlPoint2.y * 1000 ) / 1000 +\n                        \" \" + Math.round( nodeData[i].point.x * 1000 ) / 1000 + \",\" + Math.round( nodeData[i].point.y * 1000 ) / 1000 + \" \";\n            }\n        }\n        //console.log( \"GeoSpline: \" + path );\n        return path;\n    }\n\n\n    reverse()\n    {\n        var len = this.nodeData.length;\n        var revNodeData = [len];\n        for ( var i=0; i<len; i++ )\n        {\n            var node = this.nodeData[i];\n\n            revNodeData[len-i-1] =  { inControlPoint:   node.outControlPoint,\n                                      point:            node.point,\n                                      outControlPoint:  node.inControlPoint };\n        }\n        return new GeoSpline( revNodeData );\n    }\n\n\n    asShapeInfo() {\n        return ShapeInfo.path( this.svgPath() );\n    }\n    \n\n    pointAlongPathFraction( fraction ) {\n\n        if ( fraction == 0 )\n            return this.nodeData[0].point;\n\n        if ( fraction == 100 )\n            return this.nodeData[ this.nodeData.length-1 ].point;\n\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        var l = path.getTotalLength();\n        var p = path.getPointAtLength( l * fraction );\n\n        //Note, we cannot, even if a single segment use this.getPointForT() because\n        //length is not linear with t.\n        //\n        //If we want to do the calculation ourselves it will by treating the curve\n        //as 50 or so little lines using this.getPointForT() and using the length of\n        //those lines. \n\n        return new GeoPoint( p.x, p.y );\n    }       \n\n\n    pointAlongPath( length ) {\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        var xy = path.getPointAtLength( length );    \n        var p = new GeoPoint( xy.x, xy.y );\n\n        //If we want to do the calculation ourselves: \n        //iterate over the segments, adding their length to the total\n        //if a segment would blow the total, then instead guess a value \n        //of t for the last bit of length required. Return the point appropriate to that t. \n        //t = 0\n        //g = 0.01\n        //lastP = nodeData[0].point;\n        //for( var t=0.0; t<1.0; t+=g )\n        //   nextP = this.getPointForT( t + g );\n        //   lineLength = \n        //   totalLength += lineLength\n        //   if ( totalLength > length )\n        //      return a point along this last line. \n\n        //let's cross check!\n        if ( this.nodeData.length === 2 )\n        {\n            var t = this.findTForPoint( p );\n\n            if ( t === undefined )\n                console.log(\"ERROR: Result of pointAlongPath() is not on path?\" );\n        }\n        else\n        {\n            var cut = this.cutAtPoint( p );\n            if ( cut === undefined )\n                console.log(\"ERROR: Result of pointAlongPath() is not on path?\" );\n        }\n\n        return p;\n    }\n\n\n    pathLengthAtPoint( p ) {\n        //do a binary search on the length of the curve to find out best % along curve that is our intersection point. \n\n        var firstNode = this.nodeData[0].point;\n        if (    ( p.x === firstNode.x )\n             && ( p.y === firstNode.y ) )\n             return 0;\n\n        var lastNode = this.nodeData[ this.nodeData.length -1 ].point;\n        if (    ( p.x === lastNode.x )\n             && ( p.y === lastNode.y ) )\n             return this.pathLength();\n\n        var cutSpline = this.cutAtPoint( p ).beforePoint;\n\n        return cutSpline.pathLength();\n    }\n\n\n    findTForPoint(p) {\n        //only where nodeData.length == 2\n        //sometimes we're testing whether point p is on the arc. \n\n        if ( this.nodeData.length !== 2 )\n            throw \"findTForPoint() only supported for individual segments\";\n\n        //We could do this for each segnment and instantly dismiss any segment where p not in the box bounded by\n        //the polygon nodeDate[0].point, nodeData[0].outControlPoint, nodeData[1].inControlPoint, nodeData[1].point. \n\n        //TODO special handing for where p is either nodeData[0 or 1].point return 0 or 1\n        //if ( )\n\n        //TODO we can shortcut and return undefined if p is outside the binding box\n\n\n        var minT = 0.0,\n            maxT = 1.0,\n            iter = 0,\n            threshold = this.pathLength() / 1000;\n\n        var t;\n        while( iter < 20 ) { //after 20 iterations the interval will be tiny\n            iter++;\n            var closestT = null;\n            var closestDistance = undefined;\n            var interval = (maxT - minT)/4; //0.25 first time around.\n            for( t = minT; t<=maxT; t+= interval ) //five iterations the first time, 0, 0.25, 0.5, 0.75, 1.0\n            {\n                var pt = this.getPointForT( t );\n                var d = Math.sqrt( Math.pow( pt.x - p.x, 2) + Math.pow( pt.y - p.y, 2) );\n                if (( closestDistance === undefined ) || ( d < closestDistance ))\n                {\n                    closestT = t;\n                    closestDistance = d;\n                }\n\n                if (( d === 0 ) || ( d < threshold )) \n                {\n                    //console.log( \"i:\" + iter + \" t:\" + t + \" d:\" + d + \" FOUND\" );\n                    if (( t > 1 ) || ( t < 0 ))\n                        return undefined; //they are probably on another segment\n\n                    return t;\n                }\n\n            }\n            minT = closestT - interval; //So at the end of iteration 1 we'll be setting up a span next time that is 0.5 wide, which we'll cut into five slots \n            maxT = closestT + interval;\n            //console.log( \"i:\" + iter + \" minT:\" + minT + \" maxT:\" + maxT + \" closestT:\" + closestT + \" threshold:\" + threshold + \" closestDistance: \" + closestDistance  );\n        }\n        //console.log(\"Point not on curve.\" );\n        if (( t > 0 ) && ( t < 1 ))\n            return t; \n\n        return undefined;\n    }\n\n    pathSegment( segment ) {\n        if ( ! segment )\n            return this;\n\n        //Create a shorter path\n        var startNode = this.nodeData[ segment -1 ];\n        var endNode = this.nodeData[ segment ];\n        var shorterPath = new GeoSpline( [ startNode, endNode ] );\n        return shorterPath;\n    }\n\n    pathLength( segment ) {\n\n        if ( segment ) {\n            return this.pathSegment(segment).pathLength();\n        }\n\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        return path.getTotalLength();\n    }\n\n\n    splineBetweenPoints( p1, p2 )\n    {\n        var c1 = this.cutAtPoint( p1 );\n        var c2 = this.cutAtPoint( p2 );\n\n        if ( c1 === undefined )\n            throw \"p1 is not on spline;\"\n\n        if ( c2 === undefined )\n            throw \"p2 is not on spline;\"\n\n        //For each segment, determine t for each of p1 and p2\n        //the first one we find is the first point. \n        \n        //TODO this can be optimised here. \n\n        //We can avoid the more expensive pathLength() if we can see that one of \n        //the points is in an earlier segment. \n        var s1 = c1.beforePoint == null ? 0 : c1.beforePoint.nodeData.length;\n        var s2 = c2.beforePoint == null ? 0 : c2.beforePoint.nodeData.length;\n        var swap = s1 > s2;\n\n        if ( s1 == s2 )\n        {\n            //nb we have seen the pathLength() not produce a correct result.  Returns >3000 when this.pathLength = 60.  \n            var d1 = c1.beforePoint == null ? 0 : c1.beforePoint.pathLength();\n            var d2 = c2.beforePoint == null ? 0 : c2.beforePoint.pathLength();\n            swap = d1 > d2;\n        }\n\n        if ( swap )\n        {\n            var t = p2;\n            p2 = p1;\n            p1 = t;\n            c1 = c2;\n        }\n\n        var cut1 = c1;\n        var splineAfterPoint = cut1.afterPoint;\n        var c3 = splineAfterPoint.cutAtPoint( p2 );\n        if ( ! c3 )\n            console.log(\"c3 not found\"); //this is odd because c1 and c2 were found\n        var cut2 = c3 ? c3.beforePoint : splineAfterPoint;\n        return cut2;\n    }\n\n\n    //https://pomax.github.io/bezierinfo/chapters/decasteljau/decasteljau.js\n    getStrutPoints(t) {\n        return this.applyDecasteljau(t).strutPoints;\n    }\n\n    getPointForT(t) {\n        return this.applyDecasteljau(t).point;\n    }\n\n    \n    //private\n    applyDecasteljau(t) {\n        //only valid where nodeData.length === 2\n        if ( this.nodeData.length !== 2 )\n            throw( \"applyDecasteljau only valid for a segment\" );\n\n        var points = [ this.nodeData[0].point, this.nodeData[0].outControlPoint, this.nodeData[1].inControlPoint, this.nodeData[1].point ];\n        var strutPoints = [];\n\n        for( var i=0; i<points.length; i++ )\n            strutPoints.push( points[i] );\n\n        while( points.length > 1 )\n        {\n            var newPoints = [];\n            for( var i=0; i<points.length-1; i++ )\n            {\n                if ( points[i+1] === undefined  )\n                    console.log(\"how?\");\n\n                var newPoint = new GeoPoint( (1-t) * points[i].x + t * points[i+1].x,\n                                             (1-t) * points[i].y + t * points[i+1].y );\n                newPoints.push( newPoint );\n                strutPoints.push( newPoint );\n            }\n            points = newPoints;\n        }\n\n        return { strutPoints:strutPoints, point:points[0] };\n    }    \n\n\n    //Returns { beforePoint: a GeoSpline, afterPoint: a GeoSpline } //though either may be null\n    //https://pomax.github.io/bezierinfo/#splitting\n    cutAtPoint( p ) { \n        const nodeData = this.nodeData;\n\n        //The simplest spline with its two control points. \n        if ( nodeData.length === 2 )\n        {\n            if ( ! nodeData[1].point )\n                console.log(\"no point?\");\n\n            if ( nodeData[0].point.equals(p) ) \n                return { beforePoint: null,\n                         afterPoint : this };\n            else if ( nodeData[1].point.equals(p) ) \n                return { beforePoint: this,\n                         afterPoint : null };\n            else {\n                const t = this.findTForPoint(p);\n                if ( t === undefined )\n                    return undefined;\n\n                return this.cutAtT( t );\n            }\n        }\n\n        var nodesBeforeCut = [],\n            nodesAfterCut = [];\n\n        var cutMade = false;\n        for( var i=0; i<(nodeData.length-1); i++ )\n        {\n            var n1 = nodeData[i];\n            var n2 = i+1 < nodeData.length ? nodeData[i+1] : null;\n\n            if ( cutMade ) \n            {\n                nodesAfterCut.push( n1 );\n            }\n            else if ( n1.point.equals(p) )  \n            {\n                cutMade = true;\n                nodesBeforeCut.push( n1 );\n                nodesAfterCut.push( n1 );\n            }\n            else if ( n2.point.equals(p) )\n            {\n                cutMade = true;\n                nodesBeforeCut.push( n1 );\n                nodesBeforeCut.push( n2 );\n            }\n            else\n            {\n                var segment = this.pathSegment( i+1 ); //so from i to i+1\n                var tWithinSegment = segment.findTForPoint(p);                    \n\n                if ( tWithinSegment === 0 ) //effectively ( n1.point.equals(p) ), it must have been a rounding issue that prevented an exact match.\n                {\n                    cutMade = true;\n                    nodesBeforeCut.push( n1 );\n                    nodesAfterCut.push( n1 );    \n                }\n                else if ( tWithinSegment === 1) //effectively ( n2.point.equals(p) ), it must have been a rounding issue that prevented an exact match.\n                {\n                    cutMade = true;\n                    nodesBeforeCut.push( n1 );\n                    nodesBeforeCut.push( n2 );\n                }\n                else \n                {\n                    var pointLiesInThisSegment = tWithinSegment !== undefined;\n\n                    if ( ! pointLiesInThisSegment )\n                    {\n                        if ( ! cutMade )\n                            nodesBeforeCut.push(n1);\n\n                        if ( cutMade )\n                            nodesAfterCut.push(n1);\n                    }\n                    else //point lies in this segment\n                    {\n                        var splits = segment.cutAtT( tWithinSegment );\n\n                        splits.beforePoint.nodeData[0].inControlPoint = n1.inControlPoint;\n                        splits.beforePoint.nodeData[0].inAngle = n1.inAngle;\n                        splits.beforePoint.nodeData[0].inLength = n1.inLength;\n                        nodesBeforeCut.push( splits.beforePoint.nodeData[0] );\n                        nodesBeforeCut.push( splits.beforePoint.nodeData[1] );\n\n                        splits.afterPoint.nodeData[1].outControlPoint = n2.outControlPoint;\n                        splits.afterPoint.nodeData[1].outAngle = n2.outAngle;\n                        splits.afterPoint.nodeData[1].outLength = n2.outLength;\n                        nodesAfterCut.push( splits.afterPoint.nodeData[0] );\n                        nodesAfterCut.push( splits.afterPoint.nodeData[1] );\n                        i++; //because we've done n2 effectively\n                        cutMade = true;\n                    }\n                }\n            }\n        }\n\n        return { beforePoint: nodesBeforeCut.length < 2 ? null : new GeoSpline(nodesBeforeCut),\n                 afterPoint : nodesAfterCut.length < 2 ? null : new GeoSpline(nodesAfterCut) };\n    }\n\n\n    cutAtT( t )\n    {    \n        if ( t === 0 ) \n            return { beforePoint: null,\n                     afterPoint : this };\n        else if ( t === 1 ) \n            return { beforePoint: this,\n                     afterPoint : null };\n\n        const struts = this.getStrutPoints( t );\n\n        const c1n1 = this.createNodeData( undefined, struts[0], struts[4] );\n        const c1n2 = this.createNodeData( struts[7], struts[9], undefined );\n        const c2n1 = this.createNodeData( undefined, struts[9], struts[8] );\n        const c2n2 = this.createNodeData( struts[6], struts[3], undefined );\n                    \n        return { beforePoint: new GeoSpline( [c1n1,c1n2] ),\n                 afterPoint : new GeoSpline( [c2n1,c2n2] ) };            \n    }    \n\n\n    createNodeData( inControlPoint, point, outControlPoint ) \n    {\n        const c = { inControlPoint:  inControlPoint,\n                    point:           point,\n                    outControlPoint: outControlPoint };\n\n        if ( inControlPoint )\n        {\n            var inControlPointLine = new GeoLine( point, inControlPoint );\n            c.inAngle = inControlPointLine.angleDeg();\n            c.inLength = inControlPointLine.getLength();\n        }\n        if ( outControlPoint )\n        {\n            var outControlPointLine = new GeoLine( point, outControlPoint );    \n            c.outAngle = outControlPointLine.angleDeg();\n            c.outLength = outControlPointLine.getLength();\n        }\n\n        return c;\n    }    \n\n\n    adjustBounds( bounds ) {\n\n        //It won't be a perfectly tight bounding box, but \n        //it should be ample to encompass the spline loosely. \n        \n        for ( var i=0; i<this.nodeData.length; i++ )\n        {\n            var node = this.nodeData[i];\n\n            bounds.adjust( node.point );\n\n            if ( node.inControlPoint )\n                bounds.adjust( node.inControlPoint );\n\n            if ( node.outControlPoint )\n                bounds.adjust( node.outControlPoint );\n        }\n    }\n\n\n    //The direction we are travelling at the end of this spline\n    exitAngleDeg()\n    {\n        return this.angleLeavingNode( this.nodeData.length-1 );\n    }\n\n\n    entryAngleDeg()\n    {\n        return this.angleEnteringNode( 0 );\n    }\n\n    angleEnteringNode( i )\n    {\n        var n = this.nodeData[ i ];\n        var inControlPoint = n.inControlPoint;\n        var outControlPoint = n.outControlPoint;\n        var directionLine;\n\n        if ( inControlPoint && inControlPoint.equals( n.point ) )\n            inControlPoint = undefined;\n\n        if ( outControlPoint && outControlPoint.equals( n.point ) )\n            outControlPoint = undefined;\n\n        if (( ! inControlPoint ) && ( i > 0 ))\n            inControlPoint = this.nodeData[ i-1 ].outControlPoint; \n        else if (( ! outControlPoint )&&( i < this.nodeData.length-1 ))\n            outControlPoint = this.nodeData[ i+1 ].inControlPoint;  \n\n        if ( inControlPoint)\n            directionLine = new GeoLine( inControlPoint, n.point );\n        else if ( outControlPoint )\n            directionLine = new GeoLine( n.point, outControlPoint );\n\n        return directionLine.angleDeg();\n    }\n\n\n    angleLeavingNode( i )\n    {\n        var n = this.nodeData[ i ];\n        var inControlPoint = n.inControlPoint;\n        var outControlPoint = n.outControlPoint;\n        var directionLine;\n\n        //What if length2 == 0, the node's inControlPoint == point\n        if (( i == 0 ) && ( outControlPoint ))\n        {\n            if ( outControlPoint.equals( n.point ) )\n                outControlPoint = undefined;\n            else    \n                directionLine = new GeoLine( n.point, n.outControlPoint );\n        }\n        else if (( i == this.nodeData.length-1 ) && ( inControlPoint ))\n        {\n            if ( inControlPoint.equals( n.point ) )\n                inControlPoint = undefined;\n            else\n                directionLine = new GeoLine( n.inControlPoint, n.point );\n        }\n\n        if ( ! directionLine ) \n        {\n            if (( ! outControlPoint )&&( i < this.nodeData.length-1 ))\n                outControlPoint = this.nodeData[ i+1 ].inControlPoint;  \n            else if (( ! inControlPoint ) && ( i > 0 ))\n                inControlPoint = this.nodeData[ i-1 ].outControlPoint; \n\n            if ( outControlPoint )\n                directionLine = new GeoLine( n.point, outControlPoint );\n            else if ( inControlPoint )\n                directionLine = new GeoLine( inControlPoint, n.point );\n        }\n\n        return directionLine.angleDeg();\n    }\n\n\n    toString()\n    {\n        var s = \"GeoSpline[ \";\n        for ( var i=0; i<this.nodeData.length; i++ )\n        {\n            var node = this.nodeData[i];\n\n            if ( node.inControlPoint )\n                s += \" in:\" + node.inControlPoint.toString();\n\n            if ( node.inAngle )\n                s += \" inAng:\" + node.inAngle;\n\n            if ( node.inLength )\n                s += \" inLen:\" + node.inLength;\n\n            s += \" p:\" + node.point.toString();\n\n            if ( node.outControlPoint )\n                s += \" out:\" + node.outControlPoint.toString();\n\n            if ( node.outAngle )\n                s += \" outAng:\" + node.outAngle;\n\n            if ( node.outLength )\n                s += \" outLen:\" + node.outLength;\n        }\n        s += \"]\";\n        return s;\n    }\n\n\n    parallelCurve( sa )\n    {\n        if ( sa === 0 )\n        {\n            return { baseCurve: this, offsetCurve: this }; \n        }\n\n        var newNodeData = [];\n        var len = this.nodeData.length;\n        var prevNode;\n        var prevNewNode;\n        for ( var i=0; i<len; i++ )\n        {\n            var node = this.nodeData[i];\n\n            var newNode = {};\n            newNodeData[i] = newNode;\n            var tangentAfterDeg = this.angleLeavingNode(i) + 90; //TODO we could allow for pointy nodes by using angleArrivingNode for the inControlPoint\n            if ( tangentAfterDeg > 360 )\n                tangentAfterDeg -= 360;\n\n            var tangentBeforeDeg = tangentAfterDeg; //TODO determine this separately?\n\n            newNode.point = node.point.pointAtDistanceAndAngleDeg( sa, tangentAfterDeg );\n            if ( node.inControlPoint )\n                newNode.inControlPoint = node.inControlPoint.pointAtDistanceAndAngleDeg( sa, tangentBeforeDeg );\n            if ( node.outControlPoint )\n                newNode.outControlPoint = node.outControlPoint.pointAtDistanceAndAngleDeg( sa, tangentAfterDeg );\n\n            if ( prevNode )\n            {\n                //We can do slightly better still, for each step/simplespline how much bigger is the new curve (distance between start/end nodes), \n                //and scale the length of the control points accordingly. \n                var distance = (new GeoLine( prevNode.point, node.point )).getLength();\n                var offsetDistance = (new GeoLine( prevNewNode.point, newNode.point )).getLength();\n                if ( ( distance > 0 ) && ( offsetDistance > 0) && ( distance != offsetDistance ) )\n                {\n                    var extension = offsetDistance / distance; //nb this could be <0 or >0.\n                    if ( Math.abs(extension) > 0.001 )\n                    {\n                        //console.log( (extension>1 ? \"Extending\" : \"Reducing\" ) + \" the control point lengths to \" + (Math.round( extension * 1000)/10) + \"%\" );\n                        var outControlPointLine = new GeoLine( prevNewNode.point, prevNewNode.outControlPoint );\n                        prevNewNode.outAngle = outControlPointLine.angleDeg();\n                        prevNewNode.outLength = outControlPointLine.getLength() * extension;\n                        prevNewNode.outControlPoint = prevNewNode.point.pointAtDistanceAndAngleDeg( prevNewNode.outLength, prevNewNode.outAngle );\n                        var inControlPointLine = new GeoLine( newNode.point, newNode.inControlPoint );\n                        newNode.inAngle = inControlPointLine.angleDeg();\n                        newNode.inLength = inControlPointLine.getLength() * extension;                        \n                        newNode.inControlPoint = newNode.point.pointAtDistanceAndAngleDeg( newNode.inLength, newNode.inAngle );\n                    }\n                }\n            }\n\n            prevNode = node;\n            prevNewNode = newNode;\n        }\n        var offsetCurve = new GeoSpline( newNodeData );\n\n        var newNodeData = [];\n        var c1, c2, c3;\n        for ( var i=1; i<len; i++ )\n        {\n            var prevNode = this.nodeData[i-1];\n            var node = this.nodeData[i];\n            var thisSegmentAsGeoSpline = new GeoSpline( [ prevNode, node ] );\n            var offsetSegmentAsGeoSpline = new GeoSpline( [ offsetCurve.nodeData[i-1], offsetCurve.nodeData[i]] );\n            var worstError = 0.0;\n            var errorAtHalfway;\n\n            //var testPositions = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9 ];\n            // for ( var j in testPositions )\n            // {\n            //     var t = testPositions[j];\n            //     var toffset = thisSegmentAsGeoSpline.getOffsetBetweenCurves( offsetSegmentAsGeoSpline, t, sa );\n            //     var error = Math.abs( toffset - sa );\n            //     //console.log( \" Error at t:\" + Math.round(t*100)/100 + \" is \" + Math.round( error/sa1*100 ) + \"% actualError:\" + error  );\n            //     if ( error > worstError )\n            //         worstError = error;\n            // }\n            errorAtHalfway = Math.abs( thisSegmentAsGeoSpline.getOffsetBetweenCurves( offsetSegmentAsGeoSpline, 0.5, sa ) - sa );\n            //console.log( \"Worst:\" + worstError + \" Halfway:\" + errorAtHalfway );\n\n            //depending upon worstError decide if we're splitting this segment, if we're we can just copy it to the one we're creating\n            //if we split any, then recurse. \n            console.log( \"Node \" + i + \" offset variance at t=0.5 \" + Math.round( errorAtHalfway/sa*1000 )/10 + \"%\" );\n            if ( ( isNaN( errorAtHalfway ) ) || ( (errorAtHalfway/sa) > 0.005 ) ) //0.01 would be plenty accurate enough for our purposes. \n            {\n                //var splineWithAddedNodes = \n                const struts = thisSegmentAsGeoSpline.getStrutPoints( 0.5 );\n\n                if ( c3 )\n                {\n                    c1 = null;\n                    c3.outControlPoint = struts[4];\n                    //nb c3.point should equal struts[0]\n                }\n                else\n                    c1 = this.createNodeData( undefined, struts[0], struts[4] );\n\n                c2 = this.createNodeData( struts[7], struts[9], struts[8] );\n                c3 = this.createNodeData( struts[6], struts[3], undefined );\n                            \n                if ( c1 )\n                    newNodeData.push( c1 );\n\n                c3.outControlPoint = node.outControlPoint;\n\n                newNodeData.push( c2 );\n                newNodeData.push( c3 );\n            }\n            else\n            {\n                if ( i == 1 )\n                    newNodeData.push( prevNode );\n\n                newNodeData.push( node );\n                c3 = node;\n            }\n        }\n\n        if ( newNodeData.length > this.nodeData.length )\n        {\n            for ( var i=0; i<newNodeData.length; i++ )\n            {\n                var node = newNodeData[i];\n\n                if (( ! node.inControlPoint ) && ( i>0 ))\n                    console.log(\"Error, node should have inControlPoint\");\n\n                if (( ! node.outControlPoint ) && ( i<(newNodeData.length-1) ))\n                    console.log(\"Error, node should have outControlPoint\");\n\n            }\n    \n            var thisWithMoreControlPoints = new GeoSpline( newNodeData );\n            console.log(\"Recursing, now has \" + thisWithMoreControlPoints.nodeData.length + \" nodes...\");\n            return thisWithMoreControlPoints.parallelCurve( sa );\n        }\n\n        //Also see:\n        //https://raphlinus.github.io/curves/2022/09/09/parallel-beziers.html\n        //http://brunoimbrizi.com/unbox/2015/03/offset-curve/\n\n        return { baseCurve: this, offsetCurve: offsetCurve }; \n    }   \n\n    //For two curves that are supposed to be paralled, \n    //what offset has actually been achieved at t?    \n    getOffsetBetweenCurves( otherCurve, t, targetOffset )\n    {\n        var pointOnThisCurve = this.getPointForT( t );\n\n        //NOTE: we cannot simply do  otherCurve.getPointForT( t ) as the two points won't necessarily be tangential.\n\n        //So, calculate a tangent from this curve to intersect the other. \n        var anotherPointATinyBitFurtherOn = this.getPointForT( t + 0.0001 );\n        var angleAtThisPoint = (new GeoLine(pointOnThisCurve,anotherPointATinyBitFurtherOn )).angleDeg();\n        var tangentAngle = angleAtThisPoint + 90;\n        if ( tangentAngle >= 360 ) \n            tangentAngle -= 360;\n        var tangentLineAtThisPoint = new GeoLine(pointOnThisCurve, pointOnThisCurve.pointAtDistanceAndAngleDeg( 10 * targetOffset, tangentAngle ) );\n\n        var otherCurveSI = otherCurve.asShapeInfo();\n        var tangentLineSI = tangentLineAtThisPoint.asShapeInfo();        \n\n        var intersections = Intersection.intersect(otherCurveSI, tangentLineSI);\n        if ( intersections.points.length === 0 )\n            return undefined;\n\n        var pointOnOtherCurve = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n\n        var line = new GeoLine( pointOnThisCurve, pointOnOtherCurve );\n        return line.getLength();\n    }\n}"]}