{"version":3,"sources":["drawing/DrawingObject.js","drawing/ArcElliptical.js","drawing/ArcSimple.js","drawing/ArcWithLength.js","drawing/CutSpline.js","drawing/Drawing.js","drawing/Line.js","drawing/OperationFlipByAxis.js","drawing/OperationFlipLine.js","drawing/OperationMove.js","drawing/OperationResult.js","drawing/OperationRotate.js","drawing/PerpendicularPointAlongLine.js","drawing/PointAlongBisector.js","drawing/PointAlongLine.js","drawing/PointAlongPerpendicular.js","drawing/PointCutArc.js","drawing/PointCutSplinePath.js","drawing/PointEndLine.js","drawing/PointFromArcAndTangent.js","drawing/PointFromCircleAndTangent.js","drawing/PointFromXandYOfTwoOtherPoints.js","drawing/PointIntersectArcAndAxis.js","drawing/PointIntersectArcAndLine.js","drawing/PointIntersectArcs.js","drawing/PointIntersectCircles.js","drawing/PointIntersectCurveAndAxis.js","drawing/PointIntersectCurves.js","drawing/PointIntersectLineAndAxis.js","drawing/PointLineIntersect.js","drawing/PointOfTriangle.js","drawing/PointShoulder.js","drawing/PointSingle.js","drawing/SplinePathInteractive.js","drawing/SplinePathUsingPoints.js","drawing/SplineSimple.js","drawing/SplineUsingControlPoints.js","drawing/TrueDart.js","drawing/TrueDartResult.js","Pattern.js","Group.js","Piece.js","PatternDrawing.js","PatternEditor.js","expression.js","geometry/Bounds.js","geometry/GeoArc.js","geometry/GeoEllipticalArc.js","geometry/GeoLine.js","geometry/GeoPoint.js","geometry/GeoSpline.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACngDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChyDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACntBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"patterneditor.js","sourcesContent":["//(c) Copyright 2019 Jason Dore\n//\n//This library collates the various geometric calclulation requirements\n//of the drawing objects into a small number of primitives. \n//\n//This library then generally uses other libraries to perform those \n//geometric calculations where they are non trivial\n//(e.g. intersection of lines with splines).\n//\n//Source maintained at: https://github.com/MrDoo71/PatternEditor\n\nclass DrawingObject /*abstract*/ {\n    \n    constructor(data) {\n        this.data = data;\n        this.contextMenu = data.contextMenu;\n    }\n\n    drawLabel( g, drawingOptions ) {\n\n        if ( ! drawingOptions.label )\n            return;\n\n        //g - the svg group we want to add the text to\n        //o - the drawing object\n\n        const d = this.data; //the original json data\n\n        if (   ( this.p )\n            && ( typeof this.p.x === \"number\" ) )\n        {\n            const labelPosition = this.labelPosition();\n\n            if ( labelPosition.drawLine )\n                g.append(\"line\")\n                .attr(\"x1\", this.p.x)\n                .attr(\"y1\", this.p.y)\n                .attr(\"x2\", labelPosition.labelLineX )\n                .attr(\"y2\", labelPosition.labelLineY )\n                .attr(\"stroke-width\", this.getStrokeWidth( false ) )\n                .attr(\"class\", \"labelLine\" );\n\n            let labelText = d.name;\n            try {\n                if ( this.showLength() === \"label\" )\n                    labelText += \" \" + this.getLengthAndUnits();\n            } catch ( e ) {                \n            }\n\n            const t = g.append(\"text\")\n                        .attr(\"class\",\"labl\")\n                        .attr(\"x\", labelPosition.labelX )\n                        .attr(\"y\", labelPosition.labelY )\n                        .attr(\"font-size\", labelPosition.fontSize + \"px\")\n                        .text( labelText );\n\n            if ( drawingOptions.overrideLineColour )\n                t.attr(\"style\", \"fill:\"+ drawingOptions.overrideLineColour ); //using style overrides the stylesheet, whereas fill does not. \n        }\n\n        if (( this.showLength() === \"line\" ) && this.lineVisible())\n            this.drawLengthAlongLine( g, drawingOptions );\n    }\n\n\n    drawLengthAlongLine( g, drawingOptions )\n    {\n        let path;\n        if ( this.line )\n            path = this.line;\n        else if ( this.curve )\n            path = this.curve;\n        else if ( this.arc )\n            path = this.arc;\n        else \n            throw new Error( \"Unknown type to add length along line\" );\n\n        const lengthAndUnits = this.getLengthAndUnits();\n\n        this.drawing.drawLabelAlongPath( g, path, lengthAndUnits, false ); //no fontSize, so semantic zoom font size. \n    }\ns\n\n    labelPosition() {\n\n        if ( ! this.p )\n            return null;\n\n        const d = this.data; //the original json data\n        const fontSize = Math.round( 1300 / scale / fontsSizedForScale )/100;\n        let fudge = 1.0; //0.75*mx because we use a smaller font than seamly2d\n\n        //This is different to seamly2d behaviour, we'll actually reduce mx/my a bit if you zoom in\n        if ( fontsSizedForScale > 1 )\n            fudge = (1 + 1/fontsSizedForScale) /2;\n\n        let mx = (typeof d.mx === \"undefined\") ? 0 : d.mx;\n        let my = (typeof d.my === \"undefined\") ? 0 : d.my;\n\n        //some odd data exists out there in operation results of splines e.g. 3 Button Sack rev.1\n        if (( mx >= 2147480000 ) || ( my >= 2147480000 ))\n        {\n            mx = 0;\n            my = 0;\n        }\n\n        const pos = { labelX: this.p.x + fudge * mx,\n                    labelY: this.p.y + fudge * ( my + fontSize ),\n                    labelLineX: this.p.x + fudge * mx,  //line goes to left of label\n                    labelLineY: this.p.y + fudge * ( my + 0.5 * fontSize ), //line always goes to vertical midpoint of text\n                    fontSize: fontSize\n                    };\n\n        //TODO adjust the labelLine to be cleverer, intersecting a boundary box around the text.      \n        \n        if (( mx <= 0 ) && ( d.name ))\n            pos.labelLineX = this.p.x + fudge * ( mx + 0.5 * d.name.length * fontSize ); //otherwise line goes to center of label\n\n        if ( my <= 0 )\n            pos.labelLineY = this.p.y + fudge * ( my + fontSize ); //align to bottom of text\n\n        const minLineLength = 2 * fontSize;\n\n        pos.drawLine =    ( Math.abs( this.p.x - pos.labelX ) > minLineLength )\n                       || ( Math.abs( this.p.y - pos.labelY ) > minLineLength );\n\n        //TODO drawing a line can become newly desirable because of zooming, but we won't have added it. \n\n        return pos;\n    }\n\n\n    getLengthAndUnits()\n    {\n        let l;\n\n        if ( this.line )\n            l = this.line.length;\n        else if (( this.curve ) && ( typeof this.curve.pathLength === \"function\" ))\n            l = this.curve.pathLength();\n        else if (( this.arc ) && ( typeof this.arc.pathLength === \"function\" ))\n            l = this.arc.pathLength();\n\n        if ( l !== undefined )\n        {\n            const patternUnits = this.drawing.pattern.units;\n            const precision = patternUnits === \"mm\" ? 10.0 : 100.0;\n            l = Math.round( precision * l ) / precision;            \n            return l + \" \" + patternUnits;    \n        }\n            \n        throw new Error( \"Unknown length\" );\n    }\n\n\n    drawDot( g, drawingOptions ) {\n\n        if ( ! drawingOptions.dot )\n            return; \n\n        const isOutline = drawingOptions.outline;\n        g.append(\"circle\")\n            .attr(\"cx\", this.p.x)\n            .attr(\"cy\", this.p.y)\n            .attr(\"r\", Math.round( ( isOutline ? 1200 : 400 ) / scale ) /100 );\n    }\n\n\n    drawLine( g, drawingOptions ) {\n\n        if ( this.lineVisible() && this.line ) \n            this.drawALine( g, drawingOptions, this.line );\n    }\n\n\n    drawALine( g, drawingOptions, line ) {\n\n        const isOutline = drawingOptions.outline;\n        \n        const l = g.append(\"line\")\n                    .attr(\"x1\", line.p1.x)\n                    .attr(\"y1\", line.p1.y)\n                    .attr(\"x2\", line.p2.x)\n                    .attr(\"y2\", line.p2.y)\n                    .attr(\"stroke-width\", this.getStrokeWidth( isOutline ) );\n\n        if ( ! isOutline )\n            l.attr(\"stroke\", drawingOptions.overrideLineColour ? drawingOptions.overrideLineColour : this.getColor() )\n                .attr(\"class\", drawingOptions.overrideLineStyle ? drawingOptions.overrideLineStyle : this.getLineStyle() );\n    }\n\n\n    drawPath( g, path, drawingOptions ) {\n\n        const isOutline = drawingOptions.outline;\n\n        if ( this.lineVisible() )\n        {\n            const p = g.append(\"path\")\n                    .attr(\"d\", path )\n                    .attr(\"fill\", \"none\")\n                    .attr(\"stroke-width\", this.getStrokeWidth( isOutline) );\n\n            if ( ! isOutline )        \n                p.attr(\"stroke\", drawingOptions.overrideLineColour ? drawingOptions.overrideLineColour : this.getColor() )\n                 .attr(\"class\", drawingOptions.overrideLineStyle ? drawingOptions.overrideLineStyle : this.getLineStyle() );\n        }\n    }    \n\n\n    drawCurve( g, drawingOptions ) {\n\n        if ( ( this.lineVisible() ) && this.curve )\n            this.drawPath( g, this.curve.svgPath(), drawingOptions );\n    }\n\n\n    drawArc( g, drawingOptions ) {\n\n        const isOutline = drawingOptions.outline;\n        \n        if ( ( this.lineVisible() /*|| isOutline*/ ) && this.arc )\n        {\n                if ( this.lineVisible() )\n                {\n                    if (    ( this.arc instanceof GeoEllipticalArc )\n                         && ( this.arc.useSvgEllipse() ) )\n                    {\n                        const p = g.append(\"ellipse\")\n                        .attr(\"transform\", \"rotate(\" + this.arc.rotationAngle + \")\" )\n                        .attr(\"cx\", this.arc.center.x )\n                        .attr(\"cy\", this.arc.center.y )\n                        .attr(\"rx\", this.arc.radius1 )\n                        .attr(\"ry\", this.arc.radius2 )\n                        .attr(\"fill\", \"none\")\n                        .attr(\"stroke-width\", this.getStrokeWidth( isOutline) );\n    \n                        if ( ! isOutline )\n                            p.attr(\"stroke\", this.getColor() )\n                            .attr(\"class\", this.getLineStyle() );    \n                    }\n                    else\n                        this.drawPath( g, this.arc.svgPath(), drawingOptions );    \n                }\n\n                //Labels that are along the line  should only show if we're drawing the line\n                this.drawLabel(g, drawingOptions);\n        }            \n    }\n\n\n    sanitiseForHTML ( s ) {\n\n        if ( ! typeof s === \"string\" )\n            s = \"\" + s;\n\n        return s.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;').replaceAll('\"', '&quot;');\n    };\n\n\n    ref() {\n        return '<a class=\"ps-ref\">' + this.sanitiseForHTML( this.data.name ) + '</a>';\n    }\n\n\n    nameOf() {\n        return '<span class=\"ps-name\">' + this.sanitiseForHTML( this.data.name ) + '</span>'\n    }\n\n\n    refOf( anotherDrawingObject ) {\n        if ( ! anotherDrawingObject )\n            return \"???\";\n\n        if ( ! anotherDrawingObject.ref )\n            return \"????\";\n\n        return anotherDrawingObject.ref();\n    }\n\n\n    getStrokeWidth( isOutline, isSelected )\n    {\n        return Math.round( 1000 * ( isOutline ? 7.0 : ( isSelected ? 3.0 : 1.0 ) ) / scale / fontsSizedForScale ) /1000;\n    }\n\n\n    getColor() {\n\n        //Actually, we'll handle this in the stylesheet\n        //if (( this.data.color === \"black\" ) && ( typeof iskDarkMode !== \"undefined\" ) && iskDarkMode )\n        //    return \"white\";\n        //if (( this.data.color === \"white\" ) && ( typeof iskDarkMode !== \"undefined\" )&& ( ! iskDarkMode ) )\n        //    return \"black\";\n          \n        return this.data.color;\n    }\n\n    \n    getLineStyle()\n    {\n        return this.data.lineStyle;\n    }\n\n\n    lineVisible() {\n        return this.data.lineStyle !== \"none\";\n    }\n\n\n    pointEndLine(data) {\n        data.objectType = \"pointEndLine\";\n        data.basePoint = this;\n        return this.drawing.add(data);\n    }\n\n\n    pointAlongLine(data) {\n        data.objectType = \"pointAlongLine\";\n        data.firstPoint = this;\n        return this.drawing.add(data);\n    }\n\n\n    lineTo(data) {\n        data.objectType = \"line\";\n        data.firstPoint = this;\n        return this.drawing.add(data);\n    }\n\n\n    pointLineIntersect(data) {\n        data.objectType = \"pointLineIntersect\";\n        data.p1Line1 = this;\n        return this.drawing.add(data);\n    }\n\n\n    setIsMemberOfGroup( group )\n    {\n        if ( ! this.memberOf )        \n            this.memberOf = [];\n\n        this.memberOf.push( group );\n    }\n\n\n    showLength()\n    {\n        if (   this.data.showLength !== undefined \n            && this.data.showLength !== \"none\" )\n            return this.data.showLength;\n\n        if ( this.memberOf )   \n            for( const g of this.memberOf )\n            {\n                if ( g.showLength !== \"none\" ) \n                    return g.showLength;\n            }\n\n        return \"none\";\n    }\n\n\n    isVisible( options )\n    {\n        if ( this.memberOf )   \n        {\n            let isVisible = false;\n\n            this.memberOf.forEach( \n                function(g) { \n                if ( g.visible ) \n                    isVisible = true; \n            } ); \n\n            if ( ! isVisible )\n                return false; //We are in 1+ groups, but none were visible.\n        }\n\n        if ( options?.targetPiece )\n        {\n            //TODO get rid of this now that we have skipDrawing\n            if ( options.downloadOption ) //see elsewhere where we use the same control.\n                return false; //Should targetPiece mean we don't display any drawing objects? \n\n            let isVisible = false;\n\n            //if this obj doesn't match a detailNode then return false\n            //if ( options.targetPiece.nodesByName[ this.data.name ] )\n            //    isVisible = true;\n\n            //TODO or if ! this.UsedByObjects\n            //return false\n            //if ( this.usedByPieces contains options.targetPiece )\n            //return true else return false\n\n            if ( options.targetPiece.detailNodes )\n                for( const n of options.targetPiece.detailNodes )\n                {\n                    if ( n.dObj === this ) \n                        isVisible = true; \n                }\n\n            if ( ! isVisible )\n                return false;\n        }\n\n        return true;\n    }\n\n    escapeHtml(unsafe) \n    {\n        return unsafe.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;').replaceAll('\"', '&quot;').replaceAll(\"'\", '&#039;');\n    }\n}\n","class ArcElliptical extends DrawingObject {\n\n    //center\n    //angle1\n    //angle2\n    //radius1\n    //radius2\n    //rotationAngle\n\n    constructor(data) {\n        super(data);\n\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = data.derivedName;\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.center === \"undefined\")\n            this.center = this.drawing.getObject(d.center);\n        if (typeof this.angle1 === \"undefined\")\n            this.angle1 = this.drawing.newFormula(d.angle1);\n        if (typeof this.angle2 === \"undefined\")\n            this.angle2 = this.drawing.newFormula(d.angle2);\n        if (typeof this.radius1 === \"undefined\")\n            this.radius1 = this.drawing.newFormula(d.radius1);\n        if (typeof this.radius2 === \"undefined\")\n            this.radius2 = this.drawing.newFormula(d.radius2);\n        if (typeof this.rotationAngle === \"undefined\")\n            this.rotationAngle = this.drawing.newFormula(d.rotationAngle);\n\n        this.arc = new GeoEllipticalArc( this.center.p, \n                                         this.radius1.value(),\n                                         this.radius2.value(), \n                                         this.angle1.value(), \n                                         this.angle2.value(),\n                                         this.rotationAngle.value() );\n   \n        this.p = this.arc.pointAlongPathFraction( 0.5 );\n\n        this.adjustBounds( bounds );\n    }\n\n    \n    adjustBounds( bounds )\n    {\n        bounds.adjust( this.p );\n\n        if ( this.arc )\n            this.arc.adjustBounds( bounds );\n    }\n\n\n    pointAlongPath( length )\n    {\n        return this.arc.pointAlongPath( length );\n    }\n    \n\n    asShapeInfo()\n    {\n        return this.arc.asShapeInfo();\n    }\n\n\n    draw( g, drawOptions ) {\n        this.drawArc( g, drawOptions );        \n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n                + 'elliptical arc with center ' + this.refOf( this.center )\n                + \" radius-x \" + this.radius1.htmlLength( asFormula ) \n                + \" radius-y \" + this.radius2.htmlLength( asFormula ) \n                + \" from angle \" + this.angle1.htmlAngle( asFormula ) \n                + \" to \" + this.angle2.htmlAngle( asFormula )\n                + \" rotation angle \" + this.rotationAngle.htmlAngle( asFormula ) ;\n    }\n\n    \n    setDependencies( dependencies ) {\n        dependencies.add( this, this.center );\n        dependencies.add( this, this.angle1 );\n        dependencies.add( this, this.angle2 );\n        dependencies.add( this, this.rotationAngle );\n        dependencies.add( this, this.radius1 );\n        dependencies.add( this, this.radius2 );\n    }    \n}\n","class ArcSimple extends DrawingObject {\n\n    //center\n    //angle1\n    //angle2\n    //radius \n\n    constructor(data) {\n        super(data);\n\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = data.derivedName;\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.center === \"undefined\")\n            this.center = this.drawing.getObject(d.center);\n        if (typeof this.angle1 === \"undefined\")\n            this.angle1 = this.drawing.newFormula(d.angle1);\n        if (typeof this.angle2 === \"undefined\")\n            this.angle2 = this.drawing.newFormula(d.angle2);\n        if (typeof this.radius === \"undefined\")\n            this.radius = this.drawing.newFormula(d.radius);\n\n        this.arc = new GeoArc( this.center.p, this.radius.value(), this.angle1.value(), this.angle2.value() );\n\n        this.p = this.arc.pointAlongPathFraction( 0.5 );\n\n        this.adjustBounds( bounds );\n    }\n\n    \n    adjustBounds( bounds )\n    {\n        bounds.adjust( this.p ); //not necessarily\n\n        if ( this.arc )\n            this.arc.adjustBounds( bounds );\n    }\n\n\n    pointAlongPath( length ) {\n        return this.arc.pointAlongPath( length );\n    }\n    \n\n    asShapeInfo() {\n        return this.arc.asShapeInfo();\n    }\n\n\n    draw( g, drawOptions ) {\n\n        this.drawArc( g, drawOptions );\n        //this.drawLabel(g, drawOptions ); Only do the label if the line style!=none\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n                + 'arc with center ' + this.refOf( this.center )\n                + \" radius \" + this.radius.htmlLength( asFormula ) \n                + \" from angle \" + this.angle1.htmlAngle( asFormula ) \n                + \" to \" + this.angle2.htmlAngle( asFormula );\n    }\n\n    \n    setDependencies( dependencies ) {\n        dependencies.add( this, this.center );\n        dependencies.add( this, this.angle1 );\n        dependencies.add( this, this.angle2 );\n        dependencies.add( this, this.radius );\n    }    \n}\n","class ArcWithLength extends ArcSimple {\n\n    //center\n    //angle\n    //length\n    //radius \n\n    constructor(data) {\n        super(data);\n\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = data.derivedName;\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.center === \"undefined\")\n            this.center = this.drawing.getObject(d.center);\n        if (typeof this.angle1 === \"undefined\")\n            this.angle = this.drawing.newFormula(d.angle1);\n        if (typeof this.length === \"undefined\")\n            this.length = this.drawing.newFormula(d.length);\n        if (typeof this.radius === \"undefined\")\n            this.radius = this.drawing.newFormula(d.radius);\n\n        //circle-circ = 2 * pi * radius\n        //fraction of circle = length / circle-cird\n        //angle of arc  = length / circle-cird * 360\n        //angle2 = angle + ( length / circle-cird * 360 )\n        const endAngle = this.angle.value() + this.length.value() / (2 * Math.PI * this.radius.value() ) * 360;\n\n        this.arc = new GeoArc( this.center.p, this.radius.value(), this.angle.value(), endAngle );\n\n        this.p = this.arc.pointAlongPathFraction( 0.5 );\n\n        this.adjustBounds( bounds );\n    }\n\n    \n    html( asFormula ) {\n        return this.nameOf() + ': '\n                + 'arc with center ' + this.refOf( this.center )\n                + \" radius \" + this.radius.htmlLength( asFormula ) \n                + \" from angle \" + this.angle.htmlAngle( asFormula ) \n                + \" length \" + this.length.htmlLength( asFormula );\n    }\n\n    \n    setDependencies( dependencies ) {\n        dependencies.add( this, this.center );\n        dependencies.add( this, this.angle );\n        dependencies.add( this, this.length );\n        dependencies.add( this, this.radius );\n    }    \n}\n","class CutSpline extends DrawingObject { //TODO for consistency should be PointCutSpline ???\n\n    //curve\n    //length\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.curve === \"undefined\")\n            this.curve = this.drawing.getObject(d.spline);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.drawing.newFormula(d.length);\n\n        //Note tha this.curve might be something like a SplineSimple, but it might also be an OperationResult\n        this.p = this.curve.pointAlongPath( this.length.value() );\n        this.adjustBounds( bounds );\n    }\n\n    \n    adjustBounds( bounds )\n    {        \n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, drawOptions ) {\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n                + this.data.length.htmlLength( asFormula ) \n                + \" along curve \" + this.refOf( this.curve );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.curve );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","//(c) Copyright 2019 Jason Dore\n//https://github.com/MrDoo71/PatternEditor\n\nvar scale;\n\n\n","class Line extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n\n    constructor(data) {\n        super(data);\n        this.data.name = data.derivedName;\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.drawing.getObject(d.firstPoint);\n            \n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.drawing.getObject(d.secondPoint);\n\n        this.line = new GeoLine(this.firstPoint.p, this.secondPoint.p);\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjustForLine(this.line);\n    }\n\n\n    draw( g, drawOptions ) {\n        \n        this.drawLine( g, drawOptions );\n\n        this.drawLabel( g, drawOptions );\n        \n        //TODO we could display the derived name Line_A1_A2 at the mid-point along the line?       \n\n        //TODO for all lines we could draw a thicker invisible line do make it easier to click on the line.\n    }\n\n\n    html( asFormula ) {\n        return 'line ' + this.refOf( this.firstPoint ) + \" - \" + this.refOf( this.secondPoint );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n    }    \n}\n","class OperationFlipByAxis extends DrawingObject {\n\n    //operationName\n    //suffix\n    //center\n    //axis\n\n    constructor(data) {\n        super(data);\n        this.data.name = data.operationName;\n        this.axis = data.axis;\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.center === \"undefined\")\n            this.center = this.drawing.getObject(d.center);\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        //Done by OperationResult\n    }\n\n\n    draw( g, drawOptions ) {\n        //g is the svg group\n        //this.drawLine( g ); //TODO put an arrow head on this!\n        //this.drawDot( g );\n        //this.drawLabel( g );\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n                + 'Flip ' + this.axis \n                + \" around \" + this.refOf( this.center ) \n                         //\" angle:\" + this.data.angle.value() +\n                + \" applying suffix '\" + this.data.suffix + \"'\";\n    }\n\n\n    applyOperationToPoint( p ) {\n        return this.flipPoint( p, this.center.p );\n    }\n\n\n    flipPoint( p, center ) {\n        const result = new GeoPoint( p.x, p.y );\n\n        if (    ( this.axis === \"Vertical\" ) \n             || ( this.axis === \"vertical\" )) //just in case.\n            result.x = center.x - ( p.x - center.x );\n        else\n            result.y = center.y - ( p.y - center.y );\n\n        return result;\n    }\n\n    \n    setDependencies( dependencies ) {\n        dependencies.add( this, this.center );\n    }    \n\n}\n","class OperationFlipByLine extends DrawingObject {\n\n    //operationName\n    //suffix\n    //p1Line1\n    //p2Line1\n  \n\n    constructor(data) {\n        super(data);\n        this.data.name = data.operationName;\n        this.axis = data.axis;\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.p1Line1 === \"undefined\")\n            this.p1Line1 = this.drawing.getObject(d.p1Line1);\n\n        if (typeof this.p2Line1 === \"undefined\")\n            this.p2Line1 = this.drawing.getObject(d.p2Line1);\n\n        this.line = new GeoLine( this.p1Line1.p, this.p2Line1.p );\n\n        this.adjustBounds( bounds );\n    }\n\n    adjustBounds( bounds )\n    {\n        //Done by OperationResult\n    }\n\n\n    draw( g, drawOptions ) {\n        //g is the svg group\n        //this.drawLine( g ); //TODO put an arrow head on this!\n        //this.drawDot( g );\n        //this.drawLabel( g );\n\n        this.drawLine( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n                + 'Flip over line ' + this.refOf( this.p1Line1 ) \n                + \"-\" + this.refOf( this.p2Line1 ) \n                + \" applying suffix '\" + this.data.suffix + \"'\";\n    }\n\n\n    applyOperationToPoint( p ) {\n\n        return this.flipPoint( p, this.line );\n    }\n\n\n    flipPoint( p, line ) {\n        \n        //image the point of view rotated such that this.line is on the x-axis at 0deg. \n        //if the line is at 45deg, rotate the line and the source point by -45 deg. flip the y component, then rotate back by +45. \n\n        const p0 = p.rotate( this.line.p1, -this.line.angleDeg() );\n\n        const p0f = new GeoPoint( p0.x, this.line.p1.y - ( p0.y - this.line.p1.y ) );\n\n        const result = p0f.rotate( this.line.p1, this.line.angleDeg() );\n\n        return result;\n    }\n\n    \n    setDependencies( dependencies ) {\n        dependencies.add( this, this.p1Line1 );\n        dependencies.add( this, this.p2Line1 );\n    }    \n\n}\n","class OperationMove extends DrawingObject {\n\n    //operationName\n    //suffix\n    //angle\n    //length\n\n    constructor(data) {\n        super(data);\n        this.data.name = data.operationName;\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.drawing.newFormula(d.length);\n            \n        if (typeof this.angle === \"undefined\")\n            this.angle = this.drawing.newFormula(d.angle);\n            \n        //Convert degrees to radians\n        //this.p = this.basePoint.p.pointAtDistanceAndAngleRad(this.length.value(), Math.PI * 2 * this.angle.value() / 360);\n        //this.line = new GeoLine(this.basePoint.p, this.p);\n        //bounds.adjustForLine(this.line);\n        \n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        //Done by OperationResult\n    }\n\n\n    draw( g, drawOptions ) {\n        //g is the svg group\n        //this.drawLine( g ); //TODO put an arrow head on this!\n        //this.drawDot( g );\n        //this.drawLabel( g );\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n                    + 'Move ' + this.data.length.htmlLength( asFormula ) \n                    //\" from \" + this.basePoint.data.name +\n                    + \" at angle \" + this.data.angle.htmlAngle( asFormula ) \n                    + \" applying suffix '\" + this.data.suffix + \"'\";\n    }\n\n\n    applyOperationToPoint( p ) {\n        //Convert degrees to radians\n        const result = p.pointAtDistanceAndAngleDeg( this.length.value(), this.angle.value() );\n        //var line = new GeoLine( source.p, result.p );\n        return result;\n    }\n\n\n    setDependencies( dependencies ) {\n        //dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.length );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","class OperationResult extends DrawingObject {\n\n    //basePoint\n    //fromOperation\n\n    constructor(data) {\n        super(data);\n        this.data.name = data.derivedName;\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.drawing.getObject(d.basePoint);\n\n        if (typeof this.fromOperation === \"undefined\")\n            this.fromOperation = this.drawing.getObject(d.fromOperation);\n\n        //if this.basePoint is a point... (if a curve, this is the midpoint)\n        if ( this.basePoint.p )\n            this.p = this.fromOperation.applyOperationToPoint( this.basePoint.p );\n\n        const operation = this.fromOperation;\n        const applyOperationToPointFunc = function( p ) {\n            return operation.applyOperationToPoint( p );\n        };\n\n        if ( this.basePoint.curve instanceof GeoSpline )\n        {\n            //so we get this captured and can just pass the function around\n            this.curve = this.basePoint.curve.applyOperation( applyOperationToPointFunc );\n        }\n\n        //If the basePoint is a Point that is showing its construction line, then don't perform\n        //the operation on that construction line.\n        if ( ( this.basePoint instanceof Line ) && ( this.basePoint.line instanceof GeoLine ) ) //untested?\n        {\n            this.line = this.basePoint.line.applyOperation( applyOperationToPointFunc );\n        }\n\n        if (   ( this.basePoint.arc instanceof GeoArc ) //untested?\n            || ( this.basePoint.arc instanceof GeoEllipticalArc ) )\n        {\n            this.arc = this.basePoint.arc.applyOperation( applyOperationToPointFunc );\n        }\n\n        //TODO This line would be useful if the operation, or operation result is selected. \n        //THOUGH, if the operation is a rotate then drawing an arc would be useful. \n        //this.operationLine = new GeoLine(this.basePoint.p, this.p);\n\n        if (( this.line ) || ( this.curve ) || ( this.arc ))\n        {\n            if ( ! this.data.lineStyle )\n                this.data.lineStyle = this.basePoint.data.lineStyle;\n\n            if ( ! this.data.color )    \n                this.data.color = this.basePoint.data.color;\n        }\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust( this.p );\n    }\n\n\n    asShapeInfo()\n    {\n        if ( this.curve )\n            return this.curve.asShapeInfo();\n        else if ( this.arc )\n            return this.arc.asShapeInfo();\n        else    \n            throw new Error( \"asShapeInfo() not implemented. \" );\n    }    \n\n    \n    pointAlongPath( length ) {\n\n        if ( this.arc )\n            return this.arc.pointAlongPath( length );\n\n        if ( this.curve )\n            return this.curve.pointAlongPath( length );\n            \n        throw new Error( \"pointAlongPath not implemented for this operation result. \" );\n    }\n\n\n    getColor() {\n        return this.basePoint.getColor();\n    }\n\n    \n    getLineStyle() {\n        return this.basePoint.getLineStyle();\n    }\n\n\n    draw( g, drawOptions ) {\n        //g is the svg group\n\n        //We might have operated on a point, spline (or presumably line)\n\n        if (( this.p ) && ( ! this.curve ) && ( ! this.arc ))\n            this.drawDot( g, drawOptions );\n\n        if ( this.curve )\n            this.drawCurve( g, drawOptions ); \n\n        if ( this.arc )\n            this.drawArc( g, drawOptions );             \n\n        if ( this.line )\n            this.drawLine( g, drawOptions ); \n            \n        if ( this.p )\n            this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n                + 'Result of ' + this.refOf( this.fromOperation )\n                + ' on ' + this.refOf( this.basePoint ); \n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.fromOperation );\n    }    \n\n}\n","class OperationRotate extends DrawingObject {\n\n    //operationName\n    //suffix\n    //angle\n    //center\n\n    constructor(data) {\n        super(data);\n        this.data.name = data.operationName;\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.center === \"undefined\")\n            this.center = this.drawing.getObject(d.center);\n            \n        if (typeof this.angle === \"undefined\")\n            this.angle = this.drawing.newFormula(d.angle);            \n            \n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        //Done by OperationResult\n    }\n\n\n    draw( g, drawOptions ) {\n        //g is the svg group\n        //this.drawLine( g ); //TODO put an arrow head on this!\n        //this.drawDot( g );\n        //this.drawLabel( g );\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n                + 'Rotate: ' \n                + this.data.angle.htmlAngle( asFormula ) \n                + \" around \" + this.refOf( this.center ) \n                + \" applying suffix '\" + this.data.suffix + \"'\";\n    }\n\n\n    applyOperationToPoint( p ) {\n        return p.rotate( this.center.p, this.angle.value() );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.center );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","class PerpendicularPointAlongLine extends DrawingObject {\n\n    //basePoint\n    //firstPoint\n    //secondPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.drawing.getObject(d.basePoint);\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.drawing.getObject(d.p1Line1);\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.drawing.getObject(d.p2Line1);\n\n        const line = new GeoLine(this.firstPoint.p, this.secondPoint.p);        \n        const baseLine = new GeoLine( this.basePoint.p, this.basePoint.p.pointAtDistanceAndAngleDeg( 1, line.angleDeg() + 90 ) );\n\n        this.p = line.intersect(baseLine);\n        this.line = new GeoLine( this.basePoint.p, this.p );\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, drawOptions ) {\n        //g is the svg group\n        this.drawLine( g, drawOptions );\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n                + 'Point along line ' + this.refOf( this.firstPoint ) + ' - ' + this.refOf( this.secondPoint )\n                + ' where it is perpendicular to ' + this.refOf( this.basePoint );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.basePoint );\n    }    \n\n}\n","class PointAlongBisector extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n    //thirdPoint\n    //length\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.drawing.getObject(d.firstPoint);\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.drawing.getObject(d.secondPoint);\n        if (typeof this.thirdPoint === \"undefined\")\n            this.thirdPoint = this.drawing.getObject(d.thirdPoint);\n        if (typeof this.length === \"undefined\")\n            this.length = this.drawing.newFormula(d.length);\n            \n        const line1 = new GeoLine( this.secondPoint.p, this.firstPoint.p );    \n        const line2 = new GeoLine( this.secondPoint.p, this.thirdPoint.p );    \n\n        //TODO test what happens when this crosses the equator! i.e. one point is just below the equator and one just above (and in either direction)\n        const bisectingAngle = ( line1.angleDeg() + line2.angleDeg() ) /2;\n\n        //Convert degrees to radians\n        this.p = this.secondPoint.p.pointAtDistanceAndAngleDeg( this.length.value(), bisectingAngle );\n        this.line = new GeoLine(this.secondPoint.p, this.p);\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjustForLine(this.line);\n    }\n\n\n    draw( g, drawOptions ) {\n        //g is the svg group\n        this.drawLine( g, drawOptions );\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n                + this.data.length.htmlLength( asFormula ) \n                + \" along line bisecting \" + this.refOf( this.secondPoint ) \n                + \"-\" + this.refOf( this.firstPoint )\n                + \" and \" + this.refOf( this.secondPoint ) \n                + \"-\" + this.refOf( this.thirdPoint );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.thirdPoint );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","class PointAlongLine extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n    //length\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.drawing.getObject(d.firstPoint);\n\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.drawing.getObject(d.secondPoint);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.drawing.newFormula(d.length);\n\n        this.baseLine = new GeoLine(this.firstPoint.p, this.secondPoint.p);\n        this.p = this.firstPoint.p.pointAtDistanceAndAngleRad(this.length.value(this.baseLine.length), this.baseLine.angle);\n        this.line = new GeoLine(this.firstPoint.p, this.p);\n        \n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjustForLine(this.line);\n    }\n\n\n    draw( g, drawOptions ) {\n        this.drawLine( g, drawOptions );\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        \n        return this.nameOf() + ': '\n                + this.data.length.htmlLength( asFormula, this.baseLine? this.baseLine.length : 0 ) \n                + \" along line from \" + this.refOf( this.firstPoint )\n                + \" to \" + this.refOf( this.secondPoint );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","class PointAlongPerpendicular extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n    //length\n    //angle\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.drawing.getObject(d.firstPoint);\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.drawing.getObject(d.secondPoint);\n        if (typeof this.length === \"undefined\")\n            this.length = this.drawing.newFormula(d.length);\n        if (typeof this.angle === \"undefined\")\n            this.angle = this.drawing.newFormula(d.angle);\n            \n        const baseLine = new GeoLine( this.firstPoint.p, this.secondPoint.p );    \n        const totalAngle = this.angle.value() + 90 + baseLine.angleDeg();\n        //Convert degrees to radians\n        this.p = this.firstPoint.p.pointAtDistanceAndAngleDeg( this.length.value(), totalAngle );\n        this.line = new GeoLine(this.firstPoint.p, this.p);\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjustForLine(this.line);\n    }\n\n\n    draw( g , drawOptions ) {\n        //g is the svg group\n        this.drawLine( g, drawOptions );\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        let h = this.nameOf() + ': '\n                + this.data.length.htmlLength( asFormula ) \n                + \" from \" + this.refOf( this.firstPoint ) \n                + \" perpendicular to the line to \" + this.refOf( this.secondPoint );\n\n        if (    ( this.data.angle.constant )\n             && ( this.data.angle.constant != 0 ) )\n            h += \" additional angle \" + this.data.angle.htmlAngle( asFormula );\n\n        return h;\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.length );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","class PointCutArc extends DrawingObject {\n\n    //arc\n    //length\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.arc === \"undefined\")\n            this.arc = this.drawing.getObject(d.arc);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.drawing.newFormula(d.length);\n\n        this.p = this.arc.pointAlongPath( this.length.value() );\n        \n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n    \n    draw( g, drawOptions ) {\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n                + this.data.length.htmlLength( asFormula ) \n                + \" along arc \" + this.refOf( this.arc );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.arc );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","class PointCutSplinePath extends DrawingObject {\n\n    //splinePath\n    //length\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.curve === \"undefined\")\n            this.curve = this.drawing.getObject(d.splinePath);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.drawing.newFormula(d.length);\n\n        this.p = this.curve.pointAlongPath( this.length.value() );\n        \n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, drawOptions ) {\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n                + this.data.length.htmlLength( asFormula ) \n                + \" along path \" + this.refOf( this.curve );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.curve );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","class PointEndLine extends DrawingObject {\n\n    //basePoint\n    //length\n    //angle\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.drawing.getObject(d.basePoint);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.drawing.newFormula(d.length);\n            \n        if (typeof this.angle === \"undefined\")\n            this.angle = this.drawing.newFormula(d.angle);\n\n        this.p = this.basePoint.p.pointAtDistanceAndAngleDeg( this.length.value(), this.angle.value() );\n        this.line = new GeoLine(this.basePoint.p, this.p);\n        \n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjustForLine(this.line);\n    }\n\n\n    draw( g, drawOptions ) {\n        this.drawLine( g, drawOptions );\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n                + this.data.length.htmlLength( asFormula ) \n                + \" from \" + this.refOf( this.basePoint ) \n                + \" angle \" + this.data.angle.htmlAngle( asFormula );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.length );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","class PointFromArcAndTangent extends DrawingObject {\n\n    //arc\n    //tangent\n    //crossPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.tangent === \"undefined\")\n            this.tangent = this.drawing.getObject(d.tangent);\n\n        if (typeof this.arc === \"undefined\")\n            this.arc = this.drawing.getObject(d.arc); \n\n        this.crossPoint = d.crossPoint;\n\n        const tangentIntersections = this.arc.arc.getPointsOfTangent( this.tangent.p );\n        \n        if ( this.crossPoint === \"One\" ) \n            this.p = tangentIntersections[1];\n        else \n            this.p = tangentIntersections[0];\n            \n        this.line = new GeoLine( this.tangent.p, this.p );\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, drawOptions ) {\n        this.drawLine(g, drawOptions );\n        this.drawDot(g, drawOptions );\n        this.drawLabel(g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n                + 'point on arc ' + this.refOf( this.arc ) //derivedName?\n                + ' of tangent from point ' + this.refOf( this.tangent )\n                + ' crosspoint:' + this.crossPoint;\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.tangent );\n        dependencies.add( this, this.arc );\n    }    \n\n}\n","class PointFromCircleAndTangent extends DrawingObject {\n\n    //center\n    //tangent\n    //crossPoint\n    //radius\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.tangent === \"undefined\")\n            this.tangent = this.drawing.getObject(d.tangent);\n\n        if (typeof this.arc === \"undefined\")\n            this.center = this.drawing.getObject(d.center); \n\n        if (typeof this.radius === \"undefined\")\n            this.radius = this.drawing.newFormula(d.radius);\n\n        this.crossPoint = d.crossPoint;\n\n        const circle = new GeoArc( this.center.p, this.radius.value(), 0, 360 );\n\n        const tangentIntersections = circle.getPointsOfTangent( this.tangent.p );\n        \n        //TODO what is the real logic for crossPoint One vs Two\n        if ( this.crossPoint === \"One\" ) \n            this.p = tangentIntersections[1];\n        else \n            this.p = tangentIntersections[0];\n            \n        this.line = new GeoLine( this.tangent.p, this.p );\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, drawOptions ) {\n        this.drawLine(g, drawOptions );\n        this.drawDot(g, drawOptions );\n        this.drawLabel(g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n                + 'point on circle with center ' + this.refOf( this.center ) \n                + ' radius ' + this.radius.htmlLength( asFormula ) \n                + ' of tangent from point ' + this.refOf( this.tangent )\n                + ' crosspoint:' + this.crossPoint;\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.tangent );\n        dependencies.add( this, this.center );\n        dependencies.add( this, this.radius );\n    }    \n\n}\n","class PointFromXandYOfTwoOtherPoints extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.drawing.getObject(d.firstPoint);\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.drawing.getObject(d.secondPoint);\n\n        this.p = new GeoPoint( this.firstPoint.p.x, this.secondPoint.p.y );\n\n        this.line1 = new GeoLine( this.firstPoint.p, this.p );\n        this.line2 = new GeoLine( this.secondPoint.p, this.p );\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    drawLine( g, drawingOptions ) \n    {\n        if ( this.lineVisible() )\n        {\n            if ( this.line1 ) \n                this.drawALine( g, drawingOptions, this.line1 );\n\n            if ( this.line2 ) \n                this.drawALine( g, drawingOptions, this.line2 );\n        }\n    }\n\n\n    draw( g, drawOptions ) {\n        //TODO check that there is no option to draw a line as part of this tool. \n        this.drawLine( g, drawOptions );\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n               + ' point at X from ' + this.refOf( this.firstPoint ) +  \" and Y from \" + this.refOf( this.secondPoint );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n    }    \n}\n","class PointIntersectArcAndAxis extends DrawingObject {\n\n    //arc (provided as \"curve\"), and may be an arc or a spline (by observation)\n    //basePoint\n    //angle\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.drawing.getObject(d.basePoint);\n\n        if (typeof this.arc === \"undefined\")\n            this.arc = this.drawing.getObject(d.curve); //An anomaly, would be better if this were arc.\n\n        if (typeof this.angle === \"undefined\")\n            this.angle = this.drawing.newFormula(d.angle);\n\n        let angleDeg = this.angle.value();\n        if ( angleDeg >= 360 )\n            angleDeg -= 360;\n        else if ( angleDeg < 0 )\n            angleDeg += 360;\n\n        const curveOrArc = ( this.arc.arc ) ? this.arc.arc : this.arc.curve ;\n\n        //Rather than use an arbitrarily long line (which was causing issues)\n        //calculate the max length of line. The line cannot be longer than\n        //the bounding box encompassing the basePoint and the curve. \n        const tempBounds = new Bounds();\n        tempBounds.adjust( this.basePoint.p );\n        this.arc.adjustBounds( tempBounds );\n\n        let maxLineLength = tempBounds.diagonaglLength() * 1.25;        \n        let otherPoint = this.basePoint.p.pointAtDistanceAndAngleDeg( maxLineLength, angleDeg );\n        let longLine = new GeoLine( this.basePoint.p, otherPoint );\n\n        try {\n            this.p = longLine.intersectArc( curveOrArc );\n\n        } catch ( e ) {\n\n            //For compatibility with Seamly2D, if the line doesn't find an intersection in the direction in \n            //which it is specified, try the other direction. \n            otherPoint = this.basePoint.p.pointAtDistanceAndAngleDeg( maxLineLength, angleDeg + 180 );\n            longLine = new GeoLine( this.basePoint.p, otherPoint );\n            this.p = longLine.intersectArc( curveOrArc );\n        }\n\n\n        this.line = new GeoLine( this.basePoint.p, this.p );\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, drawOptions ) {\n        //g is the svg group\n        this.drawLine(g, drawOptions );\n        this.drawDot(g, drawOptions );\n        this.drawLabel(g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        //TODO use a better name for this.curve, e.g. Arc_A_nn\n        return this.nameOf() + ': '\n                + 'intersect arc ' + this.refOf( this.arc )\n                + \" with line from \" + this.refOf( this.basePoint ) \n                + \" at angle \" + this.angle.htmlAngle( asFormula );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.arc );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","class PointIntersectArcAndLine extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n    //center\n    //radius\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.drawing.getObject(d.firstPoint);\n            \n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.drawing.getObject(d.secondPoint);\n\n        if (typeof this.center === \"undefined\")\n            this.center = this.drawing.getObject(d.center);\n\n        if (typeof this.radius === \"undefined\")\n            this.radius = this.drawing.newFormula(d.radius);\n\n        const line = new GeoLine( this.firstPoint.p, this.secondPoint.p );\n        const arc  = new GeoArc( this.center.p, this.radius.value(), 0, 360 );\n\n        this.p = line.intersectArc( arc );\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, drawOptions ) {\n\n        //TODO draw the line between basePoint and p\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        \n        return this.nameOf() + ': '\n                + 'intersect arc with center ' \n                + this.refOf( this.center ) \n                + \", radius \" + this.radius.htmlLength( asFormula ) \n                +  \" with line \" + this.refOf( this.firstPoint ) \n                + \"-\" + this.refOf( this.secondPoint );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.center );\n        dependencies.add( this, this.radius );\n    }    \n\n}\n","class PointIntersectArcs extends DrawingObject {\n\n    //firstArc\n    //secondArc\n    //crossPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.firstArc === \"undefined\")\n            this.firstArc = this.drawing.getObject(d.firstArc);\n            \n        if (typeof this.secondArc === \"undefined\")\n            this.secondArc = this.drawing.getObject(d.secondArc);\n\n        const arc1SI = this.firstArc.asShapeInfo();\n        const arc2SI = this.secondArc.asShapeInfo();\n\n        let intersections = Intersection.intersect(arc1SI, arc2SI);\n\n        const myIntersections = this.firstArc.arc.intersect( this.secondArc.arc );\n\n        //This is just a conservative switchover to our own intersection code. \n        //Need to test more widely for first and second intersection points, and arcs that span 0 deg.\n        if (( intersections.points.length === 0 ) && ( myIntersections.length !== 0 ))\n        {\n            intersections = { status: \"Intersection\", points: myIntersections };\n            console.log( \"Using alternative intersect method.\");\n        }\n\n        if ( intersections.points.length === 0 )\n        {\n            throw new Error( \"No intersections found. \" );\n        }\n        else if ( intersections.points.length === 1 )\n        {\n            this.p = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n        }\n        else\n        {\n            //TODO A5 in the test should be (0,0) as the point of intersection is not during the specified angle of the arcs.\n            //For each intersection point\n            //TODO check that GeoLine( this.firstArc.center.p, p1)).angleDeg() between this.firstArc.arc.angle1 and this.firstArc.arc.angle2\n            //and similar for secondArc\n\n            //What is the angle in the first arc of the intersection point?\n            //One = smallest angle in the first arc.\n            //Two = largest angle in the first arc.\n            const p1 = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n            const p2 = new GeoPoint( intersections.points[1].x, intersections.points[1].y );\n            const angle1 = (new GeoLine( this.firstArc.center.p, p1)).angle;\n            const angle2 = (new GeoLine( this.firstArc.center.p, p2)).angle;\n\n            if ( this.data.crossPoint === \"One\" )\n            {\n                if ( angle1 < angle2 )\n                    this.p = p1;\n                else\n                    this.p = p2;\n            }            \n            else \n            {\n                if ( angle1 < angle2 )\n                    this.p = p2;\n                else\n                    this.p = p1;\n            }\n        }\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, drawOptions ) {\n        this.drawDot(g, drawOptions );\n        this.drawLabel(g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n                + 'intersect arcs ' + this.refOf( this.firstArc )\n                + \" and \" + this.refOf( this.secondArc )\n                + ( this.data.crossPoint === \"One\" ? \"\" : \" - second point\");\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.firstArc );\n        dependencies.add( this, this.secondArc );\n    }    \n\n}\n","class PointIntersectCircles extends DrawingObject {\n\n    //center1     ??? Confirm\n    //radiu1   ??? Confirm\n    //center2   ??? Confirm\n    //radius2  ??? Confirm\n    //crossPoint    ??? Confirm\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.center1 === \"undefined\")\n            this.center1 = this.drawing.getObject(d.center1);\n            \n        if (typeof this.center2 === \"undefined\")\n            this.center2 = this.drawing.getObject(d.center2);\n\n        if (typeof this.radius1 === \"undefined\")\n            this.radius1 = this.drawing.newFormula(d.radius1);\n\n        if (typeof this.radius2 === \"undefined\")\n            this.radius2 = this.drawing.newFormula(d.radius2);\n\n        //Also this.data.crossPoint    \n        const circle1 = new GeoArc( this.center1.p, this.radius1.value(), 0, 360 );\n        const circle2 = new GeoArc( this.center2.p, this.radius2.value(), 0, 360 );\n\n        const arc1SI = circle1.asShapeInfo();\n        const arc2SI = circle2.asShapeInfo();\n\n        let intersections = Intersection.intersect(arc1SI, arc2SI);\n\n        const myIntersections = circle1.intersect( circle2 );\n\n        //This is just a conservative switchover to our own intersection code. \n        //Need to test more widely for first and second intersection points. \n        if (( intersections.points.length === 0 ) && ( myIntersections.length !== 0 ))\n        {\n            intersections = { status: \"Intersection\", points: myIntersections };\n            console.log( \"Using alternative intersect method.\");\n        }        \n        \n        if ( intersections.points.length === 0 )\n        {\n            throw new Error( \"No intersections found. \" );\n        }\n        else if ( intersections.points.length === 1 )\n        {\n            //surely there must always be two intersects, unless they just touch\n            this.p = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n        }\n        else\n        {\n            /* we do not know what logic valentina/seamly uses\n\n            the smallest angle, except that if angle1 beween 270 and 360 and angle2 between 0 and 90 then add 360 to angle2. */\n\n            //NB: this is a subset of the logic that applies to PointIntersectArcs.\n            //What is the angle in the first arc of the intersection point?\n            //One = smallest angle in the first arc.\n            //Two = largest angle in the first arc.\n            const p1 = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n            const p2 = new GeoPoint( intersections.points[1].x, intersections.points[1].y );\n            let angle1 = (new GeoLine( circle1.center, p1)).angleDeg();\n            let angle2 = (new GeoLine( circle1.center, p2)).angleDeg();\n            if (( angle1 >= 270 ) && ( angle2 > 0 ) && ( angle2 < 90 ))\n                angle2 += 360;\n            else if (( angle2 >= 270 ) && ( angle1 > 0 ) && ( angle1 < 90 ))\n                angle1 += 360;\n\n            if ( this.data.crossPoint === \"One\" )\n            {\n                if ( angle1 < angle2 )\n                    this.p = p1;\n                else\n                    this.p = p2;\n            }            \n            else \n            {\n                if ( angle1 < angle2 )\n                    this.p = p2;\n                else\n                    this.p = p1;\n            }            \n        }\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, drawOptions ) {\n        this.drawDot(g, drawOptions );\n        this.drawLabel(g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n                + 'intersect circles ' + this.refOf( this.center1 ) \n                + \" radius \" + this.radius1.htmlAngle( asFormula ) \n                + \" and \" + this.refOf( this.center2 ) \n                + \" radius \" + this.radius2.htmlLength( asFormula )\n                + ( this.data.crossPoint === \"One\" ? \"\" : \" - second point\");\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.center1 );\n        dependencies.add( this, this.center2 );\n        dependencies.add( this, this.radius1 );\n        dependencies.add( this, this.radius2 );\n    }    \n\n}\n","class PointIntersectCurveAndAxis extends DrawingObject {\n\n    //basePoint\n    //curve\n    //angle\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.drawing.getObject(d.basePoint);\n\n        if (typeof this.curve === \"undefined\")\n            this.curve = this.drawing.getObject(d.curve);\n\n        if (typeof this.angle === \"undefined\")\n            this.angle = this.drawing.newFormula(d.angle);\n\n        let angleDeg = this.angle.value();\n        if ( angleDeg >= 360 )\n            angleDeg -= 360;\n        else if ( angleDeg < 0 )\n            angleDeg += 360;\n\n\n        //Rather than use an arbitrarily long line (which was causing issues)\n        //calculate the max length of line. The line cannot be longer than\n        //the bounding box encompassing the basePoint and the curve. \n        const tempBounds = new Bounds();\n        tempBounds.adjust( this.basePoint.p );\n        this.curve.adjustBounds( tempBounds );\n        const maxLineLength = tempBounds.diagonaglLength() * 1.25;\n        \n        let otherPoint = this.basePoint.p.pointAtDistanceAndAngleDeg( maxLineLength, angleDeg );\n\n        const line = new GeoLine( this.basePoint.p, otherPoint );\n\n        const lineSI = line.asShapeInfo();\n        const curveSI = this.curve.asShapeInfo();\n\n        const intersections = Intersection.intersect(lineSI, curveSI);        \n\n        if ( intersections.points.length === 0 )\n        {\n            throw new Error( \"No intersections found. \" );\n        }\n        else\n        {\n            this.p = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n        }\n        this.line = new GeoLine( this.basePoint.p, this.p );\n\n        this.adjustBounds( bounds );\n    }\n    \n        \n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n    \n    draw(g, drawOptions ) {\n        //g is the svg group\n        this.drawLine(g, drawOptions ); \n        this.drawDot(g, drawOptions );\n        this.drawLabel(g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'intersect curve ' + this.refOf( this.curve )\n                + \" with line from \" + this.refOf( this.basePoint )\n                + \" at angle \" + this.angle.htmlAngle( asFormula );\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.curve );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","class PointIntersectCurves extends DrawingObject {\n\n    //curve1\n    //curve2\n    //verticalCrossPoint\n    //horizontalCrossPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.curve1 === \"undefined\")\n            this.curve1 = this.drawing.getObject(d.curve1);\n            \n        if (typeof this.curve2 === \"undefined\")\n            this.curve2 = this.drawing.getObject(d.curve2);\n\n        const curve1SI = this.curve1.asShapeInfo();\n        const curve2SI = this.curve2.asShapeInfo();\n\n        const intersections = Intersection.intersect(curve1SI, curve2SI);\n        \n        if ( intersections.points.length === 0 )\n        {\n            this.p = new GeoPoint(0,0);\n            throw new Error( \"No intersections found. \" );\n        }        \n        else if ( intersections.points.length === 1 )\n        {\n            this.p = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n        }\n        else if ( intersections.points.length > 1 )    \n        {\n            //Vertical correction has first dibs. verticalCrossPoint==\"One\" means highest point; horizontalCrossPoint==\"One\" means leftmost point\n            let minXPnt, maxXPnt, minYPnt, maxYPnt;\n            let selectedPoint;\n            for ( const intersect of intersections.points )\n            {\n                if (( ! minXPnt ) || ( intersect.x < minXPnt.x ))\n                    minXPnt = intersect;\n                if (( ! maxXPnt ) || ( intersect.x > maxXPnt.x ))\n                    maxXPnt = intersect;\n                if (( ! minYPnt ) || ( intersect.y < minYPnt.y ))\n                    minYPnt = intersect;\n                if (( ! maxYPnt ) || ( intersect.y > maxYPnt.y ))\n                    maxYPnt = intersect;\n            }\n            if ( minYPnt !== maxYPnt )\n            {\n                if ( this.data.verticalCrossPoint === \"One\" )\n                    selectedPoint = minYPnt;\n                else\n                    selectedPoint = maxYPnt;\n            }\n            else\n            {\n                if ( this.data.horizontalCrossPoint === \"One\" )\n                    selectedPoint = minXPnt;\n                else\n                    selectedPoint = maxXPnt;\n            }\n            this.p = new GeoPoint( selectedPoint.x, selectedPoint.y );\n        }\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, drawOptions ) {\n        this.drawDot(g, drawOptions );\n        this.drawLabel(g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        //TODO use a better name for this.curve, e.g. Arc_A_nn\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'intersect curve ' + this.refOf( this.curve1 ) \n                + \" with \" + this.refOf( this.curve2 );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.curve1 );\n        dependencies.add( this, this.curve2 );\n    }    \n\n}\n","class PointIntersectLineAndAxis extends DrawingObject {\n\n    //basePoint\n    //p1Line1\n    //p2Line1\n    //angle\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.drawing.getObject(d.basePoint);\n\n        if (typeof this.p1Line1 === \"undefined\")\n            this.p1Line1 = this.drawing.getObject(d.p1Line1);\n\n        if (typeof this.p2Line1 === \"undefined\")\n            this.p2Line1 = this.drawing.getObject(d.p2Line1);\n\n        if (typeof this.angle === \"undefined\")\n            this.angle = this.drawing.newFormula(d.angle);\n\n        const line1 = new GeoLine(this.p1Line1.p, this.p2Line1.p);\n\n        const otherPoint = this.basePoint.p.pointAtDistanceAndAngleDeg( 1, this.angle.value() );\n\n        const line2 = new GeoLine(this.basePoint.p, otherPoint );\n\n        this.p = line1.intersect(line2);\n        this.line = new GeoLine( this.basePoint.p, this.p );\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, drawOptions ) {\n        this.drawLine( g, drawOptions );\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' \n                + ' intersection of ' + this.refOf( this.p1Line1 ) \n                + \"-\" + this.refOf( this.p2Line1 ) \n                + \" with line from \" + this.refOf( this.basePoint ) \n                + \" at angle \" + this.angle.htmlAngle( asFormula );\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.p1Line1 );\n        dependencies.add( this, this.p2Line1 );\n        dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.angle );\n    }    \n\n\n}\n","\n\nclass PointLineIntersect extends DrawingObject {\n\n    //p1Line1\n    //p2Line1\n    //p1Line2\n    //p2Line2\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.p1Line1 === \"undefined\")\n            this.p1Line1 = this.drawing.getObject(d.p1Line1);\n        if (typeof this.p2Line1 === \"undefined\")\n            this.p2Line1 = this.drawing.getObject(d.p2Line1);\n        if (typeof this.p1Line2 === \"undefined\")\n            this.p1Line2 = this.drawing.getObject(d.p1Line2);\n        if (typeof this.p2Line2 === \"undefined\")\n            this.p2Line2 = this.drawing.getObject(d.p2Line2);\n\n        this.line1 = new GeoLine(this.p1Line1.p, this.p2Line1.p);\n        this.line2 = new GeoLine(this.p1Line2.p, this.p2Line2.p);\n        this.p = this.line1.intersect(this.line2);\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g, drawOptions ) {\n        this.drawDot(g, drawOptions );\n        this.drawLabel(g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: '\n                + 'intersect ' + this.refOf( this.p1Line1 )\n                + \"-\" + this.refOf( this.p2Line1 ) \n                + \" with \" + this.refOf( this.p1Line2 ) \n                + \"-\" + this.refOf( this.p2Line2 );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.p1Line1 );\n        dependencies.add( this, this.p1Line2 );\n        dependencies.add( this, this.p2Line1 );\n        dependencies.add( this, this.p2Line2 );\n    }    \n\n\n}\n","\n\nclass PointOfTriangle extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n    //p1Line1\n    //p2Line1\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.drawing.getObject(d.firstPoint);\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.drawing.getObject(d.secondPoint);\n\n        if (typeof this.p1Line1 === \"undefined\")\n            this.p1Line1 = this.drawing.getObject(d.p1Line1);\n        if (typeof this.p2Line1 === \"undefined\")\n            this.p2Line1 = this.drawing.getObject(d.p2Line1);\n\n            \n        const axisLine = new GeoLine( this.p1Line1.p, this.p2Line1.p );    \n\n        //otherLine is the hypotenous of the right angled triangle\n        const otherLine = new GeoLine( this.firstPoint.p, this.secondPoint.p );\n\n        //how long should we extend the axis line? \n        const l1 = new GeoLine( this.firstPoint.p, this.p1Line1.p );\n        const l2 = new GeoLine( this.firstPoint.p, this.p2Line1.p );\n        const l3 = new GeoLine( this.secondPoint.p, this.p1Line1.p );\n        const l4 = new GeoLine( this.secondPoint.p, this.p2Line1.p );\n        const maxDistance = Math.max( l1.length, l2.length, l3.length, l4.length ) + otherLine.length;\n\n        //Now we work out another point along the axis line that forms the right angle triangle \n        //with the otherLine.\n        //\n        //The trick here is to observe that all these points, for any axisLine will form an arc\n        //centered on the midpoint of otherLine with radiu of half length of otherLine\n\n        const midpoint = this.firstPoint.p.pointAtDistanceAndAngleRad( otherLine.length/2, otherLine.angle );\n        const arc = new GeoArc( midpoint, otherLine.length/2, 0, 360 );    \n\n        const intersectionPoint = axisLine.intersect( otherLine );\n        let extendedAxis;\n        //if intersectionPoint is along the line, then we'll have to triangles to choose from\n        \n        if ( (new GeoLine( this.firstPoint.p, intersectionPoint )).length < otherLine.length )\n            extendedAxis = new GeoLine( intersectionPoint, intersectionPoint.pointAtDistanceAndAngleRad( otherLine.length*2, axisLine.angle ) );\n        else\n            extendedAxis = new GeoLine( this.p1Line1.p, this.p1Line1.p.pointAtDistanceAndAngleRad( maxDistance, axisLine.angle ) );\n\n        this.p = extendedAxis.intersectArc( arc );\n\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, drawOptions ) {\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n                + \" Point along \" + this.refOf( this.p1Line1 )\n                + \"-\" + this.refOf( this.p2Line1 )\n                + \" that forms a right angle triangle with line  \" + this.refOf( this.firstPoint )\n                + \"-\" + this.refOf( this.secondPoint );\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.p1Line1 );\n        dependencies.add( this, this.p2Line1 );\n    }    \n\n}\n","\n\nclass PointShoulder extends DrawingObject {\n\n    //pShoulder\n    //p1Line1\n    //p2Line1\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.shoulderPoint === \"undefined\")\n            this.shoulderPoint = this.drawing.getObject(d.shoulderPoint);\n\n        if (typeof this.p1Line1 === \"undefined\")\n            this.p1Line1 = this.drawing.getObject(d.p1Line1);\n\n        if (typeof this.p2Line1 === \"undefined\")\n            this.p2Line1 = this.drawing.getObject(d.p2Line1);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.drawing.newFormula(d.length);\n\n        //Find the point that is length away from the shoulderPoint along\n        //the line p1Line1-p2line1.\n            \n        const axisLine = new GeoLine( this.p1Line1.p, this.p2Line1.p );    \n        const arc = new GeoArc( this.shoulderPoint.p, this.length.value(), 0, 360  );      \n        const offset = new GeoLine( this.shoulderPoint.p, this.p1Line1.p );\n        const extendedAxisLength = this.length.value() + offset.length;\n        const extendedAxis = new GeoLine( this.p1Line1.p, this.p1Line1.p.pointAtDistanceAndAngleRad( extendedAxisLength, axisLine.angle ) );\n\n        try {\n            this.p = extendedAxis.intersectArc( arc );\n        } catch (e) {\n            //Maybe the axisLine is going in the wrong direction, and therefore extending it's length didn't help.\n            //Try reversing axisLine...\n            const axisLine = new GeoLine( this.p2Line1.p, this.p1Line1.p );    \n            const arc = new GeoArc( this.shoulderPoint.p, this.length.value(), 0, 360  );      \n            const offset = new GeoLine( this.shoulderPoint.p, this.p2Line1.p );\n            const extendedAxisLength = this.length.value() + offset.length;\n            const extendedAxis = new GeoLine( this.p2Line1.p, this.p2Line1.p.pointAtDistanceAndAngleRad( extendedAxisLength, axisLine.angle ) );\n            this.p = extendedAxis.intersectArc( arc );    \n        }\n\n        this.line = new GeoLine( this.shoulderPoint.p, this.p );\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, drawOptions ) {\n        this.drawLine( g, drawOptions );\n        this.drawDot( g, drawOptions );\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n            + \" Point along \" + this.refOf( this.p1Line1 ) \n            + \"-\" + this.refOf( this.p2Line1 )\n            + \" being \" + this.length.htmlLength( asFormula ) \n            + \" from \" + this.refOf( this.shoulderPoint );\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.shoulderPoint );\n        dependencies.add( this, this.p1Line1 );\n        dependencies.add( this, this.p2Line1 );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","\n\nclass PointSingle extends DrawingObject {\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n        this.p = new GeoPoint(d.x, d.y);\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.p);\n    }\n\n\n    draw( g, drawOptions ) {\n        this.drawDot(g, drawOptions );\n        this.drawLabel(g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n            + \" point at x:\" + this.data.x + \", y:\" + this.data.y + \" from origin\"; //TODO add units\n    }\n\n\n    setDependencies( dependencies ) {\n    }    \n\n}\n","\n\nclass SplinePathInteractive extends DrawingObject {\n\n    constructor(data) {\n        super(data);\n\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = this.data.derivedName;        \n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if ( typeof this.nodes === \"undefined\" )\n        {\n            this.nodes = [];\n\n            try {\n                for( const pathNode of d.pathNode )\n                {\n                    pathNode.point   = this.drawing.getObject( pathNode.point );\n                    pathNode.angle1  = this.drawing.newFormula( pathNode.angle1 ); \n                    pathNode.length1 = this.drawing.newFormula( pathNode.length1 ); \n                    pathNode.angle2  = this.drawing.newFormula( pathNode.angle2 ); \n                    pathNode.length2 = this.drawing.newFormula( pathNode.length2 );\n\n                    this.nodes.push( { inAngle:   pathNode.angle1.value(),\n                                       inLength:  pathNode.length1.value(),\n                                       point:     pathNode.point.p,\n                                       outAngle:  pathNode.angle2.value(),\n                                       outLength: pathNode.length2.value() } );\n                }\n            } catch ( e ) {\n                this.error = e;\n                return;\n            }\n        }\n\n        this.curve = new GeoSpline( this.nodes );\n\n        this.midPoint = this.curve.pointAlongPathFraction( 0.5 );        \n        this.p = this.midPoint;\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust( this.p );\n        this.curve.adjustBounds( bounds );\n    }\n\n    \n    asShapeInfo()\n    {\n        return this.curve.asShapeInfo();\n    }\n\n\n    draw( g, drawOptions ) {\n\n        this.drawCurve(g, drawOptions );\n\n        //Where should we draw the label? half way along the curve? \n        this.drawLabel(g, drawOptions );\n    }\n\n\n    pointAlongPath( length ) {\n        return this.curve.pointAlongPath( length );\n    }   \n\n\n    html( asFormula ) {\n        let html = this.nameOf() + ': '\n                    +'curved path:';\n\n        const d = this.data;\n        \n        try {\n            let thtml = \"<table><tbody>\";\n            for( const i in d.pathNode )\n            {\n                const node = d.pathNode[i];\n                thtml += \"<tr><td>\";\n                thtml += this.refOf( node.point );\n                thtml += \"</td>\";\n\n                if ( i == 0 )\n                    thtml += \"<td></td><td></td>\";\n                else\n                    thtml +=    \"<td>\" + node.angle1.htmlAngle( asFormula ) \n                            + \"</td><td>\" + node.length1.htmlLength( asFormula ) + \"</td>\";\n\n                if ( i == (d.pathNode.length -1) )\n                    thtml += \"<td></td><td></td>\";\n                else\n                    thtml +=    \" <td>\" + node.angle2.htmlAngle( asFormula ) \n                            + \"</td><td>\" + node.length2.htmlLength( asFormula ) + \"</td>\";\n\n                thtml += \"</tr>\";         \n            }\n            thtml += \"</tbody></table>\";\n            html += thtml;\n        } catch ( e ) {\n            if ( ! this.error )\n                html += e;\n        }\n\n        return html;\n    }\n\n    \n    setDependencies( dependencies )\n    {\n        for( const pathNode of this.data.pathNode )\n        {\n            dependencies.add( this, pathNode.point );\n            dependencies.add( this, pathNode.angle1 );\n            dependencies.add( this, pathNode.angle2 );\n            dependencies.add( this, pathNode.length1 );\n            dependencies.add( this, pathNode.length2 );\n        }        \n    }    \n}\n","\n\nclass SplinePathUsingPoints extends DrawingObject {\n\n    constructor(data) {\n        super(data);\n\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = this.data.derivedName;        \n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if ( typeof this.nodes === \"undefined\" )\n        {\n            this.nodes = [];\n\n            for( const pathNode of d.pathNode )\n            {\n                pathNode.point = this.drawing.getObject( pathNode.point );\n            }\n\n            for( let i=0; i< d.pathNode.length; i+=3 )\n            {\n                this.nodes.push( { \n                                   inControlPoint:   (i-1)>0 ? this.data.pathNode[i-1].point.p : undefined,\n                                   point:            this.data.pathNode[i].point.p,\n                                   outControlPoint:  (i+1) < this.data.pathNode.length ? this.data.pathNode[i+1].point.p : undefined,\n                                   } );\n            }\n        }\n\n        this.curve = new GeoSpline( this.nodes );\n\n        this.midPoint = this.curve.pointAlongPathFraction( 0.5 );        \n        this.p = this.midPoint;\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust( this.p );\n\n        //Bounds will already have been adjusted for each node\n    }\n\n    \n    asShapeInfo()\n    {\n        return this.curve.asShapeInfo();\n    }\n\n\n    draw( g, drawOptions ) {\n        if ( this.lineVisible() )\n            this.drawPath( g, this.curve.svgPath(), drawOptions );\n\n        //Where should we draw the label? half way along the curve? \n        this.drawLabel( g, drawOptions );\n    }\n\n\n    pointAlongPath( length ) {\n        return this.curve.pointAlongPath( length );\n    }   \n\n\n    html( asFormula ) {\n        let html = this.nameOf() + ': '\n                   + 'curved path: ';\n\n        const d = this.data;\n\n        html += \"<table><tbody>\";\n\n        for( let i=0; i< d.pathNode.length; i+=3 )\n        {\n            html += \"<tr><td>\";\n\n            if ( (i-1)>0 )\n                html += this.refOf( this.data.pathNode[i-1].point );\n\n            html += \"</td><td>\";\n\n            html += this.refOf( d.pathNode[i].point );\n\n            html += \"</td><td>\";\n\n            if ( (i+1) < this.data.pathNode.length )\n                html += this.refOf(  this.data.pathNode[i+1].point );\n\n            html += \"</td></tr>\";                \n        }\n\n        html += \"</tbody></table>\";\n\n        return html;\n    }\n\n    \n    setDependencies( dependencies )\n    {\n        for( const n of this.data.pathNode )\n        {\n            dependencies.add( this, n.point );\n        }        \n    }    \n}\n","\nclass SplineSimple extends DrawingObject {\n\n    //startPoint - the spline start\n    //endPoint - the spline end\n    //angle1\n    //angle2 \n    //length1\n    //length2\n\n    constructor(data) {\n        super(data);\n\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = this.data.derivedName;        \n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.startPoint === \"undefined\")\n            this.startPoint = this.drawing.getObject(d.point1);\n\n        if (typeof this.endPoint === \"undefined\")\n            this.endPoint = this.drawing.getObject(d.point4);\n\n        if (typeof this.angle1 === \"undefined\")\n            this.angle1 = this.drawing.newFormula(d.angle1);\n\n        if (typeof this.angle2 === \"undefined\")\n            this.angle2 = this.drawing.newFormula(d.angle2);\n\n        if (typeof this.length1 === \"undefined\")\n            this.length1 = this.drawing.newFormula(d.length1);\n\n        if (typeof this.length2 === \"undefined\")\n            this.length2 = this.drawing.newFormula(d.length2);\n\n        this.curve = new GeoSpline( [ { inAngle: undefined, inLength: undefined, point: this.startPoint.p, outAngle: this.angle1.value(), outLength: this.length1.value() },\n                                       { inAngle: this.angle2.value(), inLength: this.length2.value(), point: this.endPoint.p, outAngle: undefined, outLength: undefined } ] );\n\n        this.midPoint = this.curve.pointAlongPathFraction( 0.5 );        \n        this.p = this.midPoint;\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        this.curve.adjustBounds( bounds );\n    }\n\n    \n    asShapeInfo()\n    {\n        return this.curve.asShapeInfo();\n    }\n\n\n    draw( g, drawOptions ) {\n        \n        if ( this.lineVisible() )\n            this.drawPath( g, this.curve.svgPath(), drawOptions );\n\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    pointAlongPath( length ) {\n        return this.curve.pointAlongPath( length );\n    }   \n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n                + 'spline from ' + this.refOf( this.startPoint ) \n                + \" angle \" + this.angle1.htmlAngle( asFormula ) \n                + \" length \" + this.length1.htmlLength( asFormula )\n            + \" to \" + this.refOf( this.endPoint ) \n            + \" angle \" + this.angle2.htmlAngle( asFormula ) \n            + \" length \" + this.length2.htmlLength( asFormula );\n    }\n\n    \n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.startPoint );\n        dependencies.add( this, this.endPoint );\n        dependencies.add( this, this.angle1 );\n        dependencies.add( this, this.angle2 );\n        dependencies.add( this, this.length1 );\n        dependencies.add( this, this.length2 );\n    }    \n}\n","class SplineUsingControlPoints extends DrawingObject {\n\n    //startPoint - the spline start\n    //startControlPoint\n    //endPoint - the spline end\n    //endControlPoint\n\n    constructor(data) {\n        super(data);\n\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = this.data.derivedName;        \n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.startPoint === \"undefined\")\n            this.startPoint = this.drawing.getObject(d.point1);\n\n        if (typeof this.startControlPoint === \"undefined\")\n            this.startControlPoint = this.drawing.getObject(d.point2);\n\n        if (typeof this.endControlPoint === \"undefined\")\n            this.endControlPoint = this.drawing.getObject(d.point3);\n\n        if (typeof this.endPoint === \"undefined\")\n            this.endPoint = this.drawing.getObject(d.point4);\n\n        this.curve = new GeoSpline( [ { point: this.startPoint.p, outControlPoint: this.startControlPoint.p },\n                                      { inControlPoint: this.endControlPoint.p,  point: this.endPoint.p } ] );\n\n        this.midPoint = this.curve.pointAlongPathFraction( 0.5 );        \n        this.p = this.midPoint;\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        this.curve.adjustBounds( bounds );\n    }\n\n    \n    asShapeInfo() {\n        return this.curve.asShapeInfo();\n    }\n\n\n    draw( g, drawOptions ) {\n\n        if ( this.lineVisible() )\n            this.drawPath( g, this.curve.svgPath(), drawOptions );\n\n        //Where should we draw the label? half way along the curve?\n        //this.drawDot(g, drawOptions);\n        this.drawLabel( g, drawOptions );\n    }\n\n\n    pointAlongPath( length ) {\n        return this.curve.pointAlongPath( length );\n    }   \n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n            + 'spline from ' + this.refOf( this.startPoint )\n            + \" using control point \" + this.refOf( this.startControlPoint )\n            + \" to \" + this.refOf( this.endPoint )\n            + \" using control point \" + this.refOf( this.endControlPoint );\n    }\n\n    \n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.startPoint );\n        dependencies.add( this, this.startControlPoint );\n        dependencies.add( this, this.endPoint );\n        dependencies.add( this, this.endControlPoint );\n    }    \n}\n","class TrueDart extends DrawingObject {\n\n    //p1Line1  2 points making up the line on which the dart sits. \n    //p2Line1\n    //point1 3 points that make up a V shape of the original dart, point1 and point3 lie on the baseline\n    //point2\n    //point3\n\n    constructor(data) {\n        super(data);\n        this.data.name = data.operationName;\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.point1 === \"undefined\")\n            this.point1 = this.drawing.getObject(d.point1);\n        if (typeof this.point2 === \"undefined\")\n            this.point2 = this.drawing.getObject(d.point2);\n        if (typeof this.point3 === \"undefined\")\n            this.point3 = this.drawing.getObject(d.point3);\n\n        if (typeof this.p1Line1 === \"undefined\")\n            this.p1Line1 = this.drawing.getObject(d.p1Line1);\n        if (typeof this.p2Line1 === \"undefined\")\n            this.p2Line1 = this.drawing.getObject(d.p2Line1);\n\n        const lineD2D1 = new GeoLine( this.point2.p, this.point1.p ); \n        const lineD2D3 = new GeoLine( this.point2.p, this.point3.p );    \n\n        let angleD2D1 = lineD2D1.angleDeg();\n        let angleD2D3 = lineD2D3.angleDeg();\n\n        let totalDartAngle = angleD2D1 - angleD2D3;\n\n        //edge case:\n        //if D2D1 angle is 10 and D2D3 is 350 (or vice versa) then it would be better to consider D2D3 to be -10. \n        if ( totalDartAngle > 180 )\n        {\n            angleD2D1 -= 360;\n            totalDartAngle = angleD2D1 - angleD2D3;\n        }\n        else if ( totalDartAngle < -180 ) \n        {\n            angleD2D3 -= 360;\n            totalDartAngle = angleD2D1 - angleD2D3;\n        }\n\n        const halfDartAngle = totalDartAngle /2;\n\n        const pointA1rotated = this.p1Line1.p.rotate( this.point2.p, -halfDartAngle );\n        const pointD1rotated = this.point1.p.rotate( this.point2.p, -halfDartAngle );\n        const pointA2rotated = this.p2Line1.p.rotate( this.point2.p, halfDartAngle );\n        //const pointD2rotated = this.point3.p.rotate( this.point2.p, halfDartAngle );\n\n        const lineA1RA2R = new GeoLine( pointA1rotated, pointA2rotated );\n        this.line = lineA1RA2R; //TEMP\n        const pointClosure = lineA1RA2R.intersect( new GeoLine( this.point2.p, pointD1rotated ) ); //could equally use pointD2rotated\n        this.p = pointClosure; //TEMP\n\n        this.td1 = pointClosure.rotate( this.point2.p, halfDartAngle );\n        this.td3 = pointClosure.rotate( this.point2.p, -halfDartAngle );\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust(this.td1);\n        bounds.adjust(this.td3);\n    }\n\n\n    draw( g, drawOptions ) {\n        this.drawLine( g, drawOptions ); //TEMP - though actually handy\n        this.drawDot( g, drawOptions ); //TEMP\n        this.drawLabel( g, drawOptions ); //TEMP\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n                + \" True darts baseline \" + this.refOf( this.p1Line1 )\n                + \"-\" + this.refOf( this.p2Line1 )\n                + \" original dart \" + this.refOf( this.point1 )\n                + \"-\" + this.refOf( this.point2 )\n                + \"-\" + this.refOf( this.point3 );\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.point1 );\n        dependencies.add( this, this.point2 );\n        dependencies.add( this, this.point3 );\n        dependencies.add( this, this.p1Line1 );\n        dependencies.add( this, this.p2Line1 );\n    }    \n\n}\n","class TrueDartResult extends DrawingObject {\n\n    //fromOperation\n\n    constructor(data) {\n        super(data);\n        this.name = this.data.name;\n    }\n\n\n    calculate(bounds) {\n        const d = this.data;\n\n        if (typeof this.fromOperation === \"undefined\")\n            this.fromOperation = this.drawing.getObject(d.fromOperation);\n\n        if ( this.name === this.fromOperation.data.trueDartResult1 )\n            this.p = this.fromOperation.td1;\n        else\n            this.p = this.fromOperation.td3;\n\n            /*\n        //if this.basePoint is a point... (if a curve, this is the midpoint)\n        if ( this.basePoint.p )\n            this.p = this.fromOperation.applyOperationToPoint( this.basePoint.p );\n\n        var operation = this.fromOperation;\n        var applyOperationToPointFunc = function( p ) {\n            return operation.applyOperationToPoint( p );\n        };\n\n        //else if this.basePoint.curve is a GeoSpline...\n        if ( this.basePoint.curve instanceof GeoSpline )\n        {\n            //so we get this captured and can just pass the function around\n            this.curve = this.basePoint.curve.applyOperation( applyOperationToPointFunc );\n        }\n        else if ( this.basePoint.line instanceof GeoLine ) //untested?\n        {\n            this.line = this.basePoint.line.applyOperation( applyOperationToPointFunc );\n        }\n        //TODO we might also have operated on an arc, circle, ellipse? Some might required a different approach that needs to be aligned with original behaviour\n\n        //This line would be useful if the operation, or operation result is selected. \n        //this.operationLine = new GeoLine(this.basePoint.p, this.p);\n        */\n\n        this.adjustBounds( bounds );\n    }\n\n\n    adjustBounds( bounds )\n    {\n        bounds.adjust( this.p );\n    }\n\n\n    getColor() {\n        return this.basePoint.getColor();\n    }\n\n    \n    getLineStyle() {\n        return this.basePoint.getLineStyle();\n    }\n\n\n    draw( g, drawOptions ) {\n\n        if ( this.p )\n            this.drawDot( g, drawOptions );\n            \n        if ( this.p )\n            this.drawLabel( g, drawOptions );\n    }\n\n\n    html( asFormula ) {\n        return this.nameOf() + ': '\n                + 'Dart point from ' + this.refOf( this.fromOperation );\n    }\n\n\n    setDependencies( dependencies ) {\n        dependencies.add( this, this.fromOperation );\n    }    \n\n}\n","//(c) Copyright 2019 Jason Dore\n//https://github.com/MrDoo71/PatternEditor\n\nclass Pattern {\n\n    constructor (data, options ) {\n        this.data = data;\n        this.options = options;\n        this.patternData = data.pattern;\n        this.variable = {};\n        this.measurement = {};\n        this.units = this.patternData.units ? this.patternData.units : \"cm\";\n        this.wallpapers = data.wallpaper;\n        this.patternNumberAndName = ( this.patternData.patternNumber ? this.patternData.patternNumber + \" \": \"\" ) + this.patternData.name;\n        this.bounds = new Bounds();\n        this.visibleBounds = new Bounds();\n\n        if ( typeof this.patternData.measurement !== \"undefined\" )\n        {\n            for ( const m of this.patternData.measurement ) {\n\n                //TODO test this variable that is a simple value...            \n                if (typeof m.value !== \"undefined\") \n                {\n                    m.constant = m.value;\n                    m.value = function () {\n                        return this.constant; \n                    };\n                    m.html = function() {\n                        return this.name + \": \" + this.constant + \" \" + this.units;\n                    };                    \n                }\n                else\n                {\n                    m.expression = new Expression( m.expression, this, null );\n                    m.value = function () {\n                        return this.expression.value(); \n                    };\n                    m.html = function(asFormula) {\n                        return this.name + \": \" + this.expression.html( asFormula );\n                    };\n                }\n                this.measurement[ m.name ] = m;\n                m.isMeasurement = true;\n            }\n        }        \n        \n        if ( typeof this.patternData.variable !== \"undefined\" )\n        {\n            //Register all variable before calculating their values in to deal with dependencies.\n            for ( const v of this.patternData.variable ) {\n                this.variable[ v.name ] = v;\n                v.isVariable = true;\n            }\n\n            //Now the variable are all registered, calculate their values.\n            for ( const v of this.patternData.variable ) { \n                 \n                //TODO test this variable that is a simple value...            \n                if (typeof v.constant !== \"undefined\") \n                {\n                    v.value = function () {\n                        return this.constant;\n                    };\n                    v.html = function() {\n                        return this.name + \": \" + this.constant + ( this.isOverridden ? \" (custom)\" : \"\" ) \n                    };\n                }\n                else\n                {\n                    v.expression = new Expression( v.expression, this, null );\n                    v.value = function () {\n                        return this.expression.value();\n                    };\n                    v.html = function(asFormula) {\n                        return this.name + \": \" + this.expression.html( asFormula ) + \" = \" + Number.parseFloat( this.value() ).toPrecision(4) ;\n                    };\n                }\n            }\n        }        \n\n        this.drawings = [];\n\n        //Cater for older JSON\n        if ( this.patternData.patternPiece )\n            this.patternData.drawing = this.patternData.patternPiece;\n\n        for( const drawing of this.patternData.drawing )\n        {\n            this.drawings.push( new PatternDrawing( drawing, this ) );\n        }   \n\n        this.analyseDependencies();\n    }\n\n\n    //Return the pattern local equivalent of this number of mm\n    getPatternEquivalentOfMM( mm )\n    {\n        switch( this.units )\n        {\n            case \"mm\" : return mm; \n            case \"cm\" : return mm/10;\n            default: return mm/25.4;\n        }\n    }\n\n\n    //Return the pattern local equivalent of this number of pts\n    getPatternEquivalentOfPT( pt )\n    {\n        switch( this.units )\n        {\n            case \"mm\" : return pt/72*25.4; \n            case \"cm\" : return pt/72*2.54;\n            default: return pt/72; //inch\n        }\n    }    \n\n\n    analyseDependencies() {\n        //Now build up dependency links\n        this.dependencies = { \n            dependencies: [], \n            add: function ( source, target ) { \n\n                if (( ! source ) || ( ! target ))\n                    return;\n\n                if (   ( target && typeof target.expression === \"object\" )\n                    && ( ! target.isMeasurement )\n                    && ( ! target.isVariable ) )\n                {\n                    if ( target.expression.addDependencies )\n                        target.expression.addDependencies( source, this );\n                    else\n                        console.log(\"Failed to add dependency for expression. Presumably due to earlier errors. \"); //nb. the expression is likely the original data, not our expression object\n                }\n                else if (   ( target instanceof DrawingObject )\n                         || ( target.isMeasurement )\n                         || ( target.isIncrement ) \n                         || ( target.isVariable ) \n                         )\n                    this.dependencies.push( { source: source, target: target } ); \n            }  \n        };\n        \n        if ( this.variable )\n        {\n            //nb this.variable is on object with variables as properties, not an array\n            for( const i in this.variable )\n            {\n                const v = this.variable[i];\n                if ( v.expression ) \n                {\n                    if ( typeof v.expression.addDependencies === \"function\" )\n                        v.expression.addDependencies( v, this.dependencies );\n                    else\n                        //cater for an variable invalidly having a constant and an expression\n                        console.log( \"v.expression does not have addDependencies \" );\n                }\n            }\n        }    \n    \n        for( const drawing of this.drawings )\n        {\n            for ( const dObj of drawing.drawingObjects ) \n            {\n                dObj.setDependencies( this.dependencies );\n            }\n\n            for ( const p of drawing.pieces ) \n            {\n                p.setDependencies( this.dependencies );\n            }\n        }\n        //TODO use a d3.map of a d3.set when we build up the data and then convert it to an array\n        //so that we can remove duplicates.\n    }\n\n\n    getVariable(name) {\n        if (typeof name === \"object\")\n            return name;\n        return this.variable[name];\n    }\n\n    getMeasurement(name) {\n        if (typeof name === \"object\")\n            return name;\n\n        const m = this.measurement[name];\n\n        if ( !m )\n            throw new Error( \"Measurment not found:\" + name );\n\n        return m;\n    }\n\n    getObject( name )\n    {\n        for( const drawing of this.drawings )\n        {\n            const obj = drawing.getObject( name, true /*restrict search to this piece*/ );\n            if ( obj )\n                return obj;\n        }\n        return null;\n    }\n\n\n    getDate() {\n        const t = new Date();\n        const date = ('0' + t.getDate()).slice(-2);\n        const month = ('0' + (t.getMonth() + 1)).slice(-2);\n        const year = t.getFullYear();\n        return `${year}-${month}-${date}`;\n    }\n}","//(c) Copyright 2023 Jason Dore\n//https://github.com/MrDoo71/PatternEditor\n\nclass Group {\n\n    constructor (data, drawing) {\n        this.data = data;\n        this.drawing = drawing;\n        this.name = data.name;\n        this.visible = data.visible;\n        this.update = data.update;\n        this.contextMenu = data.contextMenu;\n        this.showLength = data.showLength === \"none\" ? undefined : data.showLength; //line or label\n        this.members = [];\n\n        if ( this.data.member )\n            this.data.member.forEach( function(m){\n                const dObj = this.drawing.getObject( m, true );\n                if ( dObj )\n                {\n                    this.members.push( dObj );\n                    dObj.setIsMemberOfGroup( this );\n                }     \n            },this);\n    }\n}","//(c) Copyright 2023 Jason Dore\n//https://github.com/MrDoo71/PatternEditor\n\nclass Piece {\n\n    constructor (data, drawing) {\n        this.data = data;\n        this.drawing = drawing;\n        this.name = data.name;\n        this.detailNodes = data.detailNode;\n        this.internalPaths = data.internalPath;\n        this.dataPanels = data.dataPanel;\n        this.nodesByName = {};\n        this.calculated = false;\n        this.ignore = false;\n\n        if ( this.data.mx === undefined )\n            this.data.mx = 0;\n\n        if ( this.data.my === undefined )\n            this.data.my = 0;\n\n        if (( ! this.detailNodes ) || ( this.detailNodes.length < 2 ) )\n        {\n            console.log(\"Piece \" + this.name + \" has 0-1 nodes and is therefore invalid.\" );\n            this.ignore = true;\n            return;\n        }\n\n        for( const n of this.detailNodes )\n        {\n            const dObj =  this.drawing.getObject( n.obj, true );\n            if ( dObj ) \n            {\n                this.nodesByName[ n.obj ] = n;\n                n.dObj = dObj;\n\n                if ( dObj.error )\n                {\n                    //Don't try to calculate() this piece if any node has an error (or we could just skip broken nodes?)\n                    this.ignore = true;\n                    return;\n                }\n\n                if ( ! n.reverse )\n                    n.reverse = false;\n\n                if ( n.before !== undefined )\n                {\n                    n.before = this.drawing.newFormula( n.before );\n                    if ( typeof n.before === \"object\" )\n                        n.before = n.before.value(); //should we defer evaluating this fornula?\n                }\n        \n                if ( n.after !== undefined )\n                {\n                    n.after = this.drawing.newFormula( n.after );\n                    if ( typeof n.after === \"object\" )\n                        n.after = n.after.value(); //should we defer evaluating this fornula?\n                }\n            }\n            else\n            {\n                console.log(\"Couldn't match piece node to drawing object: \", n.obj );\n            }\n        }    \n\n        const resolve = function( objName, b ) {\n            return drawing.getObject( objName, b );\n        };\n\n        if ( this.internalPaths )\n            for( const ip of this.internalPaths )\n            {\n                if ( ! ip.node )\n                    continue; \n\n                ip.nodes = [];\n\n                // ip.nodes is not an array, then make it an array of the one thing\n                if ( ! Array.isArray( ip.node ) )\n                    ip.node = [ ip.node ];\n\n                for( const n of ip.node )\n                {\n                    const dObj = resolve( n, true );\n                    if ( dObj ) \n                        ip.nodes.push( dObj );\n                    else\n                        console.log(\"Couldn't match internal path node to drawing object: \", n );\n                }\n\n                ip.showLength = ip.showLength === \"none\" ? undefined : ip.showLength; //line or label\n            }\n                \n        if ( this.dataPanels )\n        {\n            for( const panel of this.dataPanels )\n            {\n                const pinsToResolve = [\"center\", \"topLeft\", \"bottomRight\", \"top\", \"bottom\"];\n                for ( const s of pinsToResolve )\n                    if ( panel[s] ) \n                        panel[s] = resolve( panel[s], true );\n\n                if ( panel.orientation === undefined )\n                    panel.orientation = \"\";\n                if ( panel.quantity === undefined )\n                    panel.quantity = \"\";\n                if ( panel.annotation === undefined )\n                    panel.quantity = \"\";\n                if ( panel.onFold === undefined )\n                    panel.onFold = false;\n                if ( panel.foldPosition === undefined )\n                    panel.foldPosition = \"\";\n\n                //type===Grainline doesn't have height or width\n                if ( panel.type === \"Grainline\" )\n                {\n                    panel.length = panel.length ? drawing.newFormula( panel.length ) : undefined;\n                }\n                else\n                {                \n                    panel.height = panel.height ? drawing.newFormula( panel.height ) : 0;\n                    panel.width = panel.width ? drawing.newFormula( panel.width ) : 0;\n                }\n            }\n        }\n\n        this.defaultSeamAllowance = this.drawing.newFormula( data.seamAllowanceWidth );\n        if ( typeof this.defaultSeamAllowance === \"object\" )\n            this.defaultSeamAllowance = this.defaultSeamAllowance.value(); //should we defer evaluating this fornula?\n\n        if ( this.name === this.drawing.pattern.data.options.targetPiece )\n        {\n            this.drawing.pattern.data.options.targetPiece = this;\n        }\n    }\n\n\n    calculate()\n    {\n        if ( this.ignore )\n            return;\n\n        for( const a of this.detailNodes )\n        {\n            const o = a.dObj;\n            if (( ! o?.p ) && ( ! o?.arc ) && ( ! o?.curve ))\n            {\n                console.log(\"Skipping piece calculations \" + this.name + \". Point not known for node \" + a );\n                return;\n            }\n        }\n\n        this.calculated = true;\n        console.log(\"*********\");\n        console.log(\"Prepare piece: \" + this.name );\n        let previousP; //not adjusted for seam allowance    \n\n        console.log(\"Pass 1 - direction and skipped nodes\" );\n        //Initial preparation, cut up any curves at notches, reverse curves if necessary, work out\n        //which points don't lead to any progress around the curve. \n        for (let a = 0; a < this.detailNodes.length+1; a++)   //+1 because we circle right around to the start\n        {  \n            const n = this.detailNodes[ ( a === this.detailNodes.length ) ? 0 : a ]; //circle back to the first object at the end. \n            const pn = this.detailNodes[ a-1 < 0 ? a-1+this.detailNodes.length : a-1 ]; \n            const nn = this.detailNodes[ a+1 >= this.detailNodes.length ? a+1-this.detailNodes.length : a+1 ];\n            const dObj = n.dObj;\n            const nObj = nn.dObj;\n\n            //A point can specify before and after SA. The point will have a line drawn to it from the previous position.\n            //This line should have a sa of n.before. \n\n            if ( ! (( dObj.curve instanceof GeoSpline ) || ( dObj.arc instanceof GeoArc )) )\n            {\n                if ( typeof n.before !== \"undefined\" )\n                    n.sa1 = 1.0 * n.before; //TODO formulas?\n                else \n                    n.sa1 = this.defaultSeamAllowance;\n\n                if ( typeof n.after !== \"undefined\" ) //string\n                    n.sa2 = 1.0 * n.after; //TODO formulas?\n                else\n                    n.sa2 = this.defaultSeamAllowance;\n            }\n         \n            if ( a === 0 ) //Note if first node is curve, then it could be done at the start. \n            {\n                if ( dObj.curve instanceof GeoSpline )\n                    previousP = dObj.curve.pointAlongPathFraction( n.reverse ? 0: 100) ; //this wouldn't be correct if the curve needed splitting, i.e. if this is a node on a curve\n                else if ((dObj.arc instanceof GeoArc ) || ( dObj.arc instanceof GeoEllipticalArc ))\n                    previousP = dObj.arc.pointAlongPathFraction( n.reverse ? 0 : 100);\n                else\n                    previousP = dObj.p;\n\n                console.log( \"Start at \" + n.obj + \" delay drawing starting at \" + previousP.toString() );\n            }\n            else \n            {                \n                if (    ( dObj.curve instanceof GeoSpline ) \n                     || ( dObj.arc instanceof GeoArc )\n                     || ( dObj.arc instanceof GeoEllipticalArc ) )\n                {\n                    console.log( \"Curve \" + n.obj + \" previous:\" + pn.obj + \" next:\" + nn.obj );\n\n                    let nObjCurveOrArc = nObj.curve instanceof GeoSpline ? nObj.curve\n                                                                         : ( nObj.arc instanceof GeoArc || nObj.arc instanceof GeoEllipticalArc ) ? nObj.arc : undefined; //instanceof GeoArc\n\n                    let nextP = nObjCurveOrArc ? nObjCurveOrArc.pointAlongPathFraction( nn.reverse?100:0 ) \n                                               : nObj.p;\n\n                    let dObjCurve = dObj.curve instanceof GeoSpline ? dObj.curve\n                                                                    : ( dObj.arc instanceof GeoArc || dObj.arc instanceof GeoEllipticalArc ) ? dObj.arc.asGeoSpline() : undefined; \n\n                    //What if previousP and/or nextP isn't on the spline? TODO allow for one of them to be, and one not to be\n                    let curveSegment;\n                    try {\n                        curveSegment = dObjCurve.splineBetweenPoints( previousP, nextP );\n                        //We found both points, and so we can work out the forward/reverse automatically\n\n                        //This would work generically for arcs and curves as curveSegment.pointAlongPathFraction(0); //and get these to be remembered\n                        let correctDirection = curveSegment.nodeData[0].point.equals( previousP );\n\n                        if ( ! correctDirection )\n                        {\n                            //maybe it doesn't match completely? \n                            //This would work generically for arcs and curves as curveSegment.pointAlongPathFraction(\n                            const lineToStart = new GeoLine( previousP, curveSegment.nodeData[0].point );\n                            const lineToEnd = new GeoLine( previousP, curveSegment.nodeData[ curveSegment.nodeData.length-1 ].point );\n                            if ( lineToStart.getLength() < lineToEnd.getLength() )\n                                correctDirection = true;\n                        }\n\n                        if ( (! correctDirection) != n.reverse )\n                            console.log(\"ERROR: Correct direction:\" + correctDirection + \" reverse?\" + n.reverse );\n\n                        if ( ! correctDirection )  //or we could use n.reverse\n                        {\n                            curveSegment = curveSegment.reverse();\n                            console.log( \"Spline reversed.\");\n                        }\n\n                        //If we find 0 or 1 points, then we have to trust the forward/reverse flag. \n\n                    } catch ( e ) {\n                        console.log( \"Piece: \" + this.name + \" previous and/or next nodes not on curve:\" + n.obj );\n                        //This is not an issue, it just means we're not clipping the start/end of the curve\n                        //But, we are now dependent on the reverse flag being set correctly as we cannot determine it ourselves. \n                        \n                        if ( n.reverse )\n                            curveSegment = (new GeoSpline( [...dObjCurve.nodeData] )).reverse();\n                        else \n                            curveSegment = dObjCurve;\n\n                        //NOW INTERSECT WITH start and end separately. \n                        try {\n                            const cut = curveSegment.cutAtPoint( previousP );\n                            if ( cut?.afterPoint )\n                            {\n                                curveSegment = cut.afterPoint;\n                            }\n                            else \n                            {\n                                //insert an explicit point for the implicit one, otherwise we'll be confused about direction\n                                console.log(\"Adding explit node for an implict start of curve\");\n                                const curveStartPoint = curveSegment.nodeData[0].point;\n                                const line = new GeoLine( previousP, curveStartPoint );\n                                const anglePreviousPThisP = line.angleDeg();\n                                const newNode = { obj: n.obj + \"_implicit_start\",\n                                                point: curveStartPoint,\n                                                line: line,\n                                                directionBeforeDeg: anglePreviousPThisP,\n                                                directionAfterDeg: anglePreviousPThisP,\n                                                skipPoint: false, \n                                                dObj: { p: curveStartPoint }};\n                                this.detailNodes.splice( a, 0, newNode );        \n                                a++;\n                            }\n                        } catch ( e2 ) {\n                        }\n\n                        try {\n                            //Do we need to add an explicit point for the end of the curve? Probably not                            \n                            const cut = curveSegment.cutAtPoint( nextP );\n                            if ( cut?.beforePoint )\n                                curveSegment = cut.beforePoint;\n                        } catch ( e2 ) {\n                        }\n                    }\n\n                    //Note, don't skip a point just because it is co-incident with the start of a curve\n                    //because the start of a curve has its own directionBeforeDeg, and yet the point in relation\n                    //to the previous point may be a different angle. \n\n                    previousP = curveSegment.pointAlongPathFraction(1);\n                    n.directionBeforeDeg = curveSegment.entryAngleDeg();\n                    n.directionAfterDeg = curveSegment.exitAngleDeg(); //or curveSegmentToDraw?\n                    n.curveSegment = curveSegment;\n                }\n                else if ( dObj.p )\n                {\n                    console.log( \"Other node \" + n.obj + \" previous:\" + pn.obj + \" next:\" + nn.obj );\n\n                    const thisP = dObj.p;\n\n                    const line = new GeoLine( previousP, thisP );\n                    //Is this the same point\n                    let samePoint = false;                    \n                    if ( thisP.equals( previousP ) )\n                        samePoint = true;\n                    else\n                    {\n                        //we could measure the distance and say its the same point if it is very very close\n                        console.log(\"Distance from previousP to thisP \" + line.getLength() );\n//make this tolerance dependent on this.drawing.pattern.units?                        \n                        if ( line.getLength() < 0.05 )\n                            samePoint = true;\n                    }\n\n                    if ( ( samePoint ) && ( a == this.detailNodes.length ) ) //we've cycled back to the first node. \n                    {\n                        n.point = thisP;\n                        n.line = line;\n\n                        //if ( n.directionBeforeDeg === undefined )\n                        //    n.directionBeforeDeg = n.directionAfterDeg;\n\n                        //if ( n.directionBeforeDeg === undefined )\n                            n.directionBeforeDeg = pn.directionAfterDeg;     \n                            n.directionAfterDeg = n.directionBeforeDeg;\n\n                        n.skipPoint = false; \n                    }\n                    else if ( ! samePoint ) //not the same point\n                    {\n                        console.log( \"Line to \" + n.obj );//+ \" startAt:\" + pn.obj + \" endAt:\" + nn.obj );\n                        n.point = thisP;\n                        n.line = line;\n                        const anglePreviousPThisP = (new GeoLine( previousP, thisP )).angleDeg();\n                        previousP = thisP;\n\n                        //if ( ! pn.directionAfterDeg )\n                        //    pn.directionAfterDeg = anglePreviousPThisP;\n\n                        n.directionBeforeDeg = anglePreviousPThisP;\n                        n.directionAfterDeg = anglePreviousPThisP;\n                        n.skipPoint = false; \n                    }\n                    else //same point\n                    {\n                        //A point on a spline is a way of controlling the before/after seam allowance\n                        console.log(\"Same point, no progress\");\n                        n.directionBeforeDeg = pn.directionAfterDeg;\n                        n.point = thisP; //even if skipping, we may need this for notches\n                        n.skipPoint = true; \n                    }\n                }\n\n                if ( pn.directionAfterDeg === undefined )\n                {\n                    pn.directionAfterDeg = n.directionBeforeDeg;\n\n                    if ( pn.directionBeforeDeg === undefined )  \n                        pn.directionBeforeDeg = pn.directionAfterDeg;                      \n                }\n\n                if ( n.skipPoint )\n                  console.log(\"Index:\" + a + \" skip\" );\n                else\n                  console.log(\"Index:\" + a + \" ends at \" + previousP.toString() + \", direction \" + Math.round(n.directionAfterDeg) );\n            }                    \n        };\n\n        //If we're not drawing the seamAllowance line, then no need\n        //to calculate it. \n        if ( ! this.data.seamAllowance )\n            return;\n\n        console.log(\"**********************\");\n        console.log(\"Pass 2 - add seam allowance\");\n        let currentSeamAllowance = this.defaultSeamAllowance;        \n        for (let a = 0; a < this.detailNodes.length; a++) {\n\n            const n = this.detailNodes[ a ];\n\n            if ( typeof n.sa1 != \"undefined\" )\n                currentSeamAllowance = n.sa1;\n\n            //console.log(\"Node \" + a + \" n.sa1:\" + n.sa1 + \" currentSeamAllowance:\" + currentSeamAllowance );                \n\n            n.tangentAfterDeg = n.directionAfterDeg + 90;\n            if ( n.tangentAfterDeg >= 360 ) //TODO >= ?\n                n.tangentAfterDeg -= 360;     \n\n            n.tangentBeforeDeg = n.directionBeforeDeg + 90;\n                if ( n.tangentBeforeDeg >= 360 ) //TODO >= ?\n                    n.tangentBeforeDeg -= 360;     \n\n            if ( n.skipPoint )\n            {\n                console.log( \"Node:\" + a + \" \" + n.obj + \" skip\");\n                n.pointEndSA = n.point.pointAtDistanceAndAngleDeg( currentSeamAllowance, n.tangentBeforeDeg );\n                if ( typeof n.sa2 !== \"undefined\" )\n                    currentSeamAllowance = n.sa2;\n                continue;\n            }\n    \n            let debugSA = \"\";\n    \n            if ( n.curveSegment )\n            {    \n\n                const parallelCurves = n.curveSegment.parallelCurve( currentSeamAllowance );\n\n                n.curveSegment = parallelCurves.baseCurve; //if we've added nodes to the curve, this would add them to the base curve too\n                n.curveSegmentSA = parallelCurves.offsetCurve;\n                if ( n.curveSegmentSA === n.curveSegment )\n                {\n                    //we copied the reference to the curve, but we'll might be meddling with the in/out points, so we need a copy\n                    n.curveSegmentSA = new GeoSpline( [...n.curveSegmentSA.nodeData]  );\n                }\n                n.pointStartSA = n.curveSegmentSA.pointAlongPathFraction(0);\n                n.pointEndSA = n.curveSegmentSA.pointAlongPathFraction(1);\n\n                debugSA = \" A:\" + n.pointStartSA.toString() + \" B:\" + n.pointStartSA.toString()                 \n            }\n            else\n            {\n                if ( currentSeamAllowance === 0 )\n                    n.pointStartSA = n.line.p1;\n                else\n                    n.pointStartSA = n.line.p1.pointAtDistanceAndAngleDeg( currentSeamAllowance, n.tangentBeforeDeg );\n\n                if ( typeof n.tangentAfterDeg !== \"undefined\" )\n                {\n                    if ( currentSeamAllowance === 0 )\n                        n.pointEndSA = n.line.p2;\n                    else\n                        n.pointEndSA = n.line.p2.pointAtDistanceAndAngleDeg( currentSeamAllowance, n.tangentAfterDeg ); //SA1 seems more compatible? \n                }\n                //Note if directionBeforeDeg==directionAfterDeg then there is effectively 1 point, and no intersection is necessary\n\n                n.lineSA = new GeoLine( n.pointStartSA, n.pointEndSA );\n\n                debugSA = \" A:\" + n.pointStartSA.toString() + \" B:\" + n.pointEndSA.toString() \n            }\n\n            console.log( \"Node:\" + a + \" \" + n.obj + \n                         \" directionBeforeDeg:\" + ( n.directionBeforeDeg === undefined ? \"undefined\" : Math.round(n.directionBeforeDeg) ) + \n                         \" directionAfterDeg:\" + ( n.directionAfterDeg === undefined ? \"undefined\" : Math.round(n.directionAfterDeg) ) +\n                         \" sa:\" + ( currentSeamAllowance ) +\n                         ( n.curveSegment ? \" curvesegment\" : n.line ? \" line\" : \" UNKNOWN\" ) + \" \" + debugSA);\n\n            if ( typeof n.sa1 === \"undefined\" )\n                n.sa1 = currentSeamAllowance;\n\n            if ( typeof n.sa2 !== \"undefined\" )\n                currentSeamAllowance = n.sa2;\n        }\n        console.log(\"**********************\");\n        console.log(\"**********************\");\n        console.log(\"Pass 3 - intersects\");\n\n        let pn = this.detailNodes[ this.detailNodes.length-1 ];\n        if ( pn.skipPoint )\n            pn = this.detailNodes[ this.detailNodes.length-2 ]; \n\n        for (let a = 0; a < this.detailNodes.length; a++) {\n\n            const n = this.detailNodes[ a ];\n            const nn = this.detailNodes[ a+1 >= this.detailNodes.length ? a+1-this.detailNodes.length : a+1 ];\n\n            if ( n.skipPoint )\n                continue;\n\n            //Now extend or trim lines and curves so that they intersect at the required points. \n            //See docs/intersectionsWithChangingSeamAllowance.svg\n\n            const sa1 = pn.sa1;\n            const sa2 = n.sa1;\n\n            let angleChange = n.directionBeforeDeg - pn.directionAfterDeg;\n            if ( angleChange < -180 )\n                angleChange += 360;\n            else if ( angleChange > 180 )\n                angleChange -= 360;\n\n            if ( Math.abs( angleChange ) > 179.99 )\n            {\n                console.log(\"Complete change of direction? n.obj:\" + n.obj + \" withPrevious:\" + pn.obj  );\n            }\n\n            if (    ( ( Math.abs( angleChange ) > 0.1 ) || ( sa2 != sa1 ) ) //must be at an angle change, or an sa change //TODO 0.01 ? \n                 && ( Math.abs( angleChange ) < 179.99 )\n                )\n            try {                \n                //Our intersect could be external, in which case it will be a small, straight extension to each existing path, OR\n                //our intersect could be internal, in which case each path needs to be shortened slightly.  It is this latter type\n                //that requires us to care about where curves intersection. \n\n                //+ve a left hand bend, the SAs collapse into each other\n                //-ve a right hand bend, the SAs need some filler \n\n                console.log(\"Need to do an intersection, n.obj:\" + n.obj + \" withPrevious:\" + pn.obj + \" directionChange:\" + angleChange + \" sa1:\" + sa1 + \" sa2:\" + sa2 ) ;\n\n\n                //matingAngle - the angle at which the change in SA perfectly tallies with the change in direction\n                let matingAngle = 0; //if sa2==sa1 then matingAngle == 0\n                \n                if (sa1 > sa2)\n                    matingAngle = Math.acos( sa2/sa1 ) * 360 / 2 / Math.PI;\n\n                if (sa2 > sa1)\n                    matingAngle = Math.acos( sa1/sa2 ) * 360 / 2 / Math.PI;\n\n                //Nb. if the smaller sa is zero, then the matingAngle is 90. \n\n                let matingAngle2 = - matingAngle; //for where angleChange < 0, i.e. right hand bend\n\n                //If moving from sa1 > sa2\n                //   then for angleChange >= matingAngle (60deg) then we just intersect the lines, neither needs extending\n                //        for matingAngle2 < angleChange < matingAngle then we need to add a bend to sa1\n                //        for angleChange <= matingAngle2 we extend both lines and intersect, or can determine the intesection point through trig.  \n                //\n                //If moving from sa1 < sa2 \n                //  then for angleChange >= matingAngle then we just intersect the lines, neither needs extending\n                //           -matingAngle < angleChange < matingAngle then we need to add a bend to sa2\n                //           angleChange <=  matingAngle we extend both lines and intersect, or can determine the intesection point through trig.  \n                //\n                //Therefore the only difference between these cases is which we add the bend to. \n\n                let trailingPath = pn.lineSA ? pn.lineSA : pn.curveSegmentSA;\n                let leadingPath = n.lineSA ? n.lineSA : n.curveSegmentSA;\n\n                if ( angleChange >= matingAngle )\n                {\n                    console.log( \"Angle change > \" + matingAngle + \" therefore just do intersects\" );\n                    //then we just intersect the lines/curves, neither needs extending, both need clipping\n                    const intersect = this.intersect( trailingPath,  leadingPath );\n                    trailingPath = this.clipEnd( trailingPath, intersect );\n                    leadingPath = this.clipStart( leadingPath, intersect );\n                    pn.pointEndSA = intersect;    \n                    n.pointStartSA = intersect;            \n                }\n                else if ( angleChange > matingAngle2 ) //&& angleChange < matingAngle (as we've just done that)\n                {\n                    console.log( \"Angle change between \" + matingAngle2 + \" and \" + matingAngle + \" need to cater for special cases\" );\n\n                    //add a bend if there is a change in sa\n                    if ( sa1 > sa2 )\n                    {\n                        //add the bend to the trailling piece, at least to the difference (sa1-sa2)\n                        if ( angleChange > 0 ) //left-hand\n                        {\n                            //add the bend, length=(sa1-sa2), and then intersect\n                            const reducedSAPoint = pn.pointEndSA.pointAtDistanceAndAngleDeg( (sa1-sa2), pn.directionAfterDeg-90 );\n                            const saChangeLine = new GeoLine( pn.pointEndSA, reducedSAPoint );\n                            const intersect = this.intersect( saChangeLine, leadingPath );\n                            leadingPath = this.clipStart( leadingPath, intersect );\n                            pn.reducedSAPoint = intersect;\n                            n.pointStartSA = intersect;\n                        }\n                        else //right-hand\n                        {\n                            //add the bend, with a calculated length and then just join to the leading piece. \n                            //a = acos( sa2/sa1 )\n                            const sa1Overlap = sa2 / Math.cos( angleChange / 360 * 2 * Math.PI );\n                            const reducedSAPoint = pn.pointEndSA.pointAtDistanceAndAngleDeg( sa1-sa1Overlap, pn.directionAfterDeg-90 );\n                            pn.reducedSAPoint = reducedSAPoint;\n                            //leadingPath - nothing to do, we'll just join with a line from reducedSAPoint to its start.\n                            //pn.pointEndSA unchanged;    \n                            //n.pointStartSA unchanged\n                        }\n                        \n                    }\n                    else if ( sa2 > sa1 )\n                    {\n                        //add the bend to the leading piece, at least (sa2-sa1)\n                        if ( angleChange > 0 ) //left hand\n                        {\n                            //use sa2-sa1 and intersect with the trailing line\n                            const increasingSAPoint = n.pointStartSA.pointAtDistanceAndAngleDeg( (sa2-sa1), n.directionBeforeDeg-90 );\n                            const saChangeLine = new GeoLine( n.pointStartSA, increasingSAPoint );\n                            const intersect = this.intersect( saChangeLine, trailingPath );\n                            trailingPath = this.clipEnd( trailingPath, intersect );\n                            pn.pointEndSA = intersect;\n                            n.increasingSAPoint = intersect;\n                            //n.pointStartSA = intersect;\n                        }\n                        else //right hand\n                        {\n                            //add a calculated length bend to the leading piece and just join the path to it. \n                            const sa2overlap = sa1 / Math.cos( angleChange / 360 * 2 * Math.PI );\n                            const increasingSAPoint = n.pointStartSA.pointAtDistanceAndAngleDeg( sa2-sa2overlap, n.directionBeforeDeg-90 );\n                            //trailingPath - nothing to do\n                            //pn.pointEndSA no change\n                            //n.pointStartSA no change\n                            n.increasingSAPoint = increasingSAPoint;\n                        }\n                    }\n                }\n                else\n                {\n                    console.log( \"Angle change less than \" + matingAngle2 + \" need to intersect extensions\" );\n\n                    //we extend both lines and intersect\n                    const trailExtensionLine = new GeoLine( pn.pointEndSA, pn.pointEndSA.pointAtDistanceAndAngleDeg( 10, pn.directionAfterDeg ) );\n                    const leadingExtensionLine = new GeoLine( n.pointStartSA.pointAtDistanceAndAngleDeg( -10, n.directionBeforeDeg ), n.pointStartSA );\n                    const intersect = trailExtensionLine.intersect( leadingExtensionLine );\n\n                    console.log( \"Intersect at \" + intersect.toString() );\n\n                    if ( trailingPath instanceof GeoSpline )\n                    {\n                        trailingPath.nodeData.push(  {  inControlPoint:   intersect,\n                                                        point:            intersect,\n                                                        outControlPoint:  undefined } );\n                        trailingPath.nodeData[ trailingPath.nodeData.length-2 ].outControlPoint = intersect;\n                    }\n                    else\n                    {\n                        trailingPath = new GeoLine( pn.pointStartSA, intersect ); //this is still just a straight line as we extended it straight\n                    }\n\n                    if ( leadingPath instanceof GeoSpline )\n                    {\n                        leadingPath.nodeData.unshift( { inControlPoint:   undefined,\n                                                        point:            intersect,\n                                                        outControlPoint:  intersect } );\n                        leadingPath.nodeData[1].inControlPoint = intersect;\n                    }\n                    else\n                    {\n                        leadingPath = new GeoLine( intersect, n.pointEndSA );                    \n                    }\n\n                    pn.pointEndSA = intersect;\n                    n.pointStartSA = intersect;\n                }        \n\n                if ( trailingPath instanceof GeoSpline )\n                    pn.curveSegmentSA = trailingPath;\n                else\n                    pn.lineSA = trailingPath;\n\n                if ( leadingPath instanceof GeoSpline )\n                    n.curveSegmentSA = leadingPath;\n                else\n                    n.lineSA = leadingPath;\n                \n\n            } catch ( e ) {\n                console.log(\"No intersect pn:\" + pn.obj + \" n:\" + n.obj );\n            } \n\n            pn = n;                     \n        }\n        console.log(\"**********************\");\n\n    }\n\n\n    intersect( trailingPath, leadingPath )\n    {\n        const trailingPathSI = trailingPath.asShapeInfo();\n        const leadingPathSI = leadingPath.asShapeInfo();        \n        let intersect;\n        try {\n            const intersections = Intersection.intersect(trailingPathSI, leadingPathSI);\n            intersect = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n\n            if ( intersections.length > 1 )\n                console.log( \"Intersections found (A). \" + intersections.length );\n\n        } catch ( e ) {\n            console.log( \"No intersections found (A). \" + pn.obj + \" and \" + n.obj );\n\n            try { \n                const intersections = Intersection.intersect( leadingPathSI, leadingPathSI );\n                intersect = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n                if ( intersections.length > 1 )\n                    console.log( \"Intersections found (B). \" + intersections.length );\n            } catch ( e ) {\n                console.log( \"No intersections found (B). \" + pn.obj + \" and \" + n.obj );\n            }\n        }\n        return intersect; //OR THROW? \n    }\n\n\n    clipEnd( trailingPath, intersect )\n    {\n        if ( trailingPath instanceof GeoSpline )\n        {\n            //TODO if cutAtPoint doesn't work we could go back to our original non-extended curve and just extend that in a straight line to our intersect point\n            return trailingPath.cutAtPoint( intersect ).beforePoint;\n        }\n        else\n        {\n            return new GeoLine( trailingPath.p1, intersect );\n        }\n    }\n\n\n    clipStart( leadingPath, intersect ) \n    {\n        if ( leadingPath instanceof GeoSpline )\n        {\n            //TODO if cutAtPoint doesn't work we could go back to our original non-extended curve and just extend that in a straight line to our intersect point\n            const split = leadingPath.cutAtPoint( intersect );\n            return split.afterPoint ? split.afterPoint : split.beforePoint;\n        }\n        else\n        {\n            return new GeoLine( intersect, leadingPath.p2 );\n        }\n    }\n\n\n    drawSeamLine( g, editorOptions ) \n    {\n        if ( this.ignore )\n            return;\n\n        if ( ! this.calculated )\n            this.calculate();\n\n        //console.log(\"Time to draw seam line: \", this.name );\n\n        const p = g.append(\"path\")\n                 .attr(\"id\",\"seam line - \" + this.name )\n                 .attr(\"class\", \"seamline\" )\n                 .attr(\"d\", this.svgPath( false ) )\n                 .attr(\"stroke-width\", ( this.getStrokeWidth()/2) ); //TODO this has to be set according to scale;\n        \n        if ( p.seamAllowance )\n            p.attr(\"stroke-dasharray\", \"2,0.2\" );\n\n        if ( editorOptions.downloadOption)\n            p.attr(\"fill\", \"none\" )\n             .attr(\"stroke\", \"#929292\");\n        else if ( ! editorOptions.skipDrawing )\n             p.attr( \"opacity\", \"0.5\" );\n \n    }\n\n\n    drawLabelsAlongSeamLine( g, useExportStyles ) \n    {\n        if ( this.ignore )\n            return;\n\n        if ( ! this.calculated )\n            this.calculate();\n\n        //console.log(\"Time to draw seam line labels: \", this.name );\n\n        let labelGroup;\n\n        for ( const n of this.detailNodes )\n        {\n            if ( n.label )\n            {\n                const fontSize = this.drawing.pattern.getPatternEquivalentOfMM(6);\n\n                if ( labelGroup === undefined )\n                    labelGroup = g.append(\"g\")\n                                  .attr( \"id\", this.name + \" - path labels\" );\n\n                if ( n.curveSegment)\n                    this.drawing.drawLabelAlongPath( labelGroup, n.curveSegment, n.label, fontSize, true );\n                else if ( n.line )\n                    this.drawing.drawLabelAlongPath( labelGroup, n.line, n.label, fontSize, true );\n            }\n        }\n    }\n\n\n    drawSeamAllowance( g, editorOptions ) \n    {\n        if ( this.ignore )\n            return;\n\n        if ( ! this.calculated )\n            this.calculate();\n\n        const p = g.append(\"path\")\n                 .attr(\"id\",\"seam allowance - \" + this.name )\n                 .attr(\"class\", \"seamallowance\" )\n                 .attr(\"d\", this.svgPath( true ) )\n                 .attr(\"stroke-width\", this.getStrokeWidth() ); //TODO this has to be set according to scale\n\n        if ( editorOptions.downloadOption )\n            p.attr(\"fill\", \"none\")\n             .attr(\"stroke\", \"black\");\n        else if ( ! editorOptions.skipDrawing )\n            p.attr( \"opacity\", \"0.5\" );\n    } \n\n\n    drawNotches( g, useExportStyles  )\n    {\n        if ( this.ignore )\n            return;\n\n        if ( ! this.detailNodes )\n            return;\n\n        if ( ! this.calculated )\n            this.calculate();\n\n        const notches = g.append(\"g\").attr( \"id\", this.name + \" - notches\");\n        console.log(\"*********\");\n        console.log(\"notches: \" + this.name );\n\n        const strokeWidth = this.getStrokeWidth();\n\n        for (const n of this.detailNodes) \n        {\n            if ( typeof n.notch === \"undefined\" )\n                continue;\n\n            const notchAngle = n.notchAngle === undefined ? 0 : n.notchAngle;\n            const notchCount = n.notchCount === undefined ? 1 : n.notchCount;\n            //default length of 0.25 is presumably 1/4 inch, not 0.25mm!. We treat 0.25 in the binding as not-set and not marshalled,\n            //so if we get undefined here it means use the default notch length. \n            const notchLength = n.notchLength === undefined ? this.drawing.pattern.getPatternEquivalentOfMM( 0.25*25.4 ) : n.notchLength; \n            const notchWidth  = n.notchWidth === undefined ? this.drawing.pattern.getPatternEquivalentOfMM( 0.25*25.4 ) : n.notchWidth;      \n\n            const roundForSVG = this.roundForSVG;\n\n            const drawNotch = function( point, pointSA, tangentDeg, sa ) {\n\n                let path = \"\";\n\n                //One notch : 0    \n                //Two notches : -0.5 +0.5    0-1  1-1   n-(c/2)+0.5\n                //Three notches : -1 0 +1             \n                for( let i = 0;  i < notchCount; i++ )\n                {\n                    const offset = i-(notchCount/2)+0.5;\n\n                    const drawNotchMark = function( p, notchLength, otherPoint ) {\n\n                        const offsetAmount = offset * notchWidth;\n                        let start = p;\n                        if ( offset != 0 )\n                            start = start.pointAtDistanceAndAngleDeg( offsetAmount, tangentDeg + 90 );\n\n                        let end;\n                        if ( notchLength === undefined ) //drawing one notch from seamline to seamallowanceline\n                            end = offset == 0 ? otherPoint\n                                              : otherPoint.pointAtDistanceAndAngleDeg( offsetAmount, tangentDeg + 90 );\n                        else\n                            end = start.pointAtDistanceAndAngleDeg( notchLength, tangentDeg + 180 + notchAngle );\n\n                        //notchType == \"slit\"\n                        //TODO: tNotch; uNotch; vInternal vExternal castle diamond\n                        path += \"M\" + roundForSVG( start.x ) + \",\" + roundForSVG( start.y ) + \" L\" + roundForSVG( end.x ) + \",\" + roundForSVG( end.y );\n                    }\n\n                    //In deliberate variation to Seamly2D, if notchLength < seamAllowance, and notchAngle == 0 then draw the notch from the seam\n                    //allowance line to the seam line, but only if...\n                    //there is a non-zero seam allowance, and there isn't specified \n                    //notch length.\n                    if (     ( pointSA ) \n                          && ( sa > 0 )\n                          && ( notchAngle === 0 ) \n                          && ( n.notchLength === undefined ||  notchLength < sa ) )\n                    {\n                        drawNotchMark( pointSA, undefined, point );\n                    }\n                    else if ( pointSA ) \n                    {\n                        drawNotchMark( pointSA, notchLength );\n                        drawNotchMark( point, notchLength );\n                    }\n                    else\n                        drawNotchMark( point, notchLength );\n                }\n\n                //TODO should we connect these D3 data-wise to the notches\n                const p = notches.append(\"path\")\n                    .attr(\"d\", path )\n                    .attr(\"class\", \"notch\" )\n                    .attr(\"stroke-width\", strokeWidth); //TODO this has to be set according to scale\n\n                if ( useExportStyles )\n                    p.attr(\"fill\", \"none\")\n                        .attr(\"stroke\", \"black\");\n            };\n\n            if ( n.notchesAlongPath !== undefined )            \n            {\n                //3 along the path means cutting it into 4.\n                for ( let j=1; j<=n.notchesAlongPath; j++ )\n                {\n                    //1,2,3\n                    const fractionAlongLine = j / ( n.notchesAlongPath + 1); //0.25, 0.5, 0.75\n                    const p = n.curveSegment.pointAlongPathFraction( fractionAlongLine );\n                    const sa = n.sa1;\n                    const tinyBitFurtherAlongLine = fractionAlongLine + 0.0001;\n                    const p2 = n.curveSegment.pointAlongPathFraction( tinyBitFurtherAlongLine );\n                    const tangentDeg = (new GeoLine( p, p2 )).angleDeg() + 90.0;\n                    const pSA = n.curveSegmentSA === undefined ? undefined : p.pointAtDistanceAndAngleDeg( sa, tangentDeg );\n                    drawNotch( p, pSA, tangentDeg, sa );\n                }\n            }\n            else if ( n.point !== undefined )\n            {\n                //Normal point notch\n                const tangentDeg = n.pointEndSA ? (new GeoLine( n.point, n.pointEndSA)).angleDeg() : n.tangentAfterDeg;\n                drawNotch( n.point, n.pointEndSA, tangentDeg, n.sa2 );\n            }\n        };\n    }    \n\n\n    drawInternalPaths( g, useExportStyles  )\n    {\n        if ( this.ignore )\n            return;\n\n        let internalPathsGroup;\n\n        const strokeWidth = Math.round( this.getStrokeWidth()/2 * 10000 )/10000;\n\n        if ( this.internalPaths )\n        {\n            for( const ip of this.internalPaths )\n            {\n                if ( internalPathsGroup === undefined )\n                    internalPathsGroup = g.append(\"g\")\n                                          .attr(\"id\", this.name + \" - internal paths\");        \n\n                if ( ip.nodes )\n                    this.drawInternalPath( internalPathsGroup, ip, strokeWidth, useExportStyles );\n            }\n        }\n    }\n\n\n    drawInternalPath( internalPathsGroup, internalPath, strokeWidth, useExportStyles )\n    {\n        if ( this.ignore )\n            return;\n\n        let path; //path as SVG\n        let geopath; //path as GeoSpline - so we can find the mid-point for adding the length\n\n        let previousP;\n        for  (let a=0; a<internalPath.nodes.length; a++ )\n        {\n            const n = internalPath.nodes[ a ];\n            \n            let curve;\n\n            if (( n.arc instanceof GeoArc ) || ( n.arc instanceof GeoEllipticalArc ))\n                curve = n.arc.asGeoSpline();\n            else if ( n.curve instanceof GeoSpline )\n                curve = n.curve;\n\n            if ( curve )\n            {\n                if ( previousP )\n                {\n                    const cut = curve.cutAtPoint( previousP );\n                    curve = cut.afterPoint ? cut.afterPoint : cut.beforePoint;\n                }\n\n                const nextNode = a+1 < internalPath.nodes.length ? internalPath.nodes[ a+1 ] : undefined;\n                if ( nextNode?.p )\n                {\n                    const cut = curve.cutAtPoint( nextNode.p );\n                    curve = cut.beforePoint;\n                }\n\n                path = curve.svgPath( path );\n                geopath = geopath === undefined ? curve : geopath.extend( curve );\n                previousP = curve.pointAlongPathFraction(1);\n            }\n            else\n            {\n                path = this.lineTo( path, n.p );\n                geopath = geopath === undefined ? new GeoSpline([{  inControlPoint:   undefined,\n                                                                    point:            n.p,\n                                                                    outControlPoint:  n.p } ]) : geopath.extend( n.p );\n                previousP = n.p;\n            }\n        }\n\n        //nb path and geopath.svgPath() should be equivalent, though they won't be identical.\n        //console.log( \"Path \" + path );\n        //console.log( \"GeoPath \" + geopath );\n\n        if ( internalPath.showLength !== undefined ) //we don't draw a label, though we could use label as 100% and line as 50%\n        {\n            //TODO use non-semantic-scaling font size that we use for labels\n            let l = geopath.pathLength(); //\"TODO\";//this.getLengthAndUnits();\n\n            if ( l !== undefined )\n            {\n                const patternUnits = this.drawing.pattern.units;\n                const precision = patternUnits === \"mm\" ? 10.0 : 100.0;\n                l = Math.round( precision * l ) / precision;            \n                l = l + \" \" + patternUnits;    \n            }\n\n            const fontSize = this.drawing.pattern.getPatternEquivalentOfMM(6); //6mm equiv\n            this.drawing.drawLabelAlongPath( internalPathsGroup, geopath, l, fontSize, true );    \n        }\n\n        const p = internalPathsGroup.append(\"path\")\n            .attr(\"d\", path )\n            .attr(\"class\", \"internalpath\" )\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke-width\", strokeWidth); //TODO this has to be set according to scale\n\n        if ( useExportStyles )\n            p.attr(\"stroke\", \"black\");\n\n        if ( internalPath.lineStyle ) \n        {\n            let dasharray;\n\n            switch( internalPath.lineStyle )\n            {\n                case \"dotLine\":        dasharray = \"0.25 0.25\"; break;\n                case \"dashLine\":       dasharray = \"1 0.25\"; break;\n                case \"dashDotLine\":    dasharray = \"1 0.25 0.25 0.25\"; break;\n                case \"dashDotDotLine\": dasharray = \"1 0.25 0.25 0.25 0.25 0.25\"; break;\n            }\n        \n            if ( dasharray )\n                p.attr(\"stroke-dasharray\", dasharray );  \n        }\n    }\n\n\n    drawMarkings( g, editorOptions )\n    {\n        const useExportStyles = editorOptions.downloadOption;\n\n        if ( this.ignore )\n            return;\n        \n\n        if ( this.dataPanels )\n        {\n            for( const panel of this.dataPanels )\n            {\n                if ( panel.type === \"Grainline\" )\n                    this.drawGrainLine( g, editorOptions, panel );\n                else\n                    this.drawDataPanel( g, useExportStyles, panel );\n            }\n        }\n    }\n\n\n    drawGrainLine( g, editorOptions, grainline )\n    {\n        //Rotation\n        //CenterPin\n        //Length\n        //TopLeft / BottomRight ?????\n        //Arrows Front Both ????\n        //Visible TODO\n        //MX/MY not needed\n        const useExportStyles = editorOptions.downloadOption;\n        let end1, end2;\n\n        if (( typeof grainline.top === \"object\" ) && ( typeof grainline.bottom === \"object\" ))\n        {\n            end1 = grainline.bottom.p;\n            end2 = grainline.top.p; //Front\n        }\n        else\n        {\n            const length = ( typeof grainline.length === \"object\" ) ? grainline.length.value() : undefined;    \n            if ( ! length )\n                return;\n\n            let x,y;\n            if ( typeof grainline.center === \"object\" )\n            {   \n                x = grainline.center.p.x;\n                y = grainline.center.p.y;\n            }\n        \n            //If nothing useful, then center the panel in the piece's bounds\n            if ( x === undefined ) \n            {\n                const bounds = new Bounds();\n                this.adjustBounds( bounds );\n                x = ( bounds.minX + bounds.maxX ) / 2;\n                y = ( bounds.minY + bounds.maxY ) / 2;\n            }\n\n            const center = new GeoPoint( x, y );\n            end1 = center.pointAtDistanceAndAngleDeg( length/2, grainline.rotation + 180 );\n            end2 = center.pointAtDistanceAndAngleDeg( length/2, grainline.rotation );\n        }\n\n        const l = g.append(\"line\")\n                    .attr(\"class\",\"grainline\")\n                    .attr(\"x1\", end1.x)\n                    .attr(\"y1\", end1.y)\n                    .attr(\"x2\", end2.x)\n                    .attr(\"y2\", end2.y)\n                    .attr(\"stroke-width\", this.getStrokeWidth() );\n        \n        const arrowurl = \"url(#\" + editorOptions.arrowId + \")\";\n        const arrows = grainline.arrows ? grainline.arrows : \"Both\";\n        if (    ( arrows === \"Rear\" ) \n             || ( arrows === \"Both\" ) )\n            l.attr( \"marker-start\", arrowurl );\n\n        if (    ( arrows === \"Front\" ) \n             || ( arrows === \"Both\" ) )\n             l.attr( \"marker-end\", arrowurl );\n\n        if ( useExportStyles )\n            l.attr(\"stroke\", \"black\");\n    }\n\n\n    drawDataPanel( g, useExportStyles, panel )\n    {\n        const lineSpacing = 1.2;\n        const dataItems = panel.type === \"Info\" ? this.drawing.pattern.patternData.labelline : panel.dataItem;        \n\n        if (    ( ! dataItems )\n             || ( dataItems.length === 0 ) )\n            return; \n\n        //Note: the fontSize specified by the pattern will act as a max\n        //font size if the available width is greater than the text needs.\n        //But if there is too much text for the width and size then the \n        //text will be shrunk. \n        const baseFontSizePts = panel.fontSize == 0 ? 16 : panel.fontSize;\n\n        //in pattern units\n        let fontSize = this.drawing.pattern.getPatternEquivalentOfPT( baseFontSizePts ); \n\n        let width = ( typeof panel.width === \"object\" ) ? panel.width.value() : undefined;        \n        let height = ( typeof panel.height === \"object\" ) ? panel.height.value() : undefined;        \n    \n        let align = \"start\";                \n\n        let x;\n        let y;\n\n        //Specify two corners, overrides specified height/width\n        if (( typeof panel.topLeft === \"object\" ) && ( typeof panel.bottomRight === \"object\" ))\n        {\n            x = panel.topLeft.p.x;\n            y = panel.topLeft.p.y;\n\n            width = panel.bottomRight.p.x - x;\n            height = panel.bottomRight.p.y - y;\n        }\n        else if ( typeof panel.topLeft === \"object\" ) \n        {   \n            x = panel.topLeft.p.x;\n            y = panel.topLeft.p.y;\n            //nb we'll use the specified width/height if populated\n        }        \n        else if ( typeof panel.center === \"object\" )\n        {   \n            x = panel.center.p.x;\n            y = panel.center.p.y;\n            //nb we'll use the specified width/height if populated\n            align = \"middle\"; //We'll center align text\n        }\n        else if ( typeof panel.bottomRight === \"object\" )\n        {\n            x = panel.bottomRight.p.x;\n            y = panel.bottomRight.p.y;\n            //nb we'll use the specified width/height if populated\n            align = \"end\"; \n        }\n\n        //If nothing useful, then center the panel in the piece's bounds\n        if ( x === undefined ) \n        {\n            const bounds = new Bounds();\n            this.adjustBounds( bounds );\n            x = ( bounds.minX + bounds.maxX ) / 2;\n            y = ( bounds.minY + bounds.maxY ) / 2;\n            align = \"middle\";\n            y = y + (dataItems.length * fontSize * lineSpacing / 2)\n        }\n\n        //Panel has a fontsize specfieid in points.  This is the em for the font, and we'll \n        //approximate this as the width of an m, even though thats not quite what it means. \n\n        const dataLines = [];\n        let minFontSize = panel.fontSize;\n        let maxFontSize = panel.fontSize; \n        let maxLineLengthPts = 0;\n        let labelHeightPts = 0;\n        \n        for( const dataItem of dataItems )\n        {\n            let text = dataItem.text;\n\n            if ( text.includes( \"%date%\" ) )\n                text = text.replace(\"%date%\", this.drawing.pattern.getDate() );\n\n            if ( text.includes( \"%pLetter%\" ) )\n                text=text.replace( \"%pLetter%\", panel.letter );\n            \n            if ( text.includes( \"%pName%\" ) )\n                text=text.replace( \"%pName%\", this.name );\n\n            if ( text.includes( \"%pOrientation%\" ) )\n                text=text.replace( \"%pOrientation%\", panel.orientation );\n\n            if ( text.includes( \"%pQuantity%\" ) )\n                text=text.replace( \"%pQuantity%\", panel.quantity );\n\n            if ( text.includes( \"%pAnnotation%\" ) )\n                text=text.replace( \"%pAnnotation%\", panel.annotation );\n\n            if ( text.includes( \"%wOnFold%\" ) )\n                text=text.replace( \"%wOnFold%\", panel.onFold ? \"on fold\" : \"\" );\n\n            if ( text.includes( \"%pFoldPosition%\" ) )\n                text=text.replace( \"%pFoldPosition%\", panel.foldPosition );\n\n            if ( text.includes( \"%pFileName%\" ) )\n            {\n                //We don't have the concept of a filename \n                text=text.replace( \"%pFileName%\", \"\" );\n                if ( text.length === 0 )\n                    continue; //omit line if it would now be empty\n            }\n\n            if ( text.includes( \"%mFileName%\" ) )\n                text=text.replace( \"%mFileName%\", this.drawing.pattern.patternData.measurementsName ); \n\n            if ( text.includes( \"%author%\" ) )\n            {\n                const author = this.drawing.pattern.patternData.author;\n                text=text.replace( \"%author%\", author ? author : \"\" );\n                if ( text.length === 0 )\n                    continue; //omit line if it would now be empty \n            }\n    \n            if ( text.includes( \"%patternNumber%\" ) )\n            {\n                let patternNumber = this.drawing.pattern.patternData.patternNumber;\n                if ( patternNumber === undefined )\n                    patternNumber = \"\";\n                text=text.replace( \"%patternNumber%\", patternNumber );\n            }\n\n            if ( text.includes( \"%patternName%\" ) )\n                text=text.replace( \"%patternName%\", this.drawing.pattern.patternData.name );\n\n            dataItem.processedText = text;\n            dataItem.fontSizePts = baseFontSizePts + ( dataItem.fontSizeIncrement ? dataItem.fontSizeIncrement : 0 );\n            dataItem.lineHeightPts = dataItem.fontSizePts * lineSpacing;\n\n            const lineLengthPts = text?.length * dataItem.fontSizePts * 0.5; //TODO + sfIncrement\n            if ( lineLengthPts > maxLineLengthPts )\n                maxLineLengthPts = lineLengthPts;\n\n            labelHeightPts += dataItem.lineHeightPts;\n        }\n\n        //panel with pts\n        const maxLineWidthPatternUnits = this.drawing.pattern.getPatternEquivalentOfPT( maxLineLengthPts );\n        //console.log( \"Max line length (local): \" + maxLineWidthPatternUnits );\n\n        //So if we have a data panel with of 4inch, but long text in a large font size, then something\n        //has to give. So scale the fontsize. \n        let panelScaleX = 1;\n        let panelScaleY = 1;\n        if (    width > 0\n             && maxLineWidthPatternUnits > 0 )\n            panelScaleX = width / maxLineWidthPatternUnits;\n\n        //TODO update this with sfIncrement\n        const heightInPatternUnits = this.drawing.pattern.getPatternEquivalentOfPT( labelHeightPts );\n        if (   height > 0\n            && heightInPatternUnits > 0 )\n           panelScaleY = height / heightInPatternUnits;\n\n        const fontSizeScaling = Math.min( 1, panelScaleX, panelScaleY );\n        fontSize *= fontSizeScaling;\n\n        if ( align === \"middle\" )\n        {\n            y -= dataItems.length * fontSize * lineSpacing / 2;\n            x -= fontSizeScaling * maxLineWidthPatternUnits / 2;\n        }\n\n        let transform = \"translate(\" + x + \",\" + y + \")\";\n\n        //for better compatibility we should rotate around the centre point\n        //at least if \"middle\"\n        if ( panel.rotation )\n            transform += \" rotate(\" + ( -1 * panel.rotation ) + \")\";\n\n        const dataPanelGroup = g.append(\"text\")\n                                .attr(\"id\",\"data panel:\" + panel.letter )\n                                .attr(\"class\",\"patternlabel\")\n                                .attr(\"transform\", transform )\n                                .attr(\"font-size\", fontSize );\n\n        for( const dataItem of dataItems )\n        {\n            let text = dataItem.processedText;\n\n            const tspan = dataPanelGroup.append(\"tspan\")\n                            .attr(\"x\", \"0\" )\n                            .attr(\"dy\", this.drawing.pattern.getPatternEquivalentOfPT( dataItem.lineHeightPts * fontSizeScaling ) )\n                          //TODO  dataItem.alignmentType left/right/center/default\n                          //  .attr(\"text-anchor\", align )\n                            .text( text );\n\n            if ( dataItem.bold )\n                tspan.attr( \"font-weight\", \"bold\" );\n\n            if ( dataItem.italic )\n                tspan.attr( \"font-style\", \"italic\" );\n\n            if ( dataItem.fontSizeIncrement )\n                tspan.attr( \"font-size\", this.drawing.pattern.getPatternEquivalentOfPT( dataItem.fontSizePts * fontSizeScaling ) );\n        }\n    }\n\n\n    convertMMtoPatternUnits( mm )\n    {\n        if ( this.drawing.pattern.units = \"cm\" )\n            return mm/10;\n        else if ( this.drawing.pattern.units = \"mm\" )\n            return mm;\n        else //inches\n            return mm/25.4;\n    }\n\n\n    getStrokeWidth( isOutline, isSelected )\n    {\n        if ( this.drawing.pattern.data.options.lifeSize ) \n            return this.drawing.pattern.getPatternEquivalentOfMM(0.4); //0.4mm equiv\n            \n        return Math.round( 1000 * ( isOutline ? 7.0 : ( isSelected ? 3.0 : 1.0 ) ) / scale / fontsSizedForScale ) /1000;\n    }\n\n\n    svgPath( withSeamAllowance )\n    {\n        if ( this.ignore )\n            return;\n\n        if ( ! this.detailNodes )\n            return;\n\n        console.log(\"*********\");\n        console.log(\"svgPath: \" + this.name + \" seamAllowance:\" + withSeamAllowance );\n\n        let path;\n        let pn = this.detailNodes[ this.detailNodes.length -1 ];\n\n        for (let a = 0; a < this.detailNodes.length+1; a++) {  //+1 because we circle right around to the start\n\n            const n = this.detailNodes[ ( a == this.detailNodes.length ) ? 0 : a ]; //circle back to the first object at the end. \n         \n            if ( n.skipPoint )\n                continue;\n\n            if ( withSeamAllowance )\n            {\n                if ( pn.reducedSAPoint ) //nb if !path then M rather than L as below? \n                    path = this.lineTo( path, pn.reducedSAPoint );\n\n                if ( n.increasingSAPoint ) //nb if !path then M rather than L as below? \n                    path = this.lineTo( path, n.increasingSAPoint );\n            }\n\n            if ( n.curveSegment )\n            {\n                const curveSegmentToDraw = withSeamAllowance ? n.curveSegmentSA : n.curveSegment;\n\n                path = curveSegmentToDraw.svgPath( path ) + \" \";\n            }\n            else\n            {\n                const thisP = withSeamAllowance ? n.pointEndSA : n.point;\n\n                if ( withSeamAllowance && n.pointStartSA )\n                {\n                    path = this.lineTo( path, n.pointStartSA );\n                }\n\n                path = this.lineTo( path, thisP );\n            }\n\n            pn = n;\n        };\n\n        //TODO actually close the SVG path? \n\n        //console.log( \"Path: \" + path );\n\n        return path;        \n    }\n\n\n    lineTo( path, p )\n    {\n        if ( ! path )\n            path = \"M\" + this.roundForSVG( p.x ) + \",\" + this.roundForSVG( p.y ) + \" \";\n        else\n            path += \"L\" + this.roundForSVG( p.x ) + \",\" + this.roundForSVG( p.y ) + \" \";\n\n        return path;\n    }\n\n\n    adjustBounds( bounds, includeOffset )\n    {\n        if ( this.ignore )\n            return;\n\n        if ( ! this.detailNodes )\n            return;\n\n        if ( ! this.calculated )\n        {\n            try {\n                this.calculate();\n            } catch ( e ) {\n                console.log(\"Error adjusting bounds for \" + this.name + \". \", e );\n            }\n        }\n\n        const mx = includeOffset && this.data.mx ? this.data.mx : 0.0;\n        const my = includeOffset && this.data.my ? this.data.my : 0.0;\n        const offset = { mx: mx, my: my };\n\n        for ( const n of this.detailNodes ) {\n\n            if ( n.pointEndSA )\n                bounds.adjustToIncludeXY( n.pointEndSA.x + mx, n.pointEndSA.y + my );\n\n            if ( n.pointStartSA )\n                bounds.adjustToIncludeXY( n.pointStartSA.x + mx, n.pointStartSA.y + my );\n\n            if ( n.curveSegmentSA )\n                n.curveSegmentSA.adjustBounds( bounds, offset ); \n\n            //In case we're not drawing the seam allowance.     \n            if ( n.point )\n                bounds.adjustToIncludeXY( n.point.x + mx, n.point.y + my );\n            else if ( n.curveSegment )\n                n.curveSegment.adjustBounds( bounds, offset );\n        }\n    }\n\n\n    roundForSVG( n )\n    {\n        return Math.round( n * 1000 ) / 1000;\n    }\n\n\n    setDependencies( dependencies ) \n    {\n        if ( this.ignore )\n            return;\n\n        for ( const d of  this.detailNodes ) \n        {\n            dependencies.add( this, d.dObj );\n\n            //TODO also drawing objects used by expressions used as node seam allowances\n        }\n\n        if ( this.internalPaths )\n        {\n            for( const ip of this.internalPaths )\n            {\n                if ( ! ip.nodes )\n                    return; \n                \n                for( const n of ip.nodes )\n                {\n                    dependencies.add( this, n );\n                }\n            }\n        }\n\n        //TODO also nodes used as anchors for data. \n    }    \n\n\n    sanitiseForHTML ( s ) {\n        return s.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;').replaceAll('\"', '&quot;');\n    };\n\n\n    html() \n    {\n        //for the table\n        return \"piece: <span class=\\\"ps-name\\\">\" + this.sanitiseForHTML( this.name ) + \"</span>\";\n    }\n\n\n    drawPiece( editorOptions )\n    {\n        if ( ! this.calculated )\n            this.calculate();\n\n        const simplify = ( editorOptions.thumbnail ) && ( editorOptions.targetPiece === \"all\" );        \n        const g = this.svg;\n        g.selectAll().remove();\n\n        if ( this.data.seamAllowance )\n            this.drawSeamAllowance( g, editorOptions ); //do this first as it is bigger and we want it underneath in case we fill \n\n        if ( ! this.data.hideMainPath )    \n            this.drawSeamLine( g, editorOptions );\n\n        if ( ! simplify )\n        {\n            const useExportStyles = editorOptions.downloadOption;\n\n            this.drawInternalPaths( g, useExportStyles );\n            this.drawNotches( g, useExportStyles );\n            this.drawMarkings( g, editorOptions ); //label, grainline\n            this.drawLabelsAlongSeamLine( g, useExportStyles );\n        }\n    }\n}","//(c) Copyright 2019 Jason Dore\n//https://github.com/MrDoo71/PatternEditor\n\n\n\nclass PatternDrawing {\n\n    constructor (data, pattern) {\n        this.data = data;\n        this.drawing = {};\n        this.pattern = pattern;\n        this.textPathSeq = 0;\n\n        if (data) {\n            this.name = data.name;\n            this.drawingObjects = data.drawingObject;\n        }\n        else {\n            this.drawingObjects = [];            \n        }\n        this.bounds = new Bounds();\n        this.visibleBounds = new Bounds();\n        this.groups = [];\n        this.pieces = [];\n\n        if ( pattern ) //always true, except in some test harnesses\n        {\n            this.bounds.parent = pattern.bounds;\n            this.visibleBounds.parent = pattern.visibleBounds;\n        }\n\n        this.init();\n    }\n    \n    init() {\n        if (!this.data)\n            return;\n        \n        //Take each drawingObject in the JSON and convert to the appropriate \n        //type of object.\n        for ( const a in this.drawingObjects ) {\n            let dObj = this.drawingObjects[a];\n            dObj = this.newDrawingObj(dObj);\n            \n            if (dObj === null)\n                continue;\n            \n            this.drawingObjects[a] = dObj; //these are now the objects with methods\n            this.drawing[dObj.data.name] = dObj;\n            dObj.drawing = this;    \n            this.calculateObj(dObj);\n        }\n\n        //Take each group in the JSON and convert to an object. \n        //After this the isVisible() method on the drawingObject will work. \n        if ( this.data.group )\n            for ( let a=0; a<this.data.group.length; a++ ) {\n                this.groups[a] = new Group( this.data.group[a], this );\n            }\n        \n        if ( this.data.piece )\n            for ( let a=0; a<this.data.piece.length; a++ ) {\n                this.pieces[a] = new Piece( this.data.piece[a], this );\n            }\n\n        const options = this.pattern.data.options; \n        if ( options && ( typeof options.targetPiece === \"object\" ) )\n        {\n            options.targetPiece.adjustBounds( this.visibleBounds );\n        }\n        else if ( options && ( options.targetPiece === \"all\" ) ) //TODO also an array with specific multiple pieces specified\n        {\n            for ( const p of this.pieces ) {\n\n                //Skip non-default pieces when making thumbnail\n                if ( options.thumbnail && ! p.data.inLayout )\n                    continue;\n\n                p.adjustBounds( this.visibleBounds, true );\n            }\n        }\n        else\n        {\n            //This ensures the seam allowance is included in the bounds\n            if ( this.pieces )\n            {\n                for ( const p of this.pieces ) {\n                    p.adjustBounds( this.visibleBounds );\n                }    \n            }\n\n            //Calculate the visible bounds            \n            for ( const dObj of this.drawingObjects )\n            {\n                if (   ( dObj.isVisible( options ) )\n                    && ( dObj.data.lineStyle !== \"none\" ) )         \n                {\n                    try {\n                        dObj.adjustBounds( this.visibleBounds );\n                    } catch ( e ) {\n                        console.log(\"Error adjusting bounds for \" + dObj.name + \" \", e );\n                    }\n                }\n            }\n        }\n\n    }\n\n    \n    getObject(name, thisPieceOnly) {\n        if (typeof name === \"object\")\n            return name;\n\n        const objOnThisPiece = this.drawing[name];\n        if ( objOnThisPiece )\n            return objOnThisPiece;\n\n        //If we are finding a drawing object for a length etc. then we are allowed to reference other\n        //pieces.  And should ask the pattern for the object. But if we are here because we are scanning the whole pattern\n        //already then we shouldn't recurse back to the pattern.\n        if ( ! thisPieceOnly )\n            return this.pattern.getObject(name);\n    }\n\n    //TODO make this a static method of DrawingObject\n    newDrawingObj(dObj) {\n        switch( dObj.objectType )\n        {\n            case \"pointSingle\":               return new PointSingle(dObj);\n            case \"pointEndLine\":              return new PointEndLine(dObj);\n            case \"pointAlongLine\":            return new PointAlongLine(dObj);\n            case \"pointAlongPerpendicular\":   return new PointAlongPerpendicular(dObj);\n            case \"pointAlongBisector\":        return new PointAlongBisector(dObj);            \n            case \"pointFromXandYOfTwoOtherPoints\": return new PointFromXandYOfTwoOtherPoints(dObj);\n            case \"pointIntersectLineAndAxis\": return new PointIntersectLineAndAxis(dObj);\n            case \"line\":                      return new Line(dObj);\n            case \"pointLineIntersect\":        return new PointLineIntersect(dObj);\n            case \"pointIntersectArcAndAxis\":  return new PointIntersectArcAndAxis(dObj);\n            case \"pointIntersectArcAndLine\":  return new PointIntersectArcAndLine(dObj);\n            case \"perpendicularPointAlongLine\": return new PerpendicularPointAlongLine(dObj);\n            case \"pointOfTriangle\":           return new PointOfTriangle(dObj);            \n            case \"pointShoulder\":             return new PointShoulder(dObj);            \n            case \"arcSimple\":                 return new ArcSimple(dObj);\n            case \"arcElliptical\":             return new ArcElliptical(dObj);\n            case \"splineSimple\":              return new SplineSimple(dObj);\n            case \"splineUsingPoints\":         return new SplineUsingControlPoints(dObj);\n            case \"splinePathInteractive\":     return new SplinePathInteractive(dObj);\n            case \"splinePathUsingPoints\":     return new SplinePathUsingPoints(dObj);\n            case \"cutSpline\":                 return new CutSpline(dObj);\n            case \"pointCutSplinePath\":        return new PointCutSplinePath(dObj);      \n            case \"pointCutArc\":               return new PointCutArc(dObj);                              \n            case \"pointIntersectCurves\":      return new PointIntersectCurves(dObj);      \n            case \"pointIntersectCurveAndAxis\":return new PointIntersectCurveAndAxis(dObj);      \n            case \"pointIntersectArcs\":        return new PointIntersectArcs(dObj);      \n            case \"pointIntersectCircles\":     return new PointIntersectCircles(dObj);                  \n            case \"operationMove\":             return new OperationMove(dObj);                  \n            case \"operationRotate\":           return new OperationRotate(dObj);                  \n            case \"operationFlipByAxis\":       return new OperationFlipByAxis(dObj);                  \n            case \"operationFlipByLine\":       return new OperationFlipByLine(dObj);                  \n            case \"operationResult\":           return new OperationResult(dObj);                  \n            case \"pointFromArcAndTangent\":    return new PointFromArcAndTangent(dObj);                  \n            case \"pointFromCircleAndTangent\": return new PointFromCircleAndTangent(dObj);                  \n            case \"trueDart\":                  return new TrueDart(dObj);                              \n            case \"trueDartResult\":            return new TrueDartResult(dObj);                              \n            case \"arcWithLength\":             return new ArcWithLength(dObj);                              \n        default:\n            const fail = new PointSingle( {x:0, y:0, contextMenu:dObj.contextMenu } );\n            fail.error =  \"Unsupported drawing object type:\" + dObj.objectType;\n            return fail;\n        }\n    }\n\n    newFormula(formula) {\n\n        const patternUnits = this.pattern.units;\n        const f = formula;\n        if (typeof formula.constant !== \"undefined\") {\n            f.value = function () {\n                return this.constant;\n            };\n            f.html = function() {\n                return this.constant;\n            };\n            f.htmlLength = function() {\n                const precision = patternUnits === \"mm\" ? 10.0 : 100.0;\n                const s = Math.round( precision * this.constant ) / precision;\n                return '<span class=\"const\">' + s + \" \" + patternUnits + '</span>';\n            };\n            f.htmlAngle = function() {\n                const s = Math.round( 10.0 * this.constant ) / 10.0;\n                return '<span class=\"const\">' + s + \"&#176;\" + '</span>';\n            };\n        }\n        else if (typeof formula.expression === \"object\") {\n            f.expression = new Expression( f.expression, this.pattern, this );\n            f.value = function (currentLength) {\n                const v = f.expression.value(currentLength);\n                if ( Number.isNaN( v ) )\n                    throw new Error( \"Formula result is not a number. \" );\n                return v;\n            };\n            f.html = function( asFormula, currentLength ) {\n                return f.expression.html( asFormula, currentLength );\n            };\n            f.htmlLength = function( asFormula, currentLength ) {\n                let s = f.expression.html( asFormula, currentLength );\n                if ( ! asFormula )\n                {\n                    const precision = patternUnits === \"mm\" ? 10.0 : 100.0;\n                    s = Math.round( precision * s ) / precision;\n                    s += \" \" + patternUnits;\n                }\n                return s;\n            };\n            f.htmlAngle = function( asFormula, currentLength ) {\n                let s = f.expression.html( asFormula, currentLength );\n                if ( ! asFormula )\n                {\n                    s = Math.round( 10.0 * s ) / 10.0;\n                    s += \"&#176;\"; //degrees\n                }\n                return s;\n            };\n        }\n        return f;\n    }\n\n    calculateObj(dObj) {\n\n        if (typeof dObj.calculate !== \"undefined\") {\n            \n            try {\n                dObj.calculate(this.bounds);\n\n            } catch (e) {\n                dObj.error = \"Calculation failed. \" + e;\n            }\n\n        }\n    }\n\n    pointSingle(data) {\n        data.objectType = \"pointSingle\";\n        const dObj = this.add( data );\n        return dObj;\n    }\n\n    add(data) {\n        console.log(\"Add() is this used anywhere?\");\n\n        if (this.defaults) {\n            for (const d in this.defaults) {\n                if (typeof data[d] === \"undefined\")\n                    data[d] = this.defaults[d];\n            }\n        }\n        const dObj = this.newDrawingObj(data);\n        this.drawingObjects.push(dObj);\n        this.drawing[dObj.data.name] = dObj;\n        dObj.drawing = this;\n        this.calculateObj(dObj);\n        return dObj;\n    }\n\n\n    setDefaults(defaults) {\n        this.defaults = defaults;\n    }\n\n\n    //Add a label (to svg group g) positioned midway along path\n    drawLabelAlongPath( g, path, label, fontSize, followPathDirection )\n    {\n        fontSize = fontSize ? fontSize \n                            : Math.round( 1300 / scale / fontsSizedForScale )/100; //if both scale == 1 then 13.0 underlying units\n\n        if ( followPathDirection )\n        {   \n            //Use a parallel path inset from the one provided\n            if ( path instanceof GeoSpline )\n                path = path.parallelCurve( -fontSize ).offsetCurve;\n            else if ( path instanceof GeoLine )\n                path = new GeoLine( path.p1.pointAtDistanceAndAngleDeg( -fontSize, path.angleDeg() + 90 ),\n                                    path.p2.pointAtDistanceAndAngleDeg( -fontSize, path.angleDeg() + 90 ) );\n\n            const pathSVG = path.svgPath();\n            const pathID = \"tp\" + CryptoJS.MD5( pathSVG ).toString();\n            g.append(\"path\")\n                .attr( \"id\", pathID )\n                .attr( \"visibility\", \"hidden\" )\n                .attr( \"fill\", \"none\" )\n                .attr( \"d\", pathSVG ); \n\n            g.append(\"text\")\n                .attr(\"class\",\"alongPath\")\n                .attr(\"font-size\", fontSize )\n                .append( \"textPath\" )\n                .attr( \"xlink:href\", \"#\" + pathID )\n                .attr( \"startOffset\", \"50%\" )\n                .attr( \"text-anchor\", \"middle\" )\n                .attr( \"side\", \"left\" )\n                .text( label ); \n            return;\n        }\n        \n        try {\n            const p = path.pointAlongPathFraction(0.5);\n            let a = 0; //horizontal, unless we get an angle. \n            if ( path instanceof GeoLine  )\n            {\n                a = path.angleDeg();\n            }\n            else if ( path instanceof GeoSpline )\n            {\n                const p2 = path.pointAlongPathFraction(0.5001);\n                const lineSegment = new GeoLine(p, p2);\n                a = lineSegment.angleDeg();\n            }\n\n            if ( ! p )\n                throw new Error( \"Failed to determine position for label.\" );\n\n            {\n                let baseline = \"middle\";\n                let align = \"middle\";\n                let ta = 0;\n                let dy = 0;\n                //const patternUnits = this.drawing.pattern.units;\n                // /const spacing = (fontSize * 0.2);\n                const spacing = this.pattern.getPatternEquivalentOfMM(1);\n    \n                if ( followPathDirection )\n                {\n                    baseline = \"hanging\"; //For Safari, handing doesn't work once rotated\n                    ta = -a;\n                    dy = spacing;\n                }\n                else\n                {\n                    // East(ish)\n                    if ((( a >= 0 ) && ( a <45 )) || (( a > 270 ) && ( a <= 360 )))\n                    {\n                        baseline = \"hanging\"; //For Safari, handing doesn't work once rotated\n                        ta = - a;\n                        dy = spacing;\n                    }\n                    // West(ish)\n                    else if (  (( a >= 135 ) && ( a <225 )) \n                    )//|| (( a > 270 ) && ( a <315 ))  )\n                    {\n                        baseline = \"hanging\";\n                        ta = - (a-180);\n                        dy = spacing;\n                    }\n                    //North(ish)\n                    else if (( a > 45 ) && ( a < 135 )) \n                    {\n                        baseline = \"middle\";//\"auto\"\n                        align = \"middle\";\n                        ta = -a;\n                        p.x -= spacing;\n                    }\n                    //South(ish)\n                    else if (( a > 225 ) && ( a <= 270 )) \n                    {\n                        baseline = \"auto\"\n                        align = \"middle\";\n                        ta = - ( a-180 );\n                        p.x -= spacing;\n                    }\n                }\n\n                g.append(\"text\")\n                .attr(\"class\",\"alongPath\")\n                .attr( \"transform\", \"translate(\" + p.x + \",\" + p.y +  \") rotate(\"+ta+\")\" )\n                .attr( \"dominant-baseline\", baseline ) //if we're drawing below the line. \n                .attr( \"text-anchor\", align ) //if we're drawing to the left of the line\n                .attr( \"dy\", dy + \"px\" ) //need to also scale this\n                .attr(\"font-size\", fontSize + \"px\")\n                .text( label ); //TODO make this more generic to cater for different types.\n    \n            }\n        } catch ( e ) {\n            console.log( \"Failed to show length. \", e );            \n        }\n    }    \n}\n\n","//(c) Copyright 2019-20 Jason Dore\n//\n//Inspired by the excellent Seamly2D/Valentina pattern drawing software.\n//This library is a ground up implementation in Javascript intended to be compatible with, but\n//not based on, the Seamly2D/Valentina pattern making systen in order to support the community\n//pattern sharing website https://my-pattern.cloud/ . \n//\n//Source maintained at: https://github.com/MrDoo71/PatternEditor\n\nlet selectedObject;\nlet linksGroup;\nlet fontsSizedForScale = 1;\nlet fontResizeTimer;\nlet updateServerTimer;\nlet timeOfLastTweak;\nlet doDrawingAndTable;\n\nfunction drawPattern( dataAndConfig, ptarget, graphOptions ) \n{\n    //Remove the svg if called by graph_kill\n    if ( dataAndConfig === null )\n    {\n        const parent = document.getElementById(ptarget).parentNode;\n        const child = document.getElementById(ptarget);\n        parent.removeChild(child);\n        return ;\n    } \n\n    //This is a graph initialisation\n\n    if ( ! dataAndConfig.options )\n        dataAndConfig.options = {};\n\n    const options = dataAndConfig.options;\n\n    options.interactionPrefix = graphOptions.interactionPrefix;\n\n    const targetdiv = d3.select( \"#\" + ptarget )\n                       .append( \"div\" )\n                       .attr( \"class\", \"pattern-editor\" );\n\n    let pattern;\n    try {\n        pattern = new Pattern( dataAndConfig, graphOptions );            \n    } catch ( e ) {\n        if ( ! options.thumbnail )\n            targetdiv.append(\"div\")\n                .attr( \"class\", \"alert alert-warning\" )\n                .text( \"Pattern draw failed.\");\n\n        console.log(\"Failed to load pattern: \", e );\n\n        try {\n            const failMessage = 'FAIL:' + e.message;\n            const failMessageHash = CryptoJS.MD5( failMessage ).toString();\n            if (    ( options.returnSVG !== undefined ) \n                 && ( dataAndConfig.options.currentSVGhash !== failMessageHash )\n                 && ( options.returnID ))\n            {\n                const kvpSet = newkvpSet(true);\n                kvpSet.add( 'svg', failMessage );\n                kvpSet.add( 'id', options.returnID ) ;\n                goGraph( options.interactionPrefix + ':' + options.returnSVG, fakeEvent(), kvpSet);\n            }\n        } catch ( f ) {\n        }\n        \n        return;\n    }\n\n    if ( options.allowPanAndZoom === undefined )\n        options.allowPanAndZoom = true;\n\n    if ( options.showFormulas === undefined )\n        options.showFormulas = true;\n\n    if ( options.drawingTableSplit === undefined )\n        options.drawingTableSplit = 0.66;\n\n    if ( options.skipDrawing === undefined )\n        options.skipDrawing = false;\n\n    if ( options.skipPieces === undefined )\n        options.skipPieces = false;\n\n    if ( options.thumbnail === undefined )\n        options.thumbnail = false;\n\n    if ( options.interactive === undefined )\n        options.interactive = ! options.thumbnail;\n\n    if ( options.lastMixedSplit === undefined )\n        options.lastMixedSplit = options.drawingTableSplit > 0.0 && options.drawingTableSplit < 1.0 ? options.drawingTableSplit : 0.66;\n\n    if ( ! options.viewOption )\n        options.viewOption = [  { \"mode\":\"drawing\", \"icon\": \"fa-regular fa-image\",       \"drawingTableSplit\": 1.0 },\n                                { \"mode\":\"mixed\",   \"icon\": \"fa-solid fa-table-columns\",       \"drawingTableSplit\": 0.5 },\n                                { \"mode\":\"table\",   \"icon\": \"fa-solid fa-align-justify\", \"drawingTableSplit\": 0 } ];\n\n    // show menu on right-click.\n    const contextMenu = options.interactive && typeof goGraph === \"function\" ? function(d) {\n        if ( d.contextMenu )\n        {\n            d3.event.preventDefault() ;\n            const v = newkvpSet(false) ;\n            v.add(\"x\", d.x) ;   \n            v.add(\"y\", d.y) ;    \n            goGraph( graphOptions.interactionPrefix + ':' + d.contextMenu ,\n                    d3.event, \n                    v ) ;\n        }\n    } : undefined; //function(d){};     \n\n    options.layoutConfig = { drawingWidth: 400,\n                             drawingHeight: 600,\n                             drawingMargin: 0,\n                             tableWidth: 400,\n                             tableHeight: 600,\n                             tableMargin: 0 };\n\n    if ( ! options.translateX )                                           \n        options.translateX = 0;\n\n    if ( ! options.translateY )                                           \n        options.translateY = 0;\n\n    if ( ! options.scale )                                           \n        options.scale = 1;\n\n    options.setDrawingTableSplit = function( drawingTableSplit ) { //can be called with a decimal (0.0 - 1.0), a mode (\"drawing\",\"mixed\",\"table\"), or nothing.\n\n        //TODO if going full-screen and not specifying a split here, then keep the table the same width and give all extra space to the drawing\n        \n        if ( drawingTableSplit === undefined )\n            drawingTableSplit = this.drawingTableSplit;\n        else if ( drawingTableSplit === \"drawing\" )\n            drawingTableSplit = 1.0;\n        else if ( drawingTableSplit === \"mixed\" )\n            drawingTableSplit = this.lastMixedSplit ? this.lastMixedSplit : 0.5;\n        else if ( drawingTableSplit === \"table\" )\n            drawingTableSplit = 0.0;\n\n        if ( drawingTableSplit < 0.05 ) \n        {\n            drawingTableSplit = 0.0;\n            this.drawingTableSplitMode = \"table\";\n        }\n        else if ( drawingTableSplit > 0.95 ) \n        {\n            drawingTableSplit = 1.0;\n            this.drawingTableSplitMode = \"drawing\";\n        }\n        else\n        {\n            this.drawingTableSplitMode = \"mixed\";\n            this.lastMixedSplit = drawingTableSplit;\n        }\n\n        let availableWidth = ( options.maxWidth ) ? options.maxWidth : Math.round( window.innerWidth - 30 -32 ); //30 for resize bar & 32 for scroll bars as not all systems hide scroll bars\n        let availableHeight = ( options.maxHeight ) ? options.maxHeight : Math.round( window.innerHeight - targetdiv.node().getBoundingClientRect().top -60/*controlpanel buttons height*/);\n        if ( this.fullWindow )\n        {\n            availableWidth -= 32; //left & right padding \n            availableHeight -= 30;\n        }\n\n        //console.log(\"setDrawingTableSplit availableWidth:\" + availableWidth + \" fullWindow:\" + this.fullWindow + \" drawingWidth:\" + this.layoutConfig.drawingWidth );\n        this.layoutConfig.drawingWidth = availableWidth * drawingTableSplit;\n        this.layoutConfig.tableWidth   = availableWidth * (1-drawingTableSplit);\n        this.layoutConfig.drawingHeight = availableHeight;\n        this.layoutConfig.tableHeight = availableHeight;\n        //console.log(\"setDrawingTableSplit split:\" + drawingTableSplit + \" availableWidth:\" + availableWidth + \" fullWindow:\" + this.fullWindow + \" drawingWidth:\" + this.layoutConfig.drawingWidth );\n        \n        if ( this.sizeButtons )\n        {\n            const drawingTableSplitMode = this.drawingTableSplitMode;\n            this.sizeButtons.selectAll(\"button\")\n                        .data( this.viewOption )\n                        //.enter()\n                        //.append(\"button\")\n                        .attr( \"class\",  function(d) { \n                            return d.mode === drawingTableSplitMode ? \"btn btn-primary\" : \"btn btn-default\" } );\n        }\n\n        if ( this.drawingTableSplit !== drawingTableSplit )\n        {\n            this.drawingTableSplit = drawingTableSplit; //so we can call this without a parameter when toggling full size. \n            if ( this.updateServer ) \n                this.updateServer(); \n        }\n    };    \n\n    options.updateServer = graphOptions.interactionPrefix && options.update ? function( k, x, y ) {\n        if ( k )\n        {\n            if (    (options.translateX === x)\n                 && (options.translateY === y)\n                 && (options.scale === k) )\n                 return;\n\n            options.translateX = x;\n            options.translateY = y;\n            options.scale = k;\n        }\n\n        if ( $(\"div.popover\").length )\n        {\n            console.log(\"Skipping server update as there is an overlay form. \" );\n            return;\n        }\n\n        console.log(\"Update server with pan: \" + x + \",\" + y + \" & zoom:\" + k + \" & options\");\n        const kvpSet = newkvpSet(true) ;\n        kvpSet.add('fullWindow', options.fullWindow ) ;\n        kvpSet.add('drawingTableSplit', options.drawingTableSplit ) ;\n        kvpSet.add('scale', options.scale ) ;\n        kvpSet.add('translateX', options.translateX ) ;\n        kvpSet.add('translateY', options.translateY ) ;        \n        goGraph( options.interactionPrefix + ':' + options.update, fakeEvent(), kvpSet) ;    \n    } : undefined;\n\n    if ( options.fullWindow )\n        targetdiv.node().classList.add(\"full-page\");\n\n    options.setDrawingTableSplit( options.drawingTableSplit ); //shouln't cause a server update\n\n    let focusDrawingObject = ! options.interactive ? undefined : function( d, scrollTable )\n    {        \n        if (    ( d3.event?.originalTarget?.className === \"ps-ref\" )\n             && ( selectedObject === d )\n             )\n        {\n            //Clicking on a reference to another drawing object, scroll to it. \n            selectedObject = d.drawing.getObject( d3.event.originalTarget.innerHTML );\n            scrollTable = true;\n        }\n        else if (    ( d3.event?.srcElement?.className === \"ps-ref\" )\n                  && ( selectedObject === d )\n             )\n        {\n            //Clicking on a reference to another drawing object, scroll to it. \n            selectedObject = d.drawing.getObject( d3.event.srcElement.innerHTML );\n            scrollTable = true;\n        }\n        else\n        {\n            //Not clicking on a reference, so we've selected what we clicked on\n            selectedObject = d;\n        }\n\n        //Adjust the stoke width of related items in the drawing\n        for( const drawing of pattern.drawings )\n            for( const a of drawing.drawingObjects )\n            {\n                const g = a.drawingSvg;\n                if ( g )\n                {\n                    const strokeWidth = a.getStrokeWidth( false, (selectedObject===a) );\n\n                    g.selectAll( \"line\" )\n                     .attr(\"stroke-width\", strokeWidth );\n\n                    g.selectAll( \"path\" )\n                     .attr(\"stroke-width\", strokeWidth );\n\n                    g.selectAll( \"ellipse\" )\n                     .attr(\"stroke-width\", strokeWidth );\n                }\n            }        \n\n        const graphdiv = targetdiv;\n\n        //Remove any existing highlighting in the table. \n        $(graphdiv.node()).find( \".j-active\" ).removeClass(\"j-active\").removeClass(\"j-active-2s\");\n        $(graphdiv.node()).find( \".source\" ).removeClass(\"source\");\n        $(graphdiv.node()).find( \".target\" ).removeClass(\"target\");\n\n        //d, the drawing object we clicked on, has a direct reference to its representation in the table\n        if ( selectedObject )\n        {\n            if ( selectedObject.tableSvg ) //should always be set unless there has been a problem\n                selectedObject.tableSvg.node().classList.add(\"j-active\");\n\n            if ( selectedObject.drawingSvg )\n                selectedObject.drawingSvg.node().classList.add(\"j-active\");\n\n            if ( selectedObject.outlineSvg )\n            {\n                selectedObject.outlineSvg.node().classList.add(\"j-active\");\n                const selectedObjectToAdjustAfter2Secs = selectedObject; //The user may have clicked on something else within 2 seconds\n                //the blush will only last 2 seconds anyway, but if we don't do this then a second click whilst it is the active one doesn't repeat the blush\n                setTimeout( function(){ selectedObjectToAdjustAfter2Secs.outlineSvg.node().classList.add(\"j-active-2s\");}, 2000 );\n            }\n        }\n\n        //Set the css class of all links to \"link\" \"source link\" or \"target link\" as appropriate.\n        if ( linksGroup )\n            linksGroup.selectAll(\"path.link\") //rename .link to .dependency\n                      .attr(\"class\", function( d ) {\n                        let classes = \"link\";\n                        if ( d.source === selectedObject ) \n                        {\n                            d.target.tableSvg.node().classList.add(\"source\");\n\n                            if ( d.target.outlineSvg ) //if it errored this will be undefined\n                                d.target.outlineSvg.node().classList.add(\"source\");\n\n                            classes += \" source\";\n                        }\n                        if ( d.target === selectedObject ) \n                        {\n                            d.source.tableSvg.node().classList.add(\"target\");\n\n                            if ( d.source.outlineSvg ) //if it errored this will be undefined\n                                d.source.outlineSvg.node().classList.add(\"target\");\n\n                            classes += \" target\";\n                        }\n                        if ( d.source instanceof Piece )\n                            classes += \" piece\";\n\n                        return classes; \n                      } )\n                      .each( function( d ) { \n                        if (( d.source === selectedObject ) || ( d.target === selectedObject ))\n                            d3.select(this).raise();\n                      } );\n\n        //Scroll the table to ensure that d.tableSvg is in view.    \n        if ( scrollTable && selectedObject )\n        {\n            if ( selectedObject.tableSvg )\n            {\n                const table = d3.select(\"div.pattern-table\");\n                table.transition()\n                     .duration(500)\n                     .tween(\"uniquetweenname\", scrollTopTween( selectedObject.tableSvg.node().__data__.tableSvgY - ( table.node().getBoundingClientRect().height /2) ));\n            }\n            else\n                console.log( \"Cannot scroll table, no tableSvg - \" + selectedObject.data.name );\n        }\n\n        if ( selectedObject instanceof Piece )\n        {\n            const piece = selectedObject;\n            if ( piece.shown )\n                piece.shown = false\n            else\n                piece.shown = true;\n\n            //Toggle visibility of piece in the table\n            if ( selectedObject.tableSvg ) //should always be set unless there has been a problem\n            {\n                const n = selectedObject.tableSvg.node();\n                if (( piece.shown ) && ( ! n.classList.contains(\"shown\")))\n                    n.classList.add(\"shown\");\n                else if (( ! piece.shown ) && ( n.classList.contains(\"shown\")))\n                    n.classList.remove(\"shown\");\n            }\n\n            //Toggle visibility of the piece in the drawing\n            if ( selectedObject.svg ) //should always be set unless there has been a problem\n            {\n                const n = selectedObject.svg.node();\n                if ( piece.shown )\n                {  \n                    piece.drawPiece( options );\n                }\n                else\n                {\n                    selectedObject.svg.selectAll( \"path\" ).remove();\n                    selectedObject.svg.selectAll( \"g\" ).remove();\n                }\n            }\n        }\n    }; //focusDrawingObject\n\n    let controls;\n    if (( ! options.hideControls ) && ( options.interactive ))\n        controls = doControls( targetdiv, options, pattern );\n\n    const drawingAndTableDiv = targetdiv.append(\"div\");\n    \n    if ( ! options.thumbnail ) \n        drawingAndTableDiv.attr(\"class\", \"pattern-main\")\n\n    doDrawingAndTable = function( retainFocus ) {\n                                    if ( options.layoutConfig.drawingWidth )\n                                        doDrawings( drawingAndTableDiv, pattern, options, contextMenu, controls, focusDrawingObject );\n                                    else\n                                        drawingAndTableDiv.select(\"svg.pattern-drawing\").remove();\n                                                                            \n                                    if (   ( options.layoutConfig.drawingWidth )\n                                        && ( options.layoutConfig.tableWidth ) )\n                                        doResizeBar( drawingAndTableDiv, options );    \n                                    else\n                                        drawingAndTableDiv.select(\"div.pattern-editor-resize\").remove();\n\n                                    if ( options.layoutConfig.tableWidth )\n                                        doTable( drawingAndTableDiv, pattern, options, contextMenu, focusDrawingObject );\n                                    else\n                                        drawingAndTableDiv.select(\"div.pattern-table\").remove();\n\n                                    if ( retainFocus )\n                                        //e.g. if doing show/hide functions button\n                                        focusDrawingObject( selectedObject, true );\n                                };\n\n    doDrawingAndTable();                   \n    \n    if (( options.returnSVG !== undefined ) && ( options.returnID ))\n    {\n        const serializer = new XMLSerializer();\n        const xmlString = serializer.serializeToString( targetdiv.select('svg.pattern-drawing').node());        \n        const thisHash = CryptoJS.MD5( xmlString ).toString();\n        if ( options.currentSVGhash !== thisHash )\n        {\n            if ( xmlString.length > 64000 )\n            {\n                console.log(\"Thumnbnail SVG will be rejected as it is too large.\" );\n            }\n            else\n            {\n                const kvpSet = newkvpSet(true);\n                kvpSet.add( 'svg', xmlString );\n                kvpSet.add( 'id', options.returnID ) ;\n                goGraph( options.interactionPrefix + ':' + options.returnSVG, fakeEvent(), kvpSet);\n            }\n        }\n        else\n        {\n            console.log(\"Current thumbnail is still valid.\");\n        }\n    }\n\n    if ( ! options.interactive )\n        return;\n\n    let errorFound = false;\n    let firstDrawingObject;\n    for( const drawing of pattern.drawings )\n    {\n        for( const a of drawing.drawingObjects )\n        {\n            if (( firstDrawingObject === undefined ) && ( a.isVisible( options ) ))\n                firstDrawingObject = a;\n\n            if ( a.error )\n            {\n                focusDrawingObject(a, true);\n                errorFound = true;\n                break;\n            }\n        }\n        if ( errorFound )\n            break;\n    }\n\n    //if not focussing on an error then see if there is a recently edited item to focus on. \n    if ( ! errorFound )\n    {\n        if ( options.focus ) \n        {\n            let a = pattern.getObject( options.focus );\n\n            if ( ! a )\n            try {\n                a = pattern.getMeasurement( options.focus );\n            } catch (e){\n            }\n\n            if ( ! a )\n                a = pattern.getVariable( options.focus );\n\n            if ( a )\n                focusDrawingObject(a, true);\n        }\n        else\n        {\n            focusDrawingObject(firstDrawingObject, true);\n        }\n    }\n}\n\n\nfunction doResizeBar( graphdiv, editorOptions )\n{\n    const layoutConfig = editorOptions.layoutConfig;\n    const drag = d3.drag()\n    .on(\"start\", function(r) {\n        console.log(\"dragStart\");\n        const rg = d3.select(this);        \n        r.initialX = d3.event.x;\n        r.resizeBarBaseStyle = rg.attr(\"style\");\n    })\n    .on(\"drag\", function(r) {\n        console.log(\"drag\");\n        const rg = d3.select(this);       \n        rg.attr(\"style\", r.resizeBarBaseStyle + \" left:\" + ( d3.event.x - r.initialX ) + \"px;\" ); \n    })\n    .on(\"end\", function(r){\n        console.log(\"dragEnd: \" + d3.event.x + \" (\" + ( d3.event.x - r.initialX ) + \")\" );\n        console.log( \"layoutConfig:\" + layoutConfig ); \n        const rg = d3.select(this);       \n        rg.attr(\"style\", r.resizeBarBaseStyle ); \n        const newDrawingWidth = layoutConfig.drawingWidth + ( d3.event.x - r.initialX );\n        const newTableWidth  = layoutConfig.tableWidth - ( d3.event.x - r.initialX );\n        editorOptions.setDrawingTableSplit( newDrawingWidth / ( newDrawingWidth + newTableWidth) );\n        doDrawingAndTable();\n    });\n\n    const height = layoutConfig.drawingHeight;\n\n    graphdiv.select( \"div.pattern-editor-resize\" ).remove();\n    graphdiv.selectAll( \"div.pattern-editor-resize\" )\n            .data( [ editorOptions ] )\n            .enter()\n            .append(\"div\")\n            .attr(\"class\", \"pattern-editor-resize\")\n            .attr(\"style\", \"height:\" + height + \"px;\" )\n            .call( drag );\n}\n\n\nfunction doControls( graphdiv, editorOptions, pattern )\n{\n    if ( ! editorOptions )\n        return;\n\n    const controls = graphdiv.append(\"div\").attr(\"class\", \"pattern-editor-controls\")\n\n    if (    ( editorOptions.viewOption )\n         && ( typeof editorOptions.viewOption === \"object\" ) //allow viewOption=\"drawing\" to prevent display if these buttons\n         && ( editorOptions.viewOption.length > 1 ) )\n    {\n        editorOptions.sizeButtons = controls.append(\"div\").attr(\"class\", \"btn-group view-options\");\n        editorOptions.sizeButtons.selectAll(\"button\")\n                    .data( editorOptions.viewOption )\n                    .enter()\n                    .append(\"button\")\n                    .attr( \"class\",  function(d) { return d.mode === editorOptions.drawingTableSplitMode ? \"btn btn-primary\" : \"btn btn-default\" } )\n                    .html(function(d) { return '<i class=\"' + d.icon + '\"></i>'; })\n                    .on(\"click\", function(d) {\n                        d3.event.preventDefault();\n                        editorOptions.setDrawingTableSplit( d.mode );\n                        doDrawingAndTable();\n                    } );\n    }\n\n    if ( editorOptions.includeFullPageOption )\n    {\n        const toggleFullScreen = function() {\n            d3.event.preventDefault();\n\n            if ( graphdiv.classed(\"full-page\") ) \n            {\n                graphdiv.node().classList.remove(\"full-page\");\n                editorOptions.fullWindow = false;\n            }\n            else\n            {\n                graphdiv.node().classList.add(\"full-page\");\n                editorOptions.fullWindow = true;\n            }\n\n            editorOptions.setDrawingTableSplit();\n\n            if ( editorOptions.updateServer ) \n                editorOptions.updateServer();\n\n            doDrawingAndTable();\n        };\n\n        controls.append(\"button\")\n                .attr(\"class\", \"btn btn-default toggle-full-page\")\n                .html( '<i class=\"fa-solid fa-maximize\" />' )\n                .attr(\"title\",\"Toggle full screen\")\n                .on(\"click\", toggleFullScreen );\n    }\n\n    //Zoom to fit. \n    if ( editorOptions.allowPanAndZoom )\n    {\n        //zoomToFitButton\n        controls.append(\"button\")\n            .attr(\"class\", \"btn btn-default zoom-to-fit\")\n            .html( '<i class=\"fa-solid fa-arrows-up-down-left-right\" />' )\n            .attr(\"title\",\"Zoom to fit\");\n    }    \n\n    if ( editorOptions.downloadOption )\n    {\n        const downloadFunction = function() {\n            const serializer = new XMLSerializer();\n            const xmlString = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\r\\n\" + serializer.serializeToString( graphdiv.select(\"svg.pattern-drawing\").node() );\n            const imgData = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(xmlString);\n            \n            d3.select(this)\n                .attr( \"href-lang\", \"image/svg+xml; charset=utf-8\" )\n                .attr( \"href\", imgData )\n                .attr( \"download\", pattern.patternNumberAndName +  ( editorOptions.targetPiece.name ? \" - \" + editorOptions.targetPiece.name : \"\" ) + \" \" + pattern.getDate() + \".svg\" );\n        };\n\n        //downloadLink\n        controls.append(\"a\")\n                .attr(\"class\", \"btn btn-default download\")\n                .html( '<i class=\"fa-solid fa-download\"></i> Download' )\n                .attr(\"title\",\"Download\")\n                .on(\"click\", downloadFunction );\n    }    \n\n    if ( editorOptions.interactive )\n    {\n        const toggleShowFormulas = function() {\n            d3.event.preventDefault();\n            editorOptions.showFormulas = ! editorOptions.showFormulas;\n            $(this).children(\"i\").attr(\"class\",editorOptions.showFormulas ? \"fa-regular fa-square-check\" : \"fa-regular fa-square\" );\n            doDrawingAndTable( true /*retain focus*/ );\n        };\n\n        const optionMenuToggle = function() {\n            d3.event.preventDefault();\n            const $optionMenu = $( \"#optionMenu\");\n            if ( $optionMenu.is(\":visible\")) $optionMenu.hide(); else $optionMenu.show();\n        }\n\n        const optionMenu = controls.append(\"div\").attr(\"class\",\"pattern-popup\")\n                                 .append(\"div\").attr(\"id\",\"optionMenu\" ); //.css(\"display\",\"visible\")\n        optionMenu.append(\"button\").html( '<i class=\"fa-solid fa-xmark\"></i>' ).on(\"click\", optionMenuToggle );\n\n        pattern.drawings.forEach( function(pp) {\n            if ( ! pp.groups.length )\n                return;\n            const groupOptionsForPiece = optionMenu.append(\"section\");\n            groupOptionsForPiece.append(\"h2\").text( pp.name );\n            pp.groups.forEach( function(g) {\n                const groupOption = groupOptionsForPiece.append(\"div\").attr(\"class\",\"group-option\");\n                const toggleGroup = function() {\n                    g.visible = ! g.visible;  \n\n                    if(( typeof goGraph === \"function\" ) && ( g.update ))\n                    {\n                        const kvpSet = newkvpSet(true) ;\n                        kvpSet.add('visible', g.visible ) ;\n                        goGraph(editorOptions.interactionPrefix + ':' + g.update, fakeEvent(), kvpSet) ;    \n                    }\n\n                    return g.visible;\n                };\n                groupOption.append( \"i\" ).attr(\"class\",  g.visible ? 'fa-regular fa-eye' :'fa-regular fa-eye-slash' )\n                           .on( \"click\", function() { \n                                            d3.event.preventDefault();\n                                            const visible = toggleGroup();\n                                            d3.select(this).attr(\"class\",visible ? \"fa-regular fa-eye\" : \"fa-regular fa-eye-slash\" );\n                                            doDrawingAndTable( true /*retain focus*/ );\n                                } );\n                groupOption.append( 'span' )\n                           .text( g.name );\n                if (( g.contextMenu ) && ( typeof goGraph === \"function\" ))\n                groupOption.append( \"i\" ).attr(\"class\",  \"fa-solid fa-ellipsis k-icon-button\" )           \n                           .on( \"click\", function() { \n                            d3.event.preventDefault();\n                            const v = newkvpSet(false) ;\n                            goGraph( editorOptions.interactionPrefix + ':' + g.contextMenu, d3.event, v );\n                            } );\n            });\n        });\n\n        optionMenu.append(\"div\").attr(\"class\",\"formula-option\").html( '<i class=\"fa-regular fa-square-check\"></i>show formulas' ).on(\"click\", toggleShowFormulas );\n\n        if ( ! ( editorOptions.targetPiece && editorOptions.lifeSize ) ) //&& ! downloadOption ? \n            controls.append(\"button\")\n                    .attr(\"class\",\"btn btn-default toggle-options\").html( '<i class=\"fa-solid fa-circle-half-stroke\"></i>' )\n                    .attr(\"title\",\"Group/formula visibility\").on(\"click\", optionMenuToggle );\n    } //options menu to show/hide groups and show/hide formula\n\n    if ( pattern.wallpapers )\n    {\n        initialiseWallpapers( pattern, editorOptions.interactionPrefix );\n\n        const wallpaperMenuToggle = function() {\n            d3.event.preventDefault();\n            const $wallpaperMenu = $( \"#wallpapersMenu\");\n            if ( $wallpaperMenu.is(\":visible\")) $wallpaperMenu.hide(); else $wallpaperMenu.show();\n        }\n\n        const wallpaperMenu = controls.append(\"div\").attr(\"class\",\"pattern-popup\")\n                                    .append(\"div\").attr(\"id\",\"wallpapersMenu\" ); \n        wallpaperMenu.append(\"button\").html( '<i class=\"fa-solid fa-xmark\"></i>' ).on(\"click\", wallpaperMenuToggle );\n            \n        let wallpaperListSection = wallpaperMenu.append(\"section\");\n        wallpaperListSection.append(\"h2\").text( \"Wallpapers\" );\n        wallpaperListSection = wallpaperListSection.append(\"ul\");\n        wallpaperListSection.selectAll(\"li\")\n            .data( pattern.wallpapers )\n            .enter()\n            .append(\"li\")\n            .attr( \"class\", function(w) { return w.hide ? 'wallpaper-hidden' : null; } )\n            .each( function(wallpaper,i){                \n                const wallpaperDiv = d3.select(this);\n\n                \n                wallpaperDiv.append( \"span\" ).html( function(w) { return w.hide ? '<i class=\"fa-regular fa-eye-slash\"/>' : '<i class=\"fa-regular fa-eye\"/>' } )\n                                           .on(\"click\", function(w) { d3.event.preventDefault(); d3.event.stopPropagation();\n                                                                      w.hide = ! w.hide; \n                                                                      d3.select(this).html( w.hide ? '<i class=\"fa-regular fa-eye-slash\"/>' : '<i class=\"fa-regular fa-eye\"/>' );\n                                                                      d3.select(this.parentNode).attr( \"class\", w.hide ? 'wallpaper-hidden' : null );\n                                                                      w.updateServer();\n                                                                      const wallpaperGroups = graphdiv.select( \"g.wallpapers\");\n                                                                      doWallpapers( wallpaperGroups, pattern );                                                              \n                                                                     } );\n                wallpaperDiv.append( \"span\" ).html( function(w) { return w.editable ? '<i class=\"fa-solid fa-lock-open\"/>' : w.allowEdit ? '<i class=\"fa-solid fa-lock\"/>' : '<i class=\"fa-solid fa-lock disabled\"/>' } )\n                                           .on(\"click\", function(w) { d3.event.preventDefault(); d3.event.stopPropagation();\n                                                                      if ( w.allowEdit )\n                                                                      {\n                                                                        w.editable = ! w.editable; \n                                                                        d3.select(this).html( w.editable ? '<i class=\"fa-solid fa-lock-open\"/>' : '<i class=\"fa-solid fa-lock\"/>' );\n                                                                        const wallpaperGroups = graphdiv.select( \"g.wallpapers\");\n                                                                        doWallpapers( wallpaperGroups, pattern );                                                              \n                                                                      }\n                                                                     } );\n                wallpaperDiv.append( \"span\" ).text( wallpaper.displayName );\n                                                                     //fa-lock fa-lock-open fa-arrows-up-down-left-right fa-regular fa-eye fa-regular fa-eye-slash\n            });            \n\n        controls.append(\"button\").attr(\"class\",\"btn btn-default toggle-options\").html( '<i class=\"fa-solid fa-camera-retro\"></i>' ).attr(\"title\",\"Wallpapers\").on(\"click\", wallpaperMenuToggle );\n    } //wallpapers button    \n\n    return controls;\n}\n\n\nfunction initialiseWallpapers( pattern, interactionPrefix )\n{    \n    let defaultScale = 72.0;\n\n    const updateServer = ( typeof goGraph === \"function\" ) ? function(e) {\n        const kvpSet = newkvpSet(true) ;\n        kvpSet.add('offsetX', this.offsetX ) ;\n        kvpSet.add('offsetY', this.offsetY ) ;\n        kvpSet.add('scaleX', this.scaleX * defaultScale ) ;\n        kvpSet.add('scaleY', this.scaleY * defaultScale ) ;\n        kvpSet.add('opacity', this.opacity ) ;\n        kvpSet.add('visible', ! this.hide ) ;\n        goGraph(interactionPrefix + ':' + this.update, fakeEvent(), kvpSet) ;    \n    } : function(e){};\n\n    const wallpapers = pattern.wallpapers; \n    for( const i in wallpapers )\n    {\n        const w = wallpapers[i];\n\n        if ( ! w.initialised )\n        {\n            //A 720px image is naturally 10in (at 72dpi)\n            //If our pattern as 10in across then our image should be 10 units.\n            //If our pattern was 10cm across then our image should be 25.4 units and we would expect to need to specify a scale of 1/2.54\n            defaultScale = 72.0;\n            if ( w.patternurl )\n            {\n                defaultScale = 1.0;\n            }\n            else\n            {\n                switch( pattern.units ) {\n                    case \"cm\":\n                        defaultScale = 72.0 / 2.54;\n                        break;\n                    case \"mm\":\n                        defaultScale = 72.0 / 25.4;\n                        break;\n                }\n            }\n            w.scaleX = w.scaleX / defaultScale /*dpi*/; //And adjust by pattern.units\n            w.scaleY = w.scaleY / defaultScale /*dpi*/;\n            w.hide = ( w.visible !== undefined ) && (! w.visible );\n            w.allowEdit = ( w.allowEdit === undefined ) || ( w.allowEdit );\n            \n            if ( w.imageurl )\n            {\n                w.displayName = w.filename ? w.filename : w.imageurl;\n\n                $(\"<img/>\") // Make in memory copy of image to avoid css issues\n                    .attr(\"src\", w.imageurl )\n                    .attr(\"data-wallpaper\", i)\n                    .on( \"load\", function() {\n                        //seems like we can't rely on closure to pass w in, it always   points to the final wallpaper\n                        const w = wallpapers[ this.dataset.wallpaper ];\n                        w.width = this.width;   // Note: $(this).width() will not\n                        w.height = this.height; // work for in memory images.\n                        //console.log( \"jquery Image loaded w.imageurl \" + w.imageurl + \" width:\" + w.width + \" height:\" + w.height);\n                        //console.log( \"Wallpaper dimensions known. Image loaded w.imageurl width:\" + w.width + \" height:\" + w.height );\n                        if ( w.image )\n                        {\n                            //console.log( \" setting d3Image dimentions.\" );\n                            d3.select( w.image ).attr(\"width\", w.width );        \n                            d3.select( w.image ).attr(\"height\", w.height );        \n                        }\n                    });\n            } \n            else if ( w.patternurl )\n            {\n                w.displayName = w.patternName;\n\n                w.drawPatternWallpaper = function drawPatternWallpaper()\n                {\n                    const w = this;\n                    const drawingOptions = { \"outline\": false, \n                                             \"label\": w.showLabels,\n                                             \"dot\": false };\n\n                    if ( w.overrideLineColour )\n                        drawingOptions.overrideLineColour = w.overrideLineColour;\n\n                    if ( w.overrideLineStyle )\n                        drawingOptions.overrideLineStyle = w.overrideLineStyle;\n\n//rework to create/update groups for drawings                        \n                    for( const drawing of w.pattern.drawings )\n                    {\n                        const drawingGroup = d3.select( w.g ).append(\"g\").attr(\"class\",\"j-drawing\");\n\n                        const drawing0 = drawing; //required for closure\n                        drawingGroup.selectAll(\"g\")\n                            .data( drawing0.drawingObjects )\n                            .enter()\n                            .each( function(d,i) {\n                                const gd3 = d3.select( this );                        \n                                if (   ( typeof d.draw === \"function\" ) \n                                    && ( ! d.error )\n                                    && ( d.isVisible() ) )// editorOptions ) ) )\n                                try {\n                                    d.draw( gd3, drawingOptions );\n                                } catch ( e ) {\n                                    d.error = \"Drawing failed. \" + e;\n                                }\n                            });\n                    }\n                }\n\n                const fetchPatternForWallpaper = async () => {\n                    const response = await fetch( w.patternurl, {\n                      method: 'GET',\n                      headers: {\n                        'Content-Type': 'application/json'\n                      }\n                    });\n                    const data = await response.json();\n                    data.wallpaper = undefined; //don't put wallpapers on wallpapers\n                    w.pattern = new Pattern( data );\n                    w.width  = w.pattern.visibleBounds.maxX - w.pattern.visibleBounds.minX;\n                    w.height = w.pattern.visibleBounds.maxY - w.pattern.visibleBounds.minY;\n\n                    //This however does lead to lines being scaled for thickness too. \n                    const unitScale = function( units ) {\n                        switch( units )\n                        {\n                            case \"inch\" : return 25.4;\n                            case \"cm\" : return 10;\n                            case \"mm\" :\n                            default: return 1;\n                        }\n                    };                \n    \n                    const scaleAdjust = unitScale( w.pattern.units ) / unitScale( pattern.units );\n                    w.scaleX += scaleAdjust;\n                    w.scaleY += scaleAdjust;\n\n                    if ( w.g )\n                        w.drawPatternWallpaper(); //otherwise we'll do it when we create w.g\n                  }\n\n                fetchPatternForWallpaper();                \n            }\n                \n            if ( updateServer )\n                w.updateServer = updateServer;\n\n            w.initialised = true;\n        }    \n    }\n}\n\n\n//http://bl.ocks.org/humbletim/5507619\nfunction scrollTopTween(scrollTop) \n{\n    return function() {\n        const i = d3.interpolateNumber(this.scrollTop, scrollTop);\n\n        return function(t) { \n            this.scrollTop = i(t); \n        };\n    }\n}\n  \n\n//Do the drawing... (we've added draw() to each drawing object.\nfunction doDrawings( graphdiv, pattern, editorOptions, contextMenu, controls, focusDrawingObject )\n{\n    const layoutConfig = editorOptions.layoutConfig;\n    const margin = editorOptions.lifeSize ? pattern.getPatternEquivalentOfMM(5) : 0;\n    if ( margin )\n    {\n        pattern.visibleBounds.minX = Math.round( ( pattern.visibleBounds.minX - margin ) * 1000 ) / 1000;\n        pattern.visibleBounds.minY = Math.round( ( pattern.visibleBounds.minY - margin ) * 1000 ) / 1000;\n        pattern.visibleBounds.maxX = Math.round( ( pattern.visibleBounds.maxX + margin ) * 1000 ) / 1000;\n        pattern.visibleBounds.maxY = Math.round( ( pattern.visibleBounds.maxY + margin ) * 1000 ) / 1000;\n    }\n    const width =  layoutConfig.drawingWidth;\n    const height = layoutConfig.drawingHeight;\n    let patternWidth = pattern.visibleBounds.maxX - pattern.visibleBounds.minX;\n    let patternHeight = pattern.visibleBounds.maxY - pattern.visibleBounds.minY;\n\n    graphdiv.select(\"svg.pattern-drawing\").remove();\n\n    let svg;\n    \n    if ( editorOptions.lifeSize )\n    {\n        //The margin needs to at least be 0.5 * strokewidth so tha that strokes arnt clipped. \n        const margin = pattern.getPatternEquivalentOfMM(10); //to allow for rulers\n        patternWidth = Math.round( ( patternWidth + margin ) * 1000 ) / 1000;\n        patternHeight = Math.round( ( patternHeight + margin ) * 1000 ) / 1000;\n        svg = graphdiv.append(\"svg\")\n                      .attr(\"class\", \"pattern-drawing \" + pattern.units )\n                      .attr(\"viewBox\", (pattern.visibleBounds.minX-margin) + \" \" + (pattern.visibleBounds.minY-margin) + \" \" + patternWidth + \" \" + patternHeight )\n                      .attr(\"width\", patternWidth + pattern.units )\n                      .attr(\"height\", patternHeight + pattern.units )\n                      .attr(\"xmlns:xlink\", \"http://www.w3.org/1999/xlink\" );\n    }\n    else\n    {\n        svg = graphdiv.append(\"svg\")\n                       .attr(\"class\", \"pattern-drawing \" + pattern.units )\n                       .attr(\"width\", width + ( 2 * margin ) )\n                       .attr(\"height\", height + ( 2 * margin ));\n\n        if ( editorOptions.thumbnail )\n            svg.attr(\"viewBox\", 0 + \" \" + 0 + \" \" + (width + ( 2 * margin )) + \" \" + (height + ( 2 * margin )) );\n    }\n\n    //Arrow head for grainline. \n    const forExport = editorOptions.downloadOption;\n    //The id we use for the markers must be unique within the page, but repeatable where we are comparing SVG by hash. \n    editorOptions.arrowId = \"arrow\" + forExport + editorOptions.fullWindow;\n    const markerpath = svg.append(\"svg:defs\")\n       .append(\"marker\")\n       .attr(\"class\",\"arrow\" ) //must be unique even amongst hidden views in the strand\n       .attr(\"id\", editorOptions.arrowId ) \n       .attr(\"viewBox\", \"0 -5 12 10\")     //0 -5 10 10  //0 0 10 10\n       .attr(\"refX\", 8)                  //15 //5\n       .attr(\"refY\", 0)                  //-1.5 //5\n       .attr(\"markerWidth\", 4)  //6  \n       .attr(\"markerHeight\", 4)  //6\n       .attr(\"orient\", \"auto-start-reverse\")\n       .append(\"svg:path\") \n       .attr(\"fill\", \"none\" )\n       .attr(\"stroke-width\",\"2\")\n       .attr(\"stroke\",\"black\")\n       .attr(\"stroke-linejoin\",\"round\")\n       .attr(\"d\", \"M0,-5L10,0L0,5\"); //M0,-5L10,0L0,5 M0,0L10,5L0,10z\n\n//    if ( forExport )\n  //      markerpath.attr(\"stroke\", \"black\").attr(\"fill\",\"none\");  //fill\n\n\n    const transformGroup1 = svg.append(\"g\"); //This gets used by d3.zoom\n\n    //console.log( \"Pattern bounds minX:\" + pattern.bounds.minX + \" maxX:\" + pattern.bounds.maxX );\n    //console.log( \"Pattern bounds minY:\" + pattern.bounds.minY + \" maxY:\" + pattern.bounds.maxY );\n\n    //transformGroup2 scales from calculated positions in pattern-space (e.g. 10 representing 10cm) to\n    //pixels available. So 10cm in a 500px drawing has a scale of 50. \n    let transformGroup2;\n\n    if ( editorOptions.lifeSize )// || ( editorOptions.thumbnail ))\n    {\n        scale = 1;\n        transformGroup2 = transformGroup1; //we don't need another group\n\n        drawRulers( pattern, patternWidth, patternHeight, transformGroup2 );\n    }\n    else\n    {\n        const scaleX = width / patternWidth;                   \n        const scaleY = height / patternHeight;           \n        \n        if ( ( isFinite( scaleX ) ) && ( isFinite( scaleY ) ) )\n            scale = scaleX > scaleY ? scaleY : scaleX;\n        else if ( isFinite( scaleX ) )\n            scale = scaleX;\n        else\n            scale = 1;\n\n        transformGroup2 = transformGroup1.append(\"g\").attr(\"transform\", \"scale(\" + scale + \",\" + scale + \")\");\n    }\n\n    //console.log( \"scale:\" + scale + \" patternWidth:\" + patternWidth + \" width:\" + width );\n\n    //centralise horizontally                            \n    const boundsWidth = pattern.visibleBounds.maxX - pattern.visibleBounds.minX;\n    const availableWidth = width / scale;\n    const offSetX = ( availableWidth - boundsWidth ) /2;\n\n    //transformGroup3 shifts the position of the pattern, so that it is centered in the available space. \n    const transformGroup3 = transformGroup2.append(\"g\")                               \n                                         .attr(\"class\", editorOptions.thumbnail ? \"pattern thumbnail\" : \"pattern\");                           \n\n    if ( editorOptions.downloadOption )  \n        transformGroup3.attr(\"id\", pattern.patternNumberAndName )\n        \n    if ( ! editorOptions.lifeSize )\n        transformGroup3.attr(\"transform\", \"translate(\" + ( ( -1.0 * ( pattern.visibleBounds.minX - offSetX ) ) ) + \",\" + ( ( -1.0 * pattern.visibleBounds.minY ) ) + \")\");    \n\n    if ( pattern.wallpapers )\n    {\n        const wallpaperGroups = transformGroup2.append(\"g\")\n                                             .attr(\"class\",\"wallpapers\")\n                                             .attr(\"transform\", \"translate(\" + ( ( -1.0 * ( pattern.visibleBounds.minX - offSetX ) ) ) + \",\" + ( ( -1.0 * pattern.visibleBounds.minY ) ) + \")\")   \n                                             .lower();\n        doWallpapers( wallpaperGroups, pattern );\n    }\n     \n    //Clicking on an object in the drawing should highlight it in the table.\n    const onclick = ! editorOptions.interactive ? undefined : function(d) {\n        d3.event.preventDefault();\n        focusDrawingObject(d,true);\n    };\n\n    for( const drawing of pattern.drawings )\n    {\n        //TODO depending upon use case, do the pieces or drawing first? \n\n        //Even if we're not going to drawing pieces lets create the svg placeholders for them so they are ready \n        //if they are clicked in the table. \n        //if ( ! editorOptions.skipPieces )\n        //{\n            doPieces( drawing, transformGroup3, editorOptions );\n        //}\n\n        if ( ! editorOptions.skipDrawing )\n        {\n            doDrawing( drawing, transformGroup3, editorOptions, onclick, contextMenu );\n        }\n    }\n\n    const updateServerAfterDelay = function()\n    {\n        //Lets only update the server if we've stopped panning and zooming for > 1s.\n        timeOfLastTweak = (new Date()).getTime();\n        if ( ! updateServerTimer )\n        {\n            const updateServerTimerExpired = function () {\n\n                updateServerTimer = null;          \n                //console.log(\"Zoom update server timer activated. TimeOfLastTweak:\" + timeOfLastTweak + \" Now:\" + (new Date()).getTime());\n\n                if ( (new Date()).getTime() >= ( timeOfLastTweak + 500 ) )\n                {\n                    const zt = d3.zoomTransform( transformGroup1.node() );\n                    if ( editorOptions.updateServer )\n                        editorOptions.updateServer( zt.k, zt.x, zt.y );\n                }\n                else\n                    updateServerTimer = setTimeout(updateServerTimerExpired, 500);\n            }\n\n            updateServerTimer = setTimeout(updateServerTimerExpired, 500);\n        }           \n    };\n\n    const zoomed = function() {\n        transformGroup1.attr(\"transform\", d3.event.transform);\n\n        const currentScale = d3.zoomTransform( transformGroup1.node() ).k; //do we want to scale 1-10 to 1-5 for fonts and linewidths and dots?\n        if (   ( currentScale > (1.1*fontsSizedForScale) )\n            || ( currentScale < (0.9*fontsSizedForScale) )\n            || ( currentScale === 1 ) || ( currentScale === 8 ) )\n        {\n            if ( ! fontResizeTimer )\n            {\n                fontResizeTimer = setTimeout(function () {      \n                    fontResizeTimer = null;          \n                    fontsSizedForScale = d3.zoomTransform( transformGroup1.node() ).k;\n                    //console.log( \"Zoomed - fontsSizedForScale \" + fontsSizedForScale );\n\n                    for( const drawing of pattern.drawings )\n                    {                \n                        for( const a of drawing.drawingObjects )\n                        {\n                            let g = a.drawingSvg;                            \n                            if ( g )\n                            {\n                                const labelPosition = a.labelPosition();\n\n                                if ( labelPosition )\n                                {\n                                    g.selectAll( \"text.labl\" )\n                                    .attr(\"font-size\", labelPosition.fontSize + \"px\")\n                                    .attr(\"x\", labelPosition.labelX )\n                                    .attr(\"y\", labelPosition.labelY );\n\n                                    g.selectAll( \"line.labelLine\" )\n                                    .attr(\"x2\", labelPosition.labelLineX )\n                                    .attr(\"y2\", labelPosition.labelLineY );\n                                }\n\n                                const fontSize = Math.round( 1300 / scale / fontsSizedForScale )/100; //13 at scale 1\n                                g.selectAll( \"text.length\" )\n                                 .attr(\"font-size\", fontSize + \"px\");\n\n                                 g.selectAll( \"text.alongPath\" )\n                                 .attr(\"font-size\", fontSize + \"px\");\n                       \n                                g.selectAll( \"circle\" )\n                                 .attr(\"r\", Math.round(400 / scale / fontsSizedForScale)/100 );\n\n                                const strokeWidth = a.getStrokeWidth( false, (selectedObject===a) );\n\n                                g.selectAll( \"line\" )\n                                    .attr( \"stroke-width\", strokeWidth );\n\n                                g.selectAll( \"path\" )\n                                    .attr( \"stroke-width\", strokeWidth );\n\n                                g.selectAll( \"ellipse\" )\n                                    .attr( \"stroke-width\", strokeWidth );\n                            }\n\n                            g = a.outlineSvg;\n                            if ( g )\n                            {\n                                const strokeWidth = a.getStrokeWidth( true );\n\n                                g.selectAll( \"line\" )\n                                 .attr( \"stroke-width\", strokeWidth );\n\n                                g.selectAll( \"path\" )\n                                 .attr( \"stroke-width\", strokeWidth );           \n\n                                g.selectAll( \"ellipse\" )\n                                 .attr( \"stroke-width\", strokeWidth );           \n\n                                g.selectAll( \"circle\" )\n                                    .attr(\"r\", Math.round( 1200 / scale / fontsSizedForScale )/100 );\n                            }\n                        }        \n\n                        //TODO for each piece also scale their stroke width\n\n                        \n                    }\n                }, 50);         \n            }\n        }\n        updateServerAfterDelay();         \n    };           \n\n    fontsSizedForScale = 1; //the starting scale of transformGroup1.\n\n    if ( editorOptions.allowPanAndZoom )\n    {\n        //TODO just the fontsize needs setting initially to take editorOptions.scale into account\n\n        const transform = d3.zoomIdentity.translate(editorOptions.translateX, editorOptions.translateY).scale(editorOptions.scale);\n        const zoom = d3.zoom()\n                    .extent([[0, 0], [width, height]])\n                    .scaleExtent([0.5, 32])\n                    .on(\"zoom\", zoomed);\n        svg.call( zoom)\n           .call(zoom.transform, transform);\n\n        fontsSizedForScale = editorOptions.scale;\n\n        if ( controls) \n            controls.select( \".zoom-to-fit\" ).on( \"click\", function() {\n                d3.event.preventDefault();\n\n                //Reset transformGroup1 to 0,0 and scale 1\n                svg.call(zoom)\n                .call(zoom.transform, d3.zoomIdentity);\n                \n                if ( editorOptions.updateServer )\n                {\n                    const zt = d3.zoomTransform( transformGroup1.node() );\n                    editorOptions.updateServer( zt.k, zt.x, zt.y );\n                }\n            } );\n    }\n}\n\n\nfunction drawRulers( pattern, patternWidth, patternHeight, transformGroup2 )\n{\n    const rulers = transformGroup2.append(\"g\");\n    rulers.attr(\"id\",\"rulers\");\n    const xAxis = rulers.append(\"g\");\n    xAxis.attr(\"class\",\"ruler\")\n    //add scale marks \n    //units:cm - 1 mark per cm, so patternWidth marks every 10th mark add a label \"10cm\"\n    const strokeWidth = pattern.getPatternEquivalentOfMM(0.5);\n    const colour = \"#808080\";\n    const fontSize = pattern.getPatternEquivalentOfMM(5);\n    const tickSize = pattern.getPatternEquivalentOfMM(10);\n    const step = pattern.units === \"mm\" ? 5 : 1;\n    xAxis.append(\"line\")\n        .attr(\"x1\", pattern.visibleBounds.minX )\n        .attr(\"y1\", pattern.visibleBounds.minY - tickSize )\n        .attr(\"x2\", pattern.visibleBounds.minX + patternWidth )\n        .attr(\"y2\", pattern.visibleBounds.minY - tickSize )\n        .attr(\"stroke\", colour)\n        .attr(\"stroke-width\", strokeWidth );\n    for( let i=0; i<patternWidth; i+=step )\n    {\n        const l = xAxis.append(\"line\")\n                .attr(\"x1\", i + pattern.visibleBounds.minX )\n                .attr(\"y1\", pattern.visibleBounds.minY - tickSize )\n                .attr(\"x2\", i + pattern.visibleBounds.minX )\n                .attr(\"y2\", pattern.visibleBounds.minY - tickSize + tickSize * ( i % (10*step) == 0 ? 1 : i % (5*step) == 0 ? 0.75 : 0.5 ))\n                .attr(\"stroke\", colour)\n                .attr(\"stroke-width\", strokeWidth );\n        if ( i % (10*step) === 0 )\n        {\n            const t = xAxis.append(\"text\")\n                        .attr(\"class\",\"labl\")\n                        .attr(\"x\", i + pattern.visibleBounds.minX + 0.25 * tickSize )\n                        .attr(\"y\", pattern.visibleBounds.minY )\n                        .attr(\"font-size\", fontSize )\n                        .attr(\"fill\", colour)\n                        .text( i + ( i == 10*step ? \" \" + pattern.units : \"\" ) );\n        }\n    }  \n    const yAxis = rulers.append(\"g\");\n    yAxis.attr(\"class\",\"ruler\")\n    //add scale marks \n    //units:cm - 1 mark per cm, so patternWidth marks every 10th mark add a label \"10cm\"\n    yAxis.append(\"line\")\n        .attr(\"x1\", pattern.visibleBounds.minX - tickSize )\n        .attr(\"y1\", pattern.visibleBounds.minY )\n        .attr(\"x2\", pattern.visibleBounds.minX - tickSize )\n        .attr(\"y2\", pattern.visibleBounds.minY + patternHeight )\n        .attr(\"stroke\",colour)\n        .attr(\"stroke-width\", strokeWidth );\n    for( let i=0; i<patternHeight; i+=step )\n    {\n        const l = yAxis.append(\"line\")\n                .attr(\"x1\", pattern.visibleBounds.minX - tickSize )\n                .attr(\"y1\", i + pattern.visibleBounds.minY )\n                .attr(\"x2\", pattern.visibleBounds.minX - tickSize + tickSize * ( i % (10*step) == 0 ? 1 : i % (5*step) == 0 ? 0.75 : 0.5 ) )\n                .attr(\"y2\", i + pattern.visibleBounds.minY )\n                .attr(\"stroke\",colour)\n                .attr(\"stroke-width\", strokeWidth );\n        if ( ( i % (10*step) === 0 ) && ( i !== 0 ) )\n            {\n                const t = xAxis.append(\"text\")\n                            .attr(\"class\",\"labl\")\n                            .attr(\"x\", pattern.visibleBounds.minX - 0.25 * tickSize )\n                            .attr(\"y\", i + pattern.visibleBounds.minY - 0.25 * tickSize )\n                            .attr(\"font-size\", fontSize )\n                            .attr(\"fill\", colour)\n                            .text( i + ( i == 10*step ? \" \" + pattern.units : \"\" ) );\n            }                \n    }      \n}\n\n\nfunction doDrawing( drawing, transformGroup3, editorOptions, onclick, contextMenu ) \n{\n    const outlineGroup = ! editorOptions.interactive ? undefined : transformGroup3.append(\"g\").attr(\"class\",\"j-outline\");\n    const drawingGroup = transformGroup3.append(\"g\").attr(\"class\",\"j-drawing\");\n\n    const drawObject = function( d, g, drawingOptions ) {\n        const gd3 = d3.select( g );                        \n        if (   ( typeof d.draw === \"function\" ) \n            && ( ! d.error )\n            && ( d.isVisible( editorOptions ) ) )\n        try {\n            d.draw( gd3, drawingOptions );\n            d.drawingSvg = gd3; //not necessary if this is thumbnail\n        } catch ( e ) {\n            d.error = \"Drawing failed. \" + e;\n        }\n    };\n\n    if ( editorOptions.interactive )\n    {\n        const drawingOptions = { \"outline\": false, \n                                    \"label\": (! editorOptions.hideLabels),\n                                    \"dot\":  (! editorOptions.hideLabels) };\n        drawingGroup.selectAll(\"g\")\n        .data( drawing.drawingObjects )\n        .enter()\n        .append(\"g\")\n        .on(\"contextmenu\", contextMenu)\n        .on(\"click\", onclick)\n        .on('touchstart', function() { \n            this.touchStartTime = new Date(); \n            if ( event ) event.preventDefault();\n        })\n        .on('touchend',function(d) {    \n            const endTime = new Date(); \n            const duration = endTime - this.touchStartTime;\n\n            if ( event ) \n                event.preventDefault();\n\n            if (( duration > 400) || ( selectedObject === d ))\n            { \n                //console.log(\"long touch, \" + (duration) + \" milliseconds long\");\n                contextMenu(d);\n            }\n            else {\n                //console.log(\"regular touch, \" + (duration) + \" milliseconds long\");\n                onclick(d);\n            }                    \n        })\n        .each( function(d,i) {\n            drawObject( d, this, drawingOptions );\n        });\n    }\n    else //thumbnail\n    {\n        //In order to have the minimum SVG then don't create a group for each drawing object. \n        const drawingOptions = { \"outline\": false, \n                                    \"label\": (! editorOptions.hideLabels),\n                                    \"dot\":  (! editorOptions.hideLabels) };\n        drawingGroup.selectAll(\"g\")\n            .data( drawing.drawingObjects )\n            .enter()\n            .each( function(d,i) {\n                drawObject( d, this, drawingOptions );\n            });\n    }\n\n    if ( outlineGroup )\n    {\n        outlineGroup.selectAll(\"g\") \n            .data( drawing.drawingObjects )\n            .enter()\n            .append(\"g\")\n            .on(\"contextmenu\", contextMenu)\n            .on(\"click\", onclick)\n            .on('touchstart', function() { \n                this.touchStartTime = new Date(); \n                if ( event ) event.preventDefault();\n            })\n            .on('touchend',function(d) {    \n                const endTime = new Date(); \n                const duration = endTime - this.touchStartTime;\n                if ( event ) event.preventDefault();\n                if (( duration > 400) || ( selectedObject === d ))\n                { \n                    //console.log(\"long touch, \" + (duration) + \" milliseconds long\");\n                    contextMenu(d);\n                }\n                else {\n                    //console.log(\"regular touch, \" + (duration) + \" milliseconds long\");\n                    onclick(d);\n                }                    \n            })                \n            .each( function(d,i) {\n                const g = d3.select( this );\n                if (   ( typeof d.draw === \"function\" ) \n                    && ( ! d.error )\n                    && ( d.isVisible( editorOptions ) ) )\n                {\n                    d.draw( g, { \"outline\": true, \"label\": false, \"dot\":true } );\n                    d.outlineSvg = g;\n                }\n            });\n    }\n}\n\n\nfunction doPieces( drawing, transformGroup3, editorOptions )\n{\n    let piecesToDraw = drawing.pieces;\n\n    //Skip non-default pieces when making thumbnail\n    if ( editorOptions.thumbnail )\n    {\n        piecesToDraw = [];\n        for( const p of drawing.pieces )\n        {\n            if ( p.data.inLayout )\n                piecesToDraw.push( p );\n        }\n        if ( piecesToDraw.length === 0)\n            piecesToDraw = drawing.pieces; //revert back to all pieces\n    }\n\n    const pieceGroup = transformGroup3.append(\"g\").attr(\"class\",\"j-pieces\");\n    pieceGroup.selectAll(\"g\")\n                .data( piecesToDraw )\n                .enter()\n                .append(\"g\")        \n    //.on(\"contextmenu\", contextMenu)\n    //.on(\"click\", onclick)\n                .each( function(p,i) {\n                    const g = d3.select( this );\n                    g.attr(\"id\", p.name );\n\n                    //if doing an export of multiple pieces then take the piece.mx/my into account\n                    if ( editorOptions.targetPiece === \"all\" ) //OR AN ARRAY WITH >1 length\n                    {\n                        g.attr(\"transform\", \"translate(\" + ( 1.0 * p.data.mx ) + \",\" +  (1.0 * p.data.my ) + \")\");    \n                    }\n\n                    p.svg = g;\n\n                    if ( ! editorOptions.skipPieces )\n                    {\n                        if ( typeof p.drawSeamLine === \"function\" )\n                        {                            \n                            p.drawPiece( editorOptions );\n                        }\n                    }\n            });\n}\n\n\nfunction doWallpapers( wallpaperGroups, pattern )\n{\n    const visibleWallpapers = [];\n    for( const w of pattern.wallpapers )\n    {\n        if ( ! w.hide )\n            visibleWallpapers.push( w );\n    }\n\n    const drag = d3.drag()\n        .on(\"start\", function(wallpaper) {\n            wallpaper.offsetXdragStart = wallpaper.offsetX - d3.event.x;\n            wallpaper.offsetYdragStart = wallpaper.offsetY - d3.event.y;\n        })\n        .on(\"drag\", function(wallpaper) {\n            const wallpaperG = d3.select(this);        \n            wallpaper.offsetX = wallpaper.offsetXdragStart + d3.event.x;\n            wallpaper.offsetY = wallpaper.offsetYdragStart + d3.event.y;\n            wallpaperG.attr(\"transform\", \"translate(\" + wallpaper.offsetX + \",\" + wallpaper.offsetY + \") \" + \" scale(\" + wallpaper.scaleX + \",\" + wallpaper.scaleY + \" )\" );\n        })\n        .on(\"end\", function(wallpaper){\n            wallpaper.updateServer( d3.event );\n        });\n\n    const data = wallpaperGroups.selectAll(\"g.wallpaper\")\n                    .data( visibleWallpapers, function(d){ return d.patternurl || d.imageurl } //required to correctly match wallpapers to objects\n                    );\n\n    data.enter()\n        .append(\"g\")\n        .attr( \"class\", function(w){ return w.editable ? \"wallpaper editable\" : \"wallpaper\" } )\n        .attr( \"transform\", function(wallpaper) { return  \"translate(\" + ( wallpaper.offsetX ) + \",\" + ( wallpaper.offsetY ) + \")\"\n                                                        + \" scale(\" + wallpaper.scaleX + \",\" + wallpaper.scaleY + \")\" } )\n        .each( function(w){\n            //Set this up so that we can later use dimensionsKnown()\n\n            if ( w.imageurl )\n            {\n                //if we know the dimensions already, set them! (Safari needs this on showing a hidden wallpaper)\n                const imaged3 = d3.select(this).append(\"image\")\n                                        .attr( \"href\", w.imageurl )\n                                        .attr( \"opacity\", w.opacity )\n                                        .attr( \"width\", w.width)\n                                        .attr( \"height\", w.height);\n                imaged3.each( function(i) {\n                    w.image = this;\n                });\n            }\n            else if ( w.patternurl ) \n            {\n                w.g = this;\n                d3.select(this).attr(\"opacity\", w.opacity );\n                if ( w.pattern ) //pattern loaded already, including when toggling full screen\n                    w.drawPatternWallpaper();\n            }\n        } );\n\n    data.exit()\n        .remove();\n\n    const resize = d3.drag()\n                    .on(\"start\", function(wallpaper) {\n                        wallpaper.offsetXdragStart = d3.event.x - wallpaper.width;\n                        wallpaper.offsetYdragStart = d3.event.y - wallpaper.height;\n                        //console.log(\"start offsetXdragStart:\" + wallpaper.offsetXdragStart );\n                    })\n                    .on(\"end\", function(wallpaper) {\n                        const wallpaperG = d3.select(this.parentNode);\n                        const circle = d3.select(this);\n                        const rect = wallpaperG.select(\"rect\");\n                        const ratio = circle.attr(\"cx\") / wallpaper.width;     \n                        //const scaleXbefore = wallpaper.scaleX;                   \n                        wallpaper.scaleX = wallpaper.scaleX * ratio; //fixed aspect?\n                        wallpaper.scaleY = wallpaper.scaleY * ratio;\n                        //console.log( \"cx:\" + circle.attr(\"cx\") + \" image:\" + wallpaper.width + \"  ratio:\" + ratio + \"  scaleXbefore:\" + scaleXbefore + \"  scaleXNow:\" + wallpaper.scaleX );\n                        wallpaperG.attr(\"transform\", \"translate(\" + wallpaper.offsetX + \",\" + wallpaper.offsetY + \") \" + \" scale(\" + wallpaper.scaleX + \",\" + wallpaper.scaleY + \" )\" );\n                        circle.attr(\"cx\", wallpaper.width )\n                              .attr(\"cy\", wallpaper.height );\n                        rect.attr(\"width\", wallpaper.width )\n                            .attr(\"height\", wallpaper.height );\n                        wallpaper.updateServer( d3.event );\n                    } )\n                    .on(\"drag\", function(wallpaper) {\n                        const wallpaperG = d3.select(this.parentNode);\n                        const circle = d3.select(this);\n                        const rect = wallpaperG.select(\"rect\");\n                        let newX = d3.event.x - wallpaper.offsetXdragStart;\n                        let newY = d3.event.y - wallpaper.offsetYdragStart;\n                        //console.log(\"drag d3.event.x:\" + d3.event.x + \"  newX:\" + newX );\n\n                        //fixed aspect\n                        const ratioX = newX / wallpaper.width;\n                        const ratioY = newY / wallpaper.height;\n                        const ratio = (ratioX+ratioY)/2.0;\n                        newX = ratio * wallpaper.width;\n                        newY = ratio * wallpaper.height;\n\n                        circle.attr(\"cx\", newX )\n                              .attr(\"cy\", newY );\n                        rect.attr(\"width\", newX )\n                            .attr(\"height\", newY );\n                    });\n\n    //Add a resizing boundary to each editable wallpaper.                 \n    wallpaperGroups.selectAll(\"g\")\n                    .data( visibleWallpapers ,function(d){return d.patternurl || d.imageurl} )\n                    .each( function(w,i) {\n                        const g = d3.select(this);\n                        //This worked on Firefox and Chrome, but not Safari.\n                        //var box = g.node().getBBox();\n                        //w.width = box.width;\n                        //w.height = box.height;\n\n                        if ( w.editable )\n                        {\n                            g.append(\"rect\")\n                            .attr(\"x\",0)\n                            .attr(\"y\",0)\n                            .attr(\"stroke\", \"red\")\n                            .attr(\"fill\", \"none\")\n                            .attr(\"width\", w.width)\n                            .attr(\"height\", w.height);\n    \n                            if ( ! w.patternurl ) //don't allow re-sizing of patterns, just images\n                                g.append( \"circle\") \n                                .attr(\"cx\", function(w) { return w.width } )\n                                .attr(\"cy\", function(w) { return w.height } )\n                                .attr(\"r\", 10 / scale / w.scaleX / fontsSizedForScale )\n                                .attr(\"fill\", \"red\")\n                                .call(resize);\n                                \n                            g.call(drag);\n                        }\n                        else\n                        {\n                            g.select(\"rect\").remove();\n                            g.select(\"circle\").remove();\n                            g.on(\".drag\", null );\n                        }\n                    } );\n}\n\n\nfunction doTable( graphdiv, pattern, editorOptions, contextMenu, focusDrawingObject )\n{\n    const layoutConfig = editorOptions.layoutConfig;\n    const margin = layoutConfig.tableMargin;//25; \n    const width =  layoutConfig.tableWidth;//400;\n    const height = layoutConfig.tableHeight;//600;\n    const minItemHeight = 30; //should not be required\n    const itemMargin = 8;\n    const itemWidth = width *3/4;\n    let ypos = 0;\n    const asFormula = editorOptions.showFormulas; \n\n    const onclick = function(d) {\n        d3.event.preventDefault();\n        focusDrawingObject(d,false);\n    }\n\n    graphdiv.select(\"div.pattern-table\").remove();\n\n    let combinedObjects = [];\n\n    //TODO quick jump to start of pattern, variatble, pieces\n    if ( pattern.measurement )\n    {\n        for( const m in pattern.measurement )\n            combinedObjects.push( pattern.measurement[m] );\n    }\n\n    if ( pattern.variable )\n    {\n        for( const i in pattern.variable )\n            combinedObjects.push( pattern.variable[i] );\n    }\n\n    for( const drawing of pattern.drawings )\n    {\n        combinedObjects = combinedObjects.concat( drawing.drawingObjects );\n        combinedObjects = combinedObjects.concat( drawing.pieces );\n    }\n\n    const sanitiseForHTML = function ( s ) {\n\n            if ( typeof s !== \"string\" )\n                s = \"\" + s;\n                    \n            return s.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;').replaceAll('\"', '&quot;');\n        };\n\n    const svg = graphdiv.append(\"div\")\n                        .attr(\"class\", \"pattern-table\")\n                        .style( \"height\", height +\"px\" )    \n                        .append(\"svg\")\n                        .attr(\"width\", width + ( 2 * margin ) )\n                        .attr(\"height\", minItemHeight * combinedObjects.length );    \n\n    svg.selectAll(\"g\")\n       .data( combinedObjects )\n       .enter()        \n       .append(\"g\")\n       .each( function(d,i) {\n\n        const divHeight = function(that) {\n\n            //this - the dom svg element\n            //that - the data object\n\n            const h = $(this).find( \"div.outer\" ).height();\n            \n            if ( h < minItemHeight )\n                return minItemHeight;\n\n            return h;\n        };\n\n        const g = d3.select( this );\n\n        let classes = \"j-item\";\n\n        if ( d.isMeasurement )\n            classes += \" j-measurement\";\n        else if ( d.isVariable )\n            classes += \" j-variable\";\n        else if ( d instanceof DrawingObject )\n        {   \n            if ( ! d.isVisible( editorOptions ) ) //is a drawing object\n                classes += \" group-hidden\"; //hidden because of groups\n        }\n        else if ( d instanceof Piece )\n            classes += \" j-piece\";\n\n        d.tableSvg = g;\n        d.tableSvgX = itemWidth;\n        d.tableSvgY = ypos + ( 0.5 * minItemHeight );\n\n        const fo = g.append( \"foreignObject\" )\n                    .attr( \"x\", 0 )\n                    .attr( \"y\", function (d) { \n                                return ypos;\n                              } )\n                    .attr( \"width\", itemWidth  );\n\n        let html;\n        try {\n            html = d.html( asFormula );\n            if ( d.data?.comments )\n                html = '<div class=\"comments\">' + sanitiseForHTML( d.data.comments ) + '</div>' + html;\n            if (d.error)\n                html += '<div class=\"error\">' + sanitiseForHTML( d.error ) + '</div>' ;\n        } catch ( e ) {\n\n            if ( ! d.error )\n                d.error = \"Failed to generate description.\";\n\n            html = '<div class=\"error\">' + sanitiseForHTML( d.error ) + '</div>';\n        }\n\n        if ( d.error )\n            classes += \" error\";\n\n        g.attr( \"class\", classes ) ;    \n\n        fo.append( \"xhtml:div\" )\n           .attr(\"class\",\"outer\")\n           .append( \"xhtml:div\" )\n           .attr(\"class\",\"desc\")\n           .html( html );\n\n        fo.attr( \"height\", 1 ); //required by firefox otherwise bounding rects returns nonsense\n        fo.attr( \"height\", divHeight );\n\n        g.attr( \"height\", divHeight )\n         .attr( \"y\", function (d) { //Get the height of the foreignObject.\n                                    const h = this.childNodes[0].getBoundingClientRect().height;\n                                    ypos += h + itemMargin; \n                                    //console.log(\"y: \" + ypos );\n                                    return ypos } )\n\n        g.on(\"contextmenu\", contextMenu)\n         .on(\"click\", onclick )\n         .on('touchstart', function() { \n            this.touchStartTime = new Date(); \n            if ( event ) event.preventDefault();\n         })\n         .on('touchend',function(d) {    \n            const endTime = new Date(); \n            const duration = endTime - this.touchStartTime;\n            if ( event ) event.preventDefault();\n            if (( duration > 400) || ( selectedObject === d ))\n            { \n                //console.log(\"long touch, \" + (duration) + \" milliseconds long\");\n                contextMenu(d);\n            }\n            else {\n                //console.log(\"regular touch, \" + (duration) + \" milliseconds long\");\n                onclick(d);\n            }                    \n         });\n    }); //.each\n        \n    svg.attr(\"height\", ypos );    \n\n    linksGroup = svg.append(\"g\")\n                    .attr(\"class\", \"links\");\n\n    //Links area is width/4 by ypos.            \n    const linkScale = (width/4) / Math.log( Math.abs( ypos /30 ) );   \n\n    drawLinks( pattern, linkScale );\n}\n\n\nfunction drawLinks( pattern, linkScale ) {\n    const linkData = pattern.dependencies.dependencies;\n    \n    linksGroup.selectAll(\"path.link\") //rename .link to .dependency\n                    .data(linkData)\n                    .enter().append(\"path\")\n                    .attr(\"class\", \"link\" )\n                    .attr(\"d\", function( link ) {\n                        const x0 = link.source.tableSvgX, y0 = link.source.tableSvgY,\n                              x1 = link.target.tableSvgX, y1 = link.target.tableSvgY;\n                    \n                        const dy = y0 - y1,\n                              l = Math.log( Math.abs(dy /30 ) ) * linkScale;\n                    \n                        const path = d3.path();\n                        path.moveTo( x0, y0 );\n                        path.bezierCurveTo( x0+l , y0, x1+l, y1, x1, y1 );\n                        return path;                      \n                    } );\n}\n\n\n/*\n * Curve that connects items in the table.\n */\nfunction curve(link) {\n    const x0 = link.source.tableSvgX, y0 = link.source.tableSvgY,\n          x1 = link.target.tableSvgX, y1 = link.target.tableSvgY;\n\n    const dy = y0 - y1,\n          l = Math.log( Math.abs(dy /30 ) ) * 50;\n\n    const path = d3.path();\n    path.moveTo( x0, y0 );\n    path.bezierCurveTo( x0+l , y0, x1+l, y1, x1, y1 );\n    return path;                      \n}\n\n\n//TODO move to kinodbglue\nfunction newkvpSet(noRefresh)\n{\n    const kvp = { } ;\n    kvp.kvps = new Array() ;\n\n    kvp.add = function (k, v)\n    {\n        this.kvps.push ( {k: k, v: v} ) ;\n    } ;\n\n    kvp.toString = function (p)\n    {\n        let r = '' ;\n\n        for ( const kvp of this.kvps )\n            r += '&' + p + kvp.k + '=' + encodeURIComponent( kvp.v );\n\n        return r ;\n    } ;\n\n    if (noRefresh)\n        kvp.add(\"_noRefresh\", -1) ;\n\n    return kvp ;\n}\n\n//TODO move to kinodbglue\nfunction fakeEvent(location, x, y)\n{\n    let pXY = {x: 0, y: 0} ;\n    \n    if (location !== undefined)\n    {\n        pXY = getElementXY(location) ;\n        pXY.x = Math.round(pXY.x + x) ;\n        pXY.y = Math.round(pXY.y + y) ;\n    }\n    else\n    {\n        pXY.x = Math.round(x) ;\n        pXY.y = Math.round(y) ;\n    }\n    \n    // event to satisfy goGraph's requirements\n    return { target: location, pageX: 0, pageY: 0, processedXY: pXY } ;\n}\n\n\nexport{ PatternDrawing, doDrawings, doTable, drawPattern  };","//(c) Copyright 2019 Jason Dore\n//\n//Inspired by the excellent Seamly2D/Valentina pattern drawing software.\n//This library is a ground up implementation in Javascript intended to be compatible with, but\n//not based on, the Seamly2D/Valentina pattern making systen in order to support the community\n//pattern sharing website https://my-pattern.cloud/ . \n//\n//Source maintained at: https://github.com/MrDoo71/PatternEditor\n\nclass Expression {\n\n    constructor(data, pattern, drawing) {\n        this.dataDebug = data;\n        this.pattern = pattern;\n        this.drawing = drawing;\n\n        //divide, multiply etc. and functions too\n        if (typeof data.parameter !== \"undefined\") \n        {\n            this.params = data.parameter;\n            for ( const a in this.params ) {\n                this.params[a] = new Expression( this.params[a], pattern, drawing);\n            }            \n        }\n\n        if (typeof data.integerValue !== \"undefined\") \n        {\n            this.constant = data.integerValue;\n            this.value = this.constantValue; //the method constantValue()\n        }\n        else if (typeof data.decimalValue !== \"undefined\") \n        {\n            this.constant = data.decimalValue;\n            this.value = this.constantValue; //the method constantValue()\n        }\n        //else \n        //if (this.operation === \"Variable\") \n        //{\n            else if (  typeof data.keyword !== \"undefined\" )\n            {\n                this.variable = data.keyword;\n                this.value = this.keywordValue;\n            }\n            else if ( typeof data.variable !== \"undefined\")\n            {\n                this.variable = pattern.getVariable( data.variable );\n                this.value = this.variableValue;\n            }\n            else if ( data.measurement )\n            {\n                this.variable = pattern.getMeasurement( data.measurement );\n                this.value = this.measurementValue;\n            }\n            else if (    ( data.variableType === \"angleOfLine\" )\n                      || ( data.variableType === \"lengthOfLine\" ) )\n            {\n                this.drawingObject1 = drawing.getObject( data.drawingObject1 );\n                this.drawingObject2 = drawing.getObject( data.drawingObject2 );\n                this.function = data.variableType;\n                this.value = this.functionValue;\n            }\n            else if (    ( data.variableType === \"lengthOfSplinePath\" )\n                      || ( data.variableType === \"lengthOfSpline\" )\n                      || ( data.variableType === \"angle1OfSpline\" )\n                      || ( data.variableType === \"angle2OfSpline\" ) \n                      || ( data.variableType === \"lengthOfSplineControl1\" ) \n                      || ( data.variableType === \"lengthOfSplineControl2\" ) \n                      )\n            {\n                if ( data.drawingObject1 && data.drawingObject2 )\n                {\n                    //This shouldn't find an object, otherwise we'd have passed it as a single drawingObject.\n                    this.drawingObject = drawing.getObject( \"Spl_\" + data.drawingObject1 + \"_\" + data.drawingObject2 );\n\n                    //at least one of these will be an intersect on a curve, or position along a curve, otherwise they are end points of the curve. \n                    if ( ! this.drawingObject )\n                    {\n                        this.drawingObject1 = drawing.getObject( data.drawingObject1 );\n                        this.drawingObject2 = drawing.getObject( data.drawingObject2 );\n                        //one of these will be a Spline, the other will be an intersection point on it, or distance along it. \n\n                        //We're not the whole spline, just a segment of it. We need to find a curve that both drawing objects are on.\n\n                        const curveBeingCut = function( d ) {\n                            if ( d.arc )                             \n                                return d.arc;\n                            else if ( d.curve )                             \n                                return d.curve;\n                            else\n                                throw new Error( \"Path not found.\" ); \n                        };\n\n                        //Return true if 'other' is the start or end of this curve. \n                        const checkRelevant = function( curve, other ) {\n                            return    ( curve?.startPoint === other ) \n                                   || ( curve?.endPoint === other )\n                                   || ( curve?.data?.pathNode?.[0].point === other )\n                                   || ( curve?.data?.pathNode?.[curve?.data?.pathNode?.length-1]?.point === other )\n                                   || ( curve?.curve?.nodeData?.[0].point.equals( other.p ) ) //curve is itself an operation result\n                                   || ( curve?.curve?.nodeData?.[ curve?.curve?.nodeData?.length -1 ].point.equals( other.p ) )\n                        };\n\n                        let drawingObjectCuttingSpline;\n\n                        if (    (    ( this.drawingObject1.data.objectType === \"pointIntersectArcAndAxis\" )               \n                                  || ( this.drawingObject1.data.objectType === \"pointCutSplinePath\" ) \n                                  || ( this.drawingObject1.data.objectType === \"cutSpline\" ) )\n                             && checkRelevant( curveBeingCut( this.drawingObject1 ), this.drawingObject2 ) )\n                            drawingObjectCuttingSpline = this.drawingObject1;\n\n                        else if (    (    ( this.drawingObject2.data.objectType === \"pointIntersectArcAndAxis\" )               \n                                       || ( this.drawingObject2.data.objectType === \"pointCutSplinePath\" ) \n                                       || ( this.drawingObject2.data.objectType === \"cutSpline\" ) )\n                                 && checkRelevant( curveBeingCut( this.drawingObject2 ), this.drawingObject1 ) )\n                                 drawingObjectCuttingSpline = this.drawingObject2;\n\n                        if ( ! drawingObjectCuttingSpline )\n                            throw new Error( \"No object cutting spline. \" );\n\n                        this.splineDrawingObject = curveBeingCut( drawingObjectCuttingSpline );\n\n                        //The other drawing object will either be the start or end of this curve, OR another intersect on the same curve. \n                    }\n                }\n                else\n                    //this is the spline drawing object itself, the curve comes directly from it. \n                    this.drawingObject = drawing.getObject( data.drawingObject1 );\n\n                if (( data.segment ) && ( parseInt(data.segment) !== 0 ))\n                    this.segment = parseInt(data.segment);\n\n                this.function = data.variableType;\n                this.value = this.functionValue;\n            }            \n            else if ( data.variableType === \"lengthOfArc\" )\n            {\n                this.drawingObject = drawing.getObject( data.drawingObject1 );\n                this.arcSelection = data.arcSelection;\n                this.function = data.variableType;\n                this.value = this.functionValue;\n            }            \n            else if ( data.variableType === \"radiusOfArc\" )\n            {\n                this.drawingObject = drawing.getObject( data.drawingObject1 );\n\n                if ( data.radiusSelection === \"ellipticalArcRadius1\" )\n                    this.radiusSelection = 1;\n                else if ( data.radiusSelection === \"ellipticalArcRadius2\" )\n                    this.radiusSelection = 2;\n                else\n                    this.radiusSelection = null;\n\n                this.function = data.variableType;\n                this.value = this.functionValue;\n            }            \n            else if ( typeof data.variableType !== \"undefined\" )\n                throw new Error( \"Unsupported variableType:\" + data.variableType );\n        //}\n        else if ( typeof data.functionName !== \"undefined\" )\n        {\n            this.function = data.functionName;\n            this.value = this.functionValue;\n            //having done the parameters earlier. \n        }\n        else if ( typeof data.operation !== \"undefined\" )\n        {\n            //add, multiply etc.\n            this.operation = data.operation;\n            this.value = this.operationValue;\n        }\n        //Don't throw, we still need to continue with setting up the expression so we can describe what is wrong. \n        //else throw \"Unsupported expression.\" ;\n    }\n\n    \n    variableValue() {\n        return this.variable.value();\n    }    \n\n\n    measurementValue() {\n        //console.log(\"Measurement units \" + this.variable.units );\n        //console.log(\"Pattern units \" + this.pattern.units );\n        const measurementUnits = this.variable.units;\n        const patternUnits = this.pattern.units;\n        if ( measurementUnits === patternUnits )\n            return this.variable.value();\n\n        let mm = 1;\n        if ( measurementUnits === \"cm\" )\n            mm = 10;\n        else if ( measurementUnits === \"inch\" )\n            mm = 25.4;\n\n        let pp = mm;\n\n        if ( patternUnits === \"cm\" )\n            pp = mm / 10;\n        else if ( patternUnits === \"inch\" )\n            pp = mm / 25.4;\n\n        return pp * this.variable.value();\n    }    \n\n\n    functionValue(currentLength) {\n\n        let r; \n\n        switch( this.function )\n        {\n            case \"angleOfLine\":\n            {\n                const point1 = new GeoPoint( this.drawingObject1.p.x, this.drawingObject1.p.y );\n                const point2 = new GeoPoint( this.drawingObject2.p.x, this.drawingObject2.p.y );\n                const line = new GeoLine( point1, point2 );\n                let deg = line.angleDeg();\n                if ( deg < 0 )\n                    deg += 360; \n                r = deg;\n                break;\n            }\n            case \"lengthOfLine\":\n            {\n                const point1 = new GeoPoint( this.drawingObject1.p.x, this.drawingObject1.p.y );\n                const point2 = new GeoPoint( this.drawingObject2.p.x, this.drawingObject2.p.y );\n                const line = new GeoLine( point1, point2 );\n                r = line.getLength();\n                break;\n            }\n            case \"lengthOfSplinePath\":\n            case \"lengthOfSpline\":\n            {\n                if ( ! this.drawingObject ) \n                {\n                    //how far along the spline is each drawingObject (one is likely at the start or end)\n                    //create a copy of the spline with the intersection point added (where along the line if it has multiple nodes? the place where the line length doesn't grow).\n                    //https://pomax.github.io/bezierinfo/#splitting\n                    return    this.splineDrawingObject.curve.pathLengthAtPoint( this.drawingObject2.p )\n                            - this.splineDrawingObject.curve.pathLengthAtPoint( this.drawingObject1.p );\n                    //TODO. or we could use, though they amound to a similar thing. \n                //     return this.splineDrawingObject.curve.splineBetweenPoints( this.drawingObject1.p, this.drawingObject2.p ).pathLength();\n                }\n\n                if (    ( this.function === \"lengthOfSplinePath\" )\n                    && ( this.segment ) )\n                    r = this.drawingObject.curve.pathLength( this.segment );\n                else \n                    r = this.drawingObject.curve.pathLength();\n\n                break;\n            }\n            case \"angle1OfSpline\":\n            case \"angle2OfSpline\":\n            case \"lengthOfSplineControl1\":\n            case \"lengthOfSplineControl2\":    \n            {\n                let spline;\n                if ( this.drawingObject ) //the simple case, we are looking at the start/end of a path (not a point along the line, but could be a segment)\n                {\n                    spline = this.drawingObject.curve;\n                    if ( this.segment )\n                        spline = spline.pathSegment( this.segment );\n                }\n                else\n                {\n                    //this.splineDrawingObject is our spl or splpath, and drawingObject1 and drawingObject2 are either its ends, or intersection/pointalong\n                    //and we may also have a segment?\n                    spline = this.splineDrawingObject.curve;\n                    spline = spline.splineBetweenPoints( this.drawingObject1.p, this.drawingObject2.p );\n                }\n\n                switch( this.function )\n                {\n                    case \"angle1OfSpline\":\n                        r = spline.nodeData[0].outAngle;\n                        break;\n                    case \"angle2OfSpline\":\n                        r = spline.nodeData[ spline.nodeData.length-1 ].inAngle;\n                        break;\n                    case \"lengthOfSplineControl1\":\n                        r = spline.nodeData[0].outLength;\n                        break;\n                    case \"lengthOfSplineControl2\":\n                        r = spline.nodeData[ spline.nodeData.length-1 ].inLength;\n                        break;\n                }\n\n                break;\n            }\n            case \"lengthOfArc\":\n            {\n                if ( this.arcSelection === \"wholeArc\")\n                    r = this.drawingObject.arc.pathLength();\n                else\n                {\n                    //this.drawingObject is a cut object\n                    const arcDrawingObject = this.drawingObject.curve ? this.drawingObject.curve : this.drawingObject.arc;\n\n                    //where in the arc is this.drawingObject.curve?\n                    const radiusToIntersectLine = new GeoLine( arcDrawingObject.center.p, this.drawingObject.p );\n                    const angleToIntersectRad = radiusToIntersectLine.angle;\n                    if ( this.arcSelection === \"beforeArcCut\")\n                    {\n                        if ( arcDrawingObject.arc instanceof GeoEllipticalArc )\n                        {\n                            //else elliptical arc: from the arc's start angle to this cut angle. \n                            const cutArc = arcDrawingObject.arc.clone();\n                            cutArc.angle2 = radiusToIntersectLine.angleDeg() - cutArc.rotationAngle;\n                            if ( cutArc.angle2 < 0 )\n                                cutArc.angle2 += 360;\n                            r = cutArc.pathLength();\n                        }\n                        else //if arc\n                        {\n                            const arcStartAngleRad = arcDrawingObject.angle1.value() / 360 * 2 * Math.PI;\n                            const segmentRad = angleToIntersectRad-arcStartAngleRad;                    \n                            const length = radiusToIntersectLine.length * segmentRad; //because circumference of a arc is radius * angle (if angle is expressed in radians, where a full circle would be Math.PI*2 )\n                            r = length;\n                        }                    \n                    }\n                    else //afterArcCut\n                    {\n                        if ( arcDrawingObject.arc instanceof GeoEllipticalArc )\n                        {\n                            const cutArc = arcDrawingObject.arc.clone();\n                            cutArc.angle1 = radiusToIntersectLine.angleDeg()  - cutArc.rotationAngle;\n                            if ( cutArc.angle1 < 0 )\n                                cutArc.angle1 += 360;\n                            r = cutArc.pathLength();\n                        }\n                        else //if arc\n                        {\n                            const arcEndAngleRad = arcDrawingObject.angle2.value() / 360 * 2 * Math.PI;\n                            const segmentRad = arcEndAngleRad - angleToIntersectRad;\n                            const length = radiusToIntersectLine.length * segmentRad;\n                            r = length;\n                        }\n                    }\n                }\n                break;\n            }    \n            case \"radiusOfArc\":\n            {\n                if ( this.radiusSelection === 1 )\n                    r = this.drawingObject.radius1.value();\n                else if ( this.radiusSelection === 2 )\n                    r = this.drawingObject.radius2.value();\n                else\n                    r = this.drawingObject.radius.value();\n\n                break;\n            }\n            case \"sqrt\":\n            {\n                const p1 = this.params[0].value(currentLength);\n                r = Math.sqrt( p1 ); \n                break;\n            }\n            case \"-\":\n            {\n                const p1 = this.params[0].value(currentLength);\n                r = -p1; \n                break;\n            }\n            case \"min\":\n            {\n                const p1 = this.params[0].value(currentLength);\n                const p2 = this.params[1].value(currentLength);\n                r = Math.min( p1, p2 );\n                break;\n            }\n            case \"max\":\n            {\n                const p1 = this.params[0].value(currentLength);\n                const p2 = this.params[1].value(currentLength);\n                r = Math.max( p1, p2 );\n                break;\n            }\n            case \"sin\":\n            {\n                const p1 = this.params[0].value(currentLength);\n                r = Math.sin( p1 * Math.PI / 180 );\n                break;\n            }\n            case \"cos\":\n            {\n                const p1 = this.params[0].value(currentLength);\n                r = Math.cos( p1 * Math.PI / 180 );\n                break;\n            }\n            case \"tan\":\n            {\n                const p1 = this.params[0].value(currentLength);\n                r = Math.tan( p1 * Math.PI / 180 );\n                break;\n            }\n            case \"sinD\":\n            {\n                const p1 = this.params[0].value(currentLength);\n                r = Math.sin( p1 );\n                break;\n            }\n            case \"cosD\":\n            {\n                const p1 = this.params[0].value(currentLength);\n                r = Math.cos( p1 );\n                break;\n            }\n            case \"tanD\":\n            {\n                const p1 = this.params[0].value(currentLength);\n                r = Math.tan( p1 );\n                break;\n            }\n            case \"asin\":\n            {\n                const p1 = this.params[0].value(currentLength);\n                r = Math.asin( p1 ) * 180 / Math.PI;\n                break;\n            }\n            case \"acos\":\n            {\n                const p1 = this.params[0].value(currentLength);\n                r = Math.acos( p1 ) * 180 / Math.PI;\n                break;\n            }\n            case \"atan\":\n            {\n                const p1 = this.params[0].value(currentLength);\n                r = Math.atan( p1 ) * 180 / Math.PI;\n                break;\n            }        \n            case \"abs\":\n            {\n                const p1 = this.params[0].value(currentLength);\n                r = Math.abs( p1 );\n                break;\n            }        \n            default:\n                throw new Error (\"Unknown function: \" + this.function );\n        }\n\n        if ( r === undefined || Number.isNaN( r ) )\n            throw new Error( this.function + \" - result not a number. \" );\n\n        return r;\n    }\n    \n\n    constantValue() {\n        return this.constant;\n    }\n\n\n    operationValue(currentLength) {\n\n        if (typeof this.params[0].value !== \"function\")\n            throw new Error( \"expression p1 not valid.\" );\n\n        if ( this.operation !== \"()\" )    \n        {\n            if (typeof this.params[1].value !== \"function\")\n                throw new Error(  \"expression p2 not valid.\" );\n        }\n\n        if (this.operation === \"+\")\n            return this.params[0].value(currentLength) + this.params[1].value(currentLength);\n\n        else if (this.operation === \"-\")\n            return this.params[0].value(currentLength) - this.params[1].value(currentLength);\n\n        else if (this.operation === \"*\")\n            return this.params[0].value(currentLength) * this.params[1].value(currentLength);\n\n        else if (this.operation === \"/\")\n            return this.params[0].value(currentLength) / this.params[1].value(currentLength);\n            \n        else if (this.operation === \"==\")\n            return this.params[0].value(currentLength) == this.params[1].value(currentLength);\n\n        else if (this.operation === \"!=\")\n            return this.params[0].value(currentLength) != this.params[1].value(currentLength);\n\n        else if (this.operation === \"<\")\n            return this.params[0].value(currentLength) < this.params[1].value(currentLength);\n\n        else if (this.operation === \"<=\")\n            return this.params[0].value(currentLength) <= this.params[1].value(currentLength);\n            \n        else if (this.operation === \">\")\n            return this.params[0].value(currentLength) > this.params[1].value(currentLength);\n\n        else if (this.operation === \">=\")\n            return this.params[0].value(currentLength) >= this.params[1].value(currentLength);\n\n        else if (this.operation === \"()\")\n            return this.params[0].value(currentLength);\n\n        else if  ( this.operation === \"^\" )\n        {\n            const p1 = this.params[0].value(currentLength);\n            const p2 = this.params[1].value(currentLength);\n            return Math.pow( p1, p2 );\n        }    \n        else if (this.operation === \"?\")\n        {\n            const conditionTestResult = this.params[0].value(currentLength);\n            if ( conditionTestResult )\n                return this.params[1].value(currentLength);\n            else\n                return this.params[2].value(currentLength);\n        }\n\n\n        throw new Error( \"Unknown operation: \" + this.operation );\n    }\n\n\n    keywordValue(currentLength) {\n        if (this.variable === \"CurrentLength\")\n            return currentLength;\n        throw new Error( \"Unknown keyword: \" + this.variable );\n    }\n\n\n    nameWithPopupValue( name ) {\n        try {\n            return '<span title=\"' + ( Math.round( this.value() * 1000 ) / 1000 ) + ' ' + this.pattern.units + '\">' + name + '</span>';\n        } catch ( e ) {\n            return \"ERROR1:\" + name;\n        }\n    }\n\n\n    html( asFormula, currentLength, parentPrecedence ) {\n\n        if ( ! asFormula )\n        {\n            try { \n                return this.value( currentLength );\n                //return Number.parseFloat( this.value( currentLength ) ).toPrecision(4); \n            } catch ( e ) {\n                return \"???\"\n            }\n        }\n\n        if ( this.variable )\n        {\n            if (this.variable === \"CurrentLength\")\n                return this.nameWithPopupValue( \"CurrentLength\" );\n\n            return this.nameWithPopupValue( this.variable.name );\n        }\n\n        if ( this.constant !== undefined )\n            return this.constant;\n\n        if ( this.function )\n        {\n            switch ( this.function ) {\n\n            case \"lengthOfLine\":\n                return this.nameWithPopupValue( \"lengthOfLine(\" + this.drawingObject1.ref() + \", \" + this.drawingObject2.ref() + \")\" );\n\n            case \"angleOfLine\":\n                return this.nameWithPopupValue( \"angleOfLine(\" + this.drawingObject1.ref() + \", \" + this.drawingObject2.ref() + \")\" );\n\n            case \"lengthOfSpline\":\n            case \"lengthOfSplinePath\":\n            \n                if ( ! this.drawingObject )\n                    return this.nameWithPopupValue( this.function + \"( curve:\" + this.splineDrawingObject.ref() + \", from:\" + this.drawingObject1.ref() + \", to:\" + this.drawingObject2.ref() + \")\" );\n                \n                return this.nameWithPopupValue( this.function + \"(\" + this.drawingObject.ref() + (this.segment?\", segment:\" + this.segment:\"\") + \")\" );\n\n            case \"angle1OfSpline\":\n            case \"angle2OfSpline\":\n            case \"lengthOfSplineControl1\":\n            case \"lengthOfSplineControl2\":\n            \n                if ( ! this.drawingObject )\n                    return this.nameWithPopupValue( this.function + \"( curve:\" + this.splineDrawingObject.ref() + \", at:\" +\n                                            ((( this.splineDrawingObject.startPoint == this.drawingObject1 ) || ( this.splineDrawingObject.endPoint == this.drawingObject1 ))\n                                            ? this.drawingObject2.ref() : this.drawingObject1.ref() ) + \")\" );\n\n                return this.nameWithPopupValue( this.function + \"(\" + this.drawingObject.ref() + \")\" );\n\n            case \"lengthOfArc\":\n            \n                if ( ! this.drawingObject )\n                    return \"lengthOfArc( ??? )\";\n                \n                return this.nameWithPopupValue( \"lengthOfArc(\" + this.arcSelection + \" \" + this.drawingObject.ref() + \")\" );\n\n            case \"radiusOfArc\":\n\n                if ( ! this.drawingObject )\n                    return \"radiusOfArc( ??? )\";\n                \n                return this.nameWithPopupValue( \"radiusOfArc(\" + this.drawingObject.ref() + ( this.radiusSelection ? \", radius-\" + this.radiusSelection : \"\" ) + \")\" );\n            \n            case \"-\":\n            \n                return ( \"-(\" + this.params[0].html( asFormula, currentLength ) + \")\" ); \n            \n            case \"sqrt\":\n            case \"sin\":\n            case \"cos\":\n            case \"tan\": \n            case \"sinD\":\n            case \"cosD\":\n            case \"tanD\": \n            case \"asin\":\n            case \"acos\":\n            case \"atan\": \n            case \"abs\":\n                return ( this.function + \"(\" + this.params[0].html( asFormula, currentLength ) + \")\" ); \n\n            default:\n                return \"UNKNOWN FUNCTION TYPE\" + this.function;\n            }\n        }\n\n        if ( this.operation === \"?\" )\n        {\n            return this.params[0].html( asFormula, currentLength ) + \" ? \" +\n                   this.params[1].html( asFormula, currentLength ) + \" : \" +\n                   this.params[2].html( asFormula, currentLength );\n        }\n        else if ( this.operation ) \n        {\n            let useOperatorNotation = false;\n            let precedence = 0;\n\n            if (    (this.operation === \"+\") \n                 || (this.operation === \"-\") )\n            {\n                useOperatorNotation = \" \" + this.operation + \" \";\n                precedence = 3;\n            }\n            else if (    (this.operation === \"/\") \n                      || (this.operation === \"*\") ) \n            {\n                useOperatorNotation = \" \" + this.operation + \" \";\n                precedence = 4;\n            }\n            else if (    (this.operation === \"==\") \n                      || (this.operation === \"!=\") \n                      || (this.operation === \">=\") \n                      || (this.operation === \"<=\") \n                      || (this.operation === \">\") \n                      || (this.operation === \"<\") )\n            {\n                useOperatorNotation = \" \" + this.operation + \" \";\n                precedence = 2;\n            }\n            //power = 5\n            //ternary = 2\n\n            let t = ( useOperatorNotation || this.operation === \"()\" ? \"\" : this.operation );\n            \n            const useParenthesis = ( ( this.operation === \"()\" ) || ( precedence < parentPrecedence ) || (!useOperatorNotation) );\n\n            if ( useParenthesis )\n                t += \"(\";\n\n            let first = true;\n            for ( const p of this.params )\n            {\n                if ( ! first )\n                {\n                    if ( useOperatorNotation )\n                        t += useOperatorNotation;\n                    else\n                        t += \",\";\n                }\n                t += p.html( asFormula, currentLength, precedence );\n                first = false;\n            }\n\n            if ( useParenthesis )\n                t += \")\";\n\n            return t;\n        }\n\n        return \"???\";\n    };\n\n\n    //The dependencies of this expression need adding to the source drawingObject that uses this expression\n    addDependencies( source, dependencies ) \n    {\n        if ( typeof this.drawingObject1 !== \"undefined\" )\n            dependencies.add( source, this.drawingObject1 );\n\n        if ( typeof this.drawingObject2 !== \"undefined\" )\n            dependencies.add( source, this.drawingObject2 );\n\n        if ( typeof this.splineDrawingObject !== \"undefined\" )\n            dependencies.add( source, this.splineDrawingObject );\n\n        if ( typeof this.drawingObject !== \"undefined\" ) //e.g. lengthOfArc\n            dependencies.add( source, this.drawingObject );\n\n        //variable or measurement\n        if (    ( typeof this.variable !== \"undefined\")\n             && (    ( this.variable.isMeasurement  )\n                  || ( this.variable.isVariable  ) ) )\n            dependencies.add( source, this.variable );\n\n        //recurse into the expression parameters.\n        if ( this.params )\n        {       \n            for ( const p of this.params ) {\n                p.addDependencies( source, dependencies );\n            }\n        }\n    }\n}\n\n\n","//(c) Copyright 2019 Jason Dore\n//https://github.com/MrDoo71/PatternEditor\n\nclass Bounds {\n    \n    constructor() {\n        this.minX = undefined;\n        this.maxX = undefined;\n        this.minY = undefined;\n        this.maxY = undefined;\n    }\n\n    //offset is optinoal\n    adjust( p, offset ) {\n\n        if (!p)\n            return; //e.g. an error\n\n        const mx = offset?.mx;\n        const my = offset?.my;\n        this.adjustToIncludeXY( p.x + ( mx !== undefined ? mx : 0 ) , p.y + ( my !== undefined ? my : 0 ) );\n    }\n\n    adjustToIncludeXY( x, y ) {\n\n        if (x !== undefined) {\n            if ((this.minX === undefined) || (x < this.minX))\n                this.minX = x;\n            if ((this.maxX === undefined) || (x > this.maxX))\n                this.maxX = x;\n        }\n\n        if (y !== undefined) {\n            if ((this.minY === undefined) || (y < this.minY))\n                this.minY = y;\n            if ((this.maxY === undefined) || (y > this.maxY))\n                this.maxY = y;\n        }\n\n        if ( this.parent )\n            this.parent.adjustToIncludeXY( x,y );\n    }\n\n    adjustForLine(line, offset) {\n\n        if (!line)\n            return;\n\n        this.adjust(line.p1, offset);\n        this.adjust(line.p2, offset);\n    }\n\n    diagonaglLength() {\n\n        const deltaX = ( this.maxX - this.minX );\n        const deltaY = ( this.maxY - this.minY );\n    \n        return Math.sqrt( Math.pow(deltaX,2) + Math.pow(deltaY,2) );\n    }\n\n    \n    /**\n     * Return true if these bounds contain the point, false if the point\n     * is outside these bounds. \n     * \n     * @param {*} p \n     */\n    containsPoint( p, tolerance )\n    {\n        tolerance = tolerance === undefined ? 0 : tolerance;\n        return    ( p.x >= ( this.minX - tolerance ) )\n               && ( p.x <= ( this.maxX + tolerance ) )\n               && ( p.y >= ( this.minY - tolerance ) )\n               && ( p.y <= ( this.maxY + tolerance ) );\n    }\n}\n\n\n","//(c) Copyright 2019 Jason Dore\n//\n//This library collates the various geometric calclulation requirements\n//of the drawing objects into a small number of primitives. \n//\n//This library then generally uses other libraries to perform those \n//geometric calculations where they are non trivial\n//(e.g. intersection of lines with splines).\n//\n//Source maintained at: https://github.com/MrDoo71/PatternEditor\n\n//If making improvements also research:\n//https://github.com/DmitryBaranovskiy/raphael/blob/v2.1.1/dev/raphael.core.js#L1837\n//https://github.com/jarek-foksa/path-data-polyfill/blob/master/path-data-polyfill.js\n\nimport { Intersection, Point2D, ShapeInfo } from '../node_modules/kld-intersections/dist/index-esm.js';\n\n\n//An arc of a circle\nclass GeoArc {\n\n    //center\n    //radius\n    //angle1 - degrees!\n    //angle2 - degrees!\n\n    constructor( center, radius, angle1 /*deg*/, angle2 /*deg*/ ) {\n        this.center = center;\n        this.radius = radius;\n        this.angle1 = angle1;\n        this.angle2 = angle2;\n\n        //Correct 180-0 to 180-360\n        if ( this.angle2 < this.angle1 )\n            this.angle2+=360;\n    }\n\n    intersect( arc2 )\n    {\n        //https://mathworld.wolfram.com/Circle-CircleIntersection.html\n        //consider this arc to be centred at 0,0 and re-base arc 2 so that its origin is relative to this\n        const a1 = new GeoArc( new GeoPoint(0,0), this.radius, this.angle1, this.angle2 );\n        const a2 = new GeoArc( new GeoPoint( arc2.center.x - this.center.x, arc2.center.y - this.center.y), arc2.radius, arc2.angle1, arc2.angle2 );\n\n        //rotate both arcs to be on the x axis. \n        const currentAngle = (new GeoLine( a1.center, a2.center )).angleDeg();\n        a1.angle1 -= currentAngle;\n        a1.angle2 -= currentAngle;\n        a2.angle1 -= currentAngle;\n        a2.angle2 -= currentAngle;\n        //rotate a2's center.\n        a2.center = a2.center.rotate( a1.center, -currentAngle );\n\n        //Now both a1 and a2 have been shift and rotated such that a1 is at 0,0 an a2 is at x,0.\n        //d - distance between centers\n        const d = Math.abs( a2.center.x );\n        if ( d > ( a1.radius + a2.radius ) )\n            return []; //circles are too far apart, they don't intersect.\n\n        const x =  ( Math.pow( d, 2 ) - Math.pow( a2.radius, 2 ) + Math.pow( a1.radius, 2 ) ) / ( 2 * d );\n        const y = Math.sqrt( Math.pow( a1.radius, 2 ) - Math.pow( x, 2 ) );  //the other point is -y\n\n        let i1 = new GeoPoint( x, y );\n        let i2 = new GeoPoint( x, -y );\n\n        const intersects = [ i1, i2 ];\n        const goodIntersects = [];\n\n        for( let n in intersects )\n        {\n            let i = intersects[n];\n\n            //Rotate back\n            i = i.rotate( a1.center, currentAngle );\n\n            //Translate back onto the original coordinate system\n            i.x = i.x + this.center.x;\n            i.y = i.y + this.center.y;\n\n            //Finally check whether either or both of these intersections are within the angles of the arc.\n            if (   ( this.isPointOnArc( i ) )\n                && ( arc2.isPointOnArc( i ) ) )\n                goodIntersects.push( i );    \n        }\n\n        return goodIntersects;\n    }\n\n    //nb for this use we don't need to check radius. \n    isPointOnArc( p )\n    {\n        //nb, what about arcs spanning 0 ?  +360?\n        const line1 = new GeoLine( this.center, p )\n        return ( line1.angleDeg() >= this.angle1 ) && ( line1.angleDeg() <= this.angle2); \n    }\n\n    //https://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes F.6.4 Conversion from center to endpoint parameterization\n    //Hashed together from https://stackoverflow.com/questions/30277646/svg-convert-arcs-to-cubic-bezier and https://github.com/BigBadaboom/androidsvg/blob/5db71ef0007b41644258c1f139f941017aef7de3/androidsvg/src/main/java/com/caverock/androidsvg/utils/SVGAndroidRenderer.java#L2889\n    asGeoSpline() {\n\n        const angleStartRad = this.angle1 / 360.0 * 2.0 * Math.PI;\n        const angleEndRad = this.angle2 / 360.0 * 2.0 * Math.PI;\n        const angleExtentRad = angleEndRad - angleStartRad;\n        const numSegments =  Math.ceil( Math.abs(angleExtentRad) * 2.0 / Math.PI); \n        const angleIncrement = angleExtentRad / numSegments;\n\n        const controlLength = 4.0 / 3.0 * Math.sin(angleIncrement / 2.0) / (1.0 + Math.cos(angleIncrement / 2.0));\n\n        const nodeData = [];\n\n        let node = {};\n        nodeData.push( node );\n\n        for (let i=0; i<numSegments; i++)\n        {\n            let angle = angleStartRad + i * angleIncrement;\n            let dx = Math.cos(angle) * this.radius;\n            let dy = Math.sin(angle) * this.radius;\n\n            if ( ! node.point )\n                node.point = new GeoPoint( this.center.x + dx , this.center.y - dy );\n\n            node.outControlPoint = new GeoPoint( this.center.x + dx - controlLength * dy, this.center.y - dy - controlLength * dx );\n\n            angle += angleIncrement;\n            dx = Math.cos(angle) * this.radius;\n            dy = Math.sin(angle) * this.radius;\n\n            node = {};\n            nodeData.push( node );\n            node.inControlPoint = new GeoPoint( this.center.x + dx + controlLength * dy, this.center.y - dy + controlLength * dx );\n            node.point = new GeoPoint( this.center.x + dx, this.center.y - dy );\n        }\n\n        return new GeoSpline( nodeData );\n    }\n\n\n    splineBetweenPoints( previousP, nextP )\n    {\n        return this.asGeoSpline().splineBetweenPoints( previousP, nextP );\n    }\n\n\n    /**\n     * Get the points on this arc where the tangents that go through\n     * the specified point touch this arc.\n     * \n     * @param {*} pointOnTangent \n     */\n    getPointsOfTangent( pointOnTangent ) {\n        //There is a right angle triangle where\n        //hypotenous is the line tangent-arc.center - known length\n        //lines tangent-p and p-center form a right angle.   p-center has length arc.radius\n        //cos(i) = arc.radius / tangent-arc.center\n        const radius  = this.radius;\n        const h       = new GeoLine( this.center, pointOnTangent );\n        const hLength = h.length;\n        const angle   = Math.acos( radius/hLength ); //Would be an error if hLength < radius, as this means pointOnTangent is within the circle. \n\n        const tangentTouchPoints = [ this.center.pointAtDistanceAndAngleRad( radius, h.angle - angle ),\n                                     this.center.pointAtDistanceAndAngleRad( radius, h.angle + angle ) ];        \n        \n        return tangentTouchPoints;\n    }\n\n\n    svgPath() {\n\n        //TODO if this is a full circle we should really generate an svg circle rather than using a path\n\n        const arcPath = d3.path();\n\n        let a2 = this.angle2;\n\n        if ( a2 < this.angle1 )\n            a2 += 360;\n\n        arcPath.arc( this.center.x, this.center.y, \n                    this.radius, \n                    -this.angle1 * Math.PI / 180, -a2 * Math.PI / 180, true );\n             \n\n                     //console.log( \"Could have used d3:\", arcPath.toString() );\n        return arcPath.toString();\n\n        //var a2 = this.angle2;\n        //if ( this.angle2 < this.angle1 )\n        //    a2 = a2 + 360;\n\n        //THIS NOT WORKING\n        //var svgParams = this.centeredToSVG( this.center.x, this.center.y, this.radius, this.radius, -this.angle1, a2-this.angle1, 0 );\n        //var path = \"M\" + svgParams.x + \",\" + svgParams.y \n        //     + \"A\" + svgParams.rx + \",\" + svgParams.ry \n        //     + \",\" + svgParams.xAxisAngle + \",\" + svgParams.largeArc + \",\" + svgParams.sweep + \",\"\n        //     + svgParams.x1 + \",\" + svgParams.y1 \n        //\n        //console.log( \"svgPath() - \", path );\n\n        //return path;\n    }    \n\n    \n    pointAlongPath( length ) {\n        const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        if ( length > path.getTotalLength() )\n            length = path.getTotalLength();\n        const p = path.getPointAtLength( length );\n        return new GeoPoint( p.x, p.y );\n    }        \n\n    \n    pointAlongPathFraction( fraction ) {\n\n        if ( fraction == 0 )\n        {\n            return this.center.pointAtDistanceAndAngleDeg( this.radius, this.angle1 );\n        }\n\n        if ( fraction == 1 )\n        {\n            return this.center.pointAtDistanceAndAngleDeg( this.radius, this.angle2 );\n        }\n\n        const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        const l = path.getTotalLength();\n        const p = path.getPointAtLength( l * fraction );\n        return new GeoPoint( p.x, p.y );\n    }\n    \n    \n    pathLength() {\n        const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        return path.getTotalLength();\n    }             \n\n\n    asShapeInfo() {  \n        if (( this.angle1 == 0 ) && ( this.angle2 == 360 ))\n            return ShapeInfo.circle( this.center.x, this.center.y, this.radius );\n\n        //ShapeInfo angles seem to go clockwise from East, rather than our anti-clickwise angles\n        let angle1 = 360-this.angle2;\n        let angle2 = 360-this.angle1;\n\n        if ( angle1 < 0 )\n        {\n            angle1 += 360;\n            angle2 += 360;\n        }\n\n        //if ( angle2 < 0 )\n        //    angle2 += 360;\n\n        if ( angle2 < angle1 )\n            angle2 += 360;\n\n        //if ( angle2 > 360 ) //the original angle1 was negative. \n        //{\n        //    angle1 -= 360;\n        //    angle2 -= 360;\n        //}\n\n        //if ( angle1 < 0 )\n        //angle1 = 0;\n\n        //if ( angle2 < 0 )\n        //angle2 = 0;\n\n       // if ( angle2 < angle1 )\n       // {\n       //     var t = angle2;\n       //     angle2 = angle1;\n       //     angle1 = t;\n       // }\n                \n        return ShapeInfo.arc( this.center.x, this.center.y, this.radius, this.radius, angle1 * Math.PI/180, angle2 * Math.PI/180 );\n    }    \n\n\n    applyOperation( pointTransformer ) {//apply a operationFlip or operationRotate to this GeoArc\n        const center2 = pointTransformer( this.center );\n\n        //s = the point on the arc that we start drawing\n        const s = this.center.pointAtDistanceAndAngleDeg( this.radius, this.angle1 );\n        const s2 = pointTransformer( s );\n        const s2line = new GeoLine( center2, s2 );\n        const startAngle2 = s2line.angleDeg();\n\n        //f = the point on the arc that we finish drawing\n        const f = this.center.pointAtDistanceAndAngleDeg( this.radius, this.angle2 );\n        const f2 = pointTransformer( f );\n        const f2line = new GeoLine( center2, f2 );\n        const finishAngle2 = f2line.angleDeg();\n\n        //Because we've flipped the start angle becomes the finish angle and vice verasa.\n        return new GeoArc(  center2, this.radius, finishAngle2 /*deg*/, startAngle2 /*deg*/  );\n    }\n\n\n    adjustBounds( bounds ) {\n\n        //An arc, between 70, and 100 degrees would be bounded by the start and stop\n        //points and the point at 90 degrees. \n        var startPoint = this.pointAlongPathFraction(0);\n        var endPoint = this.pointAlongPathFraction(0);\n        bounds.adjust( startPoint );\n        bounds.adjust( endPoint );\n\n        if (( this.angle1 < 90 ) && ( this.angle2 > 90 ))        \n            bounds.adjustToIncludeXY( this.center.x, this.center.y - this.radius ); //add N\n\n        if (( this.angle1 < 180 ) && ( this.angle2 > 180 ))        \n            bounds.adjustToIncludeXY( this.center.x - this.radius, this.center.y ); //add W\n\n        if (( this.angle1 < 270 ) && ( this.angle2 > 270 ))        \n            bounds.adjustToIncludeXY( this.center.x, this.center.y + this.radius ); //add S\n\n        if (( this.angle1 < 360 ) && ( this.angle2 > 360 ))        \n            bounds.adjustToIncludeXY( this.center.x + this.radius, this.center.y ); //add E\n    }\n}\n\n\n","//(c) Copyright 2019 Jason Dore\n//\n//This library collates the various geometric calclulation requirements\n//of the drawing objects into a small number of primitives. \n//\n//This library then generally uses other libraries to perform those \n//geometric calculations where they are non trivial\n//(e.g. intersection of lines with splines).\n//\n//Source maintained at: https://github.com/MrDoo71/PatternEditor\n\nclass GeoEllipticalArc {\n\n    constructor( center, radius1, radius2, angle1, angle2, rotationAngle ) {\n        this.center = center;\n        this.radius1 = radius1;\n        this.radius2 = radius2;\n        this.angle1 = angle1;\n        this.angle2 = angle2;\n        this.rotationAngle = rotationAngle;\n    }\n\n\n    clone() {\n        return new GeoEllipticalArc( this.center, \n                                     this.radius1, \n                                     this.radius2, \n                                     this.angle1,  \n                                     this.angle2,\n                                     this.rotationAngle );\n    }\n\n    //https://observablehq.com/@toja/ellipse-and-elliptical-arc-conversion\n    //http://xahlee.info/js/svg_path_ellipse_arc.html\n    //https://observablehq.com/@toja/ellipse-and-elliptical-arc-conversion\n    getEllipsePointForAngle(cx, cy, rx, ry, phi, theta) {\n        const { sin, cos, sqrt, pow } = Math;\n        \n        //https://en.wikipedia.org/wiki/Ellipse#Polar_form_relative_to_focus\n        const radius=   ( rx * ry )\n                      / sqrt( pow( rx * sin( theta ),2 ) + pow( ry * cos( theta ), 2 ) ); \n\n        const M = radius * cos(theta),\n              N = radius * sin(theta);  \n\n        return { x: cx + cos(phi) * M - sin(phi) * N,\n                 y: cy + sin(phi) * M + cos(phi) * N };\n     }\n\n\n    //TODO based on SVG book, but corrected\n    centeredToSVG( cx, cy, rx, ry, thetaDeg/*arcStart*/, deltaDeg/*arcExtent*/, phiDeg/*x axis rotation*/ ) {\n        \n        const theta = thetaDeg * Math.PI / 180;\n        const endTheta = ( thetaDeg + deltaDeg ) * Math.PI / 180;\n        const phiRad = phiDeg * Math.PI / 180;\n\n        //console.log( \"centeredToSVG thetaDeg: \" + thetaDeg );\n        //console.log( \"centeredToSVG deltaDeg: \" + deltaDeg );\n        //console.log( \"centeredToSVG endThetaDeg: \" + ( thetaDeg + deltaDeg ) );\n        //console.log( \"centeredToSVG endTheta: \" + endTheta );\n\n        const start = this.getEllipsePointForAngle(cx, cy, rx, ry, phiRad, theta);\n        const end = this.getEllipsePointForAngle(cx, cy, rx, ry, phiRad, endTheta);\n\n        //console.log( \"3. centeredToSVG x0,y0: \" + x0 + \",\" + y0 );\n        //console.log( \"3. centeredToSVG x1,y1: \" + x1 + \",\" + y1 );\n\n        const largeArc = ( deltaDeg > 180 ) || ( deltaDeg < -180 ) ? 1 : 0;\n        const sweep = ( deltaDeg > 0 ) ? 0 : 1;\n         \n        return { x: start.x,\n                 y: start.y,\n                rx: rx,\n                ry: ry,\n                xAxisAngle: phiDeg,\n                largeArc: largeArc,\n                sweep: sweep,\n                x1: end.x,\n                y1: end.y };\n    }    \n\n\n    useSvgEllipse() {\n        //we can use <ellipse> if it is a full ellipse, otherwise we need to use an elliptical arc path\n        return (    ( this.angle1 === 0 ) \n                 && ( this.angle2 === 360 ) );\n    }\n\n\n    svgPath() {\n        // 90->180   -90 -> -180     -90,-90\n        // 0->90   -0 +-90\n\n\n\n        const d2 = this.centeredToSVG( this.center.x, this.center.y, this.radius1, this.radius2, 360-(this.angle1), -(this.angle2 - this.angle1), -this.rotationAngle );\n        let path = \"M\" + d2.x + \",\" + d2.y;\n        path += \" A\" + d2.rx + \" \" + d2.ry;\n        path += \" \" + d2.xAxisAngle;\n        path += \" \" + d2.largeArc + \",0\";// + d2.sweep;\n        path += \" \" + d2.x1 + \",\" + ( d2.y1 + (((d2.y===d2.y1)&&(d2.x===d2.x1))?0.001:0)  ) + \" \"; //we need to start/stop on a slightly different point\n        //The fudge above that allows the path to work even for a full ellipse should never be needed as if it is a full ellipse useSvgEllipse() should return true.\n\n        //console.log( \"GeoEllipticalArc: \" + path );\n\n        return path;\n    }\n\n\n    asShapeInfo() {\n        //TEMPORARY ON TRIAL - THIS WORKS, SO ROTATE TRANSLATE \n        //              cx, cy, rx, ry. start, end   \n        if ( this.rotationAngle === 0 )\n            return ShapeInfo.arc( this.center.x, this.center.y, this.radius1, this.radius2, this.angle1/180*Math.PI, this.angle2/180*Math.PI)\n\n        const svgPath = this.svgPath();\n        //console.log( \"EllipticalArc.asShapeInfo() this might not work for intersections... \" + svgPath );\n        return ShapeInfo.path( svgPath );\n    }\n    \n\n    asGeoSpline() {\n\n        //Un-rotate this if it is rotated\n        if ( this.rotationAngle !== 0 )\n        {\n            const center = this.center;\n            const rotationAngle = this.rotationAngle;\n            const unrotator = function( p ) {\n                return p.rotate( center, -rotationAngle );\n            };\n            const unrotatedArc = this.applyOperation( unrotator );\n\n            const unrotatedSplines = unrotatedArc.asGeoSpline();\n\n            const rerotator = function( p ) {\n                return p.rotate( center, rotationAngle );\n            };\n\n            return unrotatedSplines.applyOperation( rerotator );\n        }\n\n        //We won't be a rotated elipse. \n\n        const angleStartRad = this.angle1 / 360.0 * 2.0 * Math.PI;\n        const angleEndRad = this.angle2 / 360.0 * 2.0 * Math.PI;\n        const angleExtentRad = angleEndRad - angleStartRad;\n        const numSegments =  Math.ceil( Math.abs(angleExtentRad) * 2.0 / Math.PI); \n        const angleIncrement = angleExtentRad / numSegments;\n\n        const controlLength = 4.0 / 3.0 * Math.sin(angleIncrement / 2.0) / (1.0 + Math.cos(angleIncrement / 2.0));\n\n        const nodeData = [];\n\n        let node = {};\n        nodeData.push( node );\n\n        for (let i=0; i<numSegments; i++)\n        {\n            let angle = angleStartRad + i * angleIncrement;\n\n            let dxr1 = Math.cos(angle) * this.radius1;\n            let dxr2 = Math.cos(angle) * this.radius2;\n            let dyr1 = Math.sin(angle) * this.radius1;\n            let dyr2 = Math.sin(angle) * this.radius2;\n\n            if ( ! node.point )\n                node.point = new GeoPoint( this.center.x + dxr1 , this.center.y - dyr2 );\n\n            node.outControlPoint = new GeoPoint( this.center.x + dxr1 - controlLength * dyr1, this.center.y - dyr2 - controlLength * dxr2 );\n\n            angle += angleIncrement;\n            dxr1 = Math.cos(angle) * this.radius1;\n            dxr2 = Math.cos(angle) * this.radius2;\n            dyr1 = Math.sin(angle) * this.radius1;\n            dyr2 = Math.sin(angle) * this.radius2;\n\n            node = {};\n            nodeData.push( node );\n            node.inControlPoint = new GeoPoint( this.center.x + dxr1 + controlLength * dyr1, this.center.y - dyr2 + controlLength * dxr2 );\n            node.point = new GeoPoint( this.center.x + dxr1, this.center.y - dyr2 );\n        }\n\n        return new GeoSpline( nodeData );        \n    }\n\n\n    pointAlongPathFraction( fraction ) {\n        const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        const l = path.getTotalLength();\n        const p = path.getPointAtLength( l * fraction );\n        return new GeoPoint( p.x, p.y );\n    }       \n\n\n    pointAlongPath( length ) {\n        const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        const p = path.getPointAtLength( length );\n        return new GeoPoint( p.x, p.y );\n    }       \n\n\n    pathLength() {\n        const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        return path.getTotalLength();\n    }             \n\n\n    applyOperation( pointTransformer ) { //apply a operationFlip or operationRotate to this GeoEllipticalArc\n\n        const center2 = pointTransformer( this.center );\n\n        //Converted start and finishing angles are calculated identically to a circle\n        //It doesn't matter from this perspective whether we use radius1 or radius2\n\n        //s = the point on the arc that we start drawing\n        const s = this.center.pointAtDistanceAndAngleDeg( this.radius1, this.angle1 + this.rotationAngle );\n        const s2 = pointTransformer( s );\n        const s2line = new GeoLine( center2, s2 );\n        let startAngle2 = s2line.angleDeg();\n\n        //f = the point on the arc that we finish drawing\n        const f = this.center.pointAtDistanceAndAngleDeg( this.radius1, this.angle2 + this.rotationAngle );\n        const f2 = pointTransformer( f );\n        const f2line = new GeoLine( center2, f2 );\n        let finishAngle2 = f2line.angleDeg();\n\n        //don't abritrarily convert 360 to 0. \n        if (( finishAngle2 === 0 ) && ( this.angle2 === 360 ))\n            finishAngle2 = 360;\n\n        if (( startAngle2 === 0 ) && ( this.angle1 === 360 ))\n            startAngle2 = 360;\n\n        //Is this a good enough test?\n        const isFlip = ( this.angle1 < this.angle2 ) != ( startAngle2 < finishAngle2 );\n\n        //This is an ellipse, so we also need to adjust the ellipse rotation. \n        const r = this.center.pointAtDistanceAndAngleDeg( this.radius1, this.rotationAngle );\n        const r2 = pointTransformer( r );\n        const r2line = new GeoLine( center2, r2 );\n        let rotationAngle2 = r2line.angleDeg() + ( isFlip ? 180 : 0 );\n\n        // + 180;\n        if ( rotationAngle2 >= 360 )\n            rotationAngle2 -= 360;\n\n        //finally, start and finish point angles are defined with respect to the rotation angle\n        startAngle2 -= rotationAngle2;\n        finishAngle2 -= rotationAngle2;\n\n        //If we've flipped the start angle becomes the finish angle and vice versa.\n        return new GeoEllipticalArc( center2, this.radius1, this.radius2, isFlip ? finishAngle2 : startAngle2/*deg*/, isFlip ? startAngle2 : finishAngle2/*deg*/, rotationAngle2 /*deg*/ )\n    }\n\n\n    adjustBounds( bounds ) {\n        //TODO determine the bounds for a similar non-rotated ellipse\n        //and rotate\n\n        bounds.adjust( this.pointAlongPathFraction( 0 ) );\n        bounds.adjust( this.pointAlongPathFraction( 0.25 ) );\n        bounds.adjust( this.pointAlongPathFraction( 0.5 ) );\n        bounds.adjust( this.pointAlongPathFraction( 0.75 ) );\n        bounds.adjust( this.pointAlongPathFraction( 1 ) );\n    }\n}\n\n","//(c) Copyright 2019 Jason Dore\n//\n//This library collates the various geometric calclulation requirements\n//of the drawing objects into a small number of primitives. \n//\n//This library then generally uses other libraries to perform those \n//geometric calculations where they are non trivial\n//(e.g. intersection of lines with splines).\n//\n//Source maintained at: https://github.com/MrDoo71/PatternEditor\n\n//A line\nclass GeoLine {\n\n    //p1;\n    //p2;\n\n    constructor( p1, p2 ) {\n\n        if ( ! p1 )\n            throw new Error( \"GeoLine p1 not defined.\" );\n\n        if ( ! p2 )\n            throw new Error( \"GeoLine p2 not defined.\" );\n\n        this.p1 = p1;\n        this.p2 = p2;\n    \n        this.deltaX = ( this.p2.x - this.p1.x ); //nb. +ve to the east from p1 to p2\n        this.deltaY = ( this.p2.y - this.p1.y ); //nb +ve to the south from p1 to p2\n    \n        this.length = Math.sqrt( Math.pow(this.deltaX,2) + Math.pow(this.deltaY,2) );\n\n        //angle is anti-clockwise starting east in radians\n        this.angle = Math.atan2( -this.deltaY, this.deltaX );\n\n        if ( this.angle < 0 )\n            this.angle = this.angle + (2 * Math.PI);          \n    \n        this.slope  = ( this.deltaY / this.deltaX );\n        this.offset = this.p1.y - ( this.p1.x * this.slope ); //the y values where x = 0; the intersection of the line with the y-axis\n        //this line is generically: y = offset + ( x * slope )\n    }\n\n    //Return a GeoPoint for the intersection of this line with line2. \n    intersect( line2 ) {    \n        //intersection\n        //  // offset - line2.offset / ( line2.slope - slope ) = x\n\n        const swap = Math.abs( this.deltaX ) > Math.abs( line2.deltaX );\n        const line1s = swap ? this : line2;\n        const line2s = swap ? line2 : this;\n\n        let x, y;\n\n        if (    ( line2s.slope === Infinity ) \n             || ( line2s.slope === -Infinity )  )\n            x = line2s.p1.x;\n        else\n            x = ( line1s.offset - line2s.offset ) / ( line2s.slope - line1s.slope );\n\n        if ( line1s.slope === 0 )\n            y = line1s.p1.y;\n        else\n            y = line1s.p1.y + ( line1s.slope * ( x - line1s.p1.x ) );\n\n        return new GeoPoint(x,y);\n\n        //Using the Intersection libary requires that the finite lines intersect, rather than\n        //their infinite versions. \n        //var line1SI = this.asShapeInfo();\n        //var line2SI = line2.asShapeInfo();\n        //var intersections = Intersection.intersect(line1SI, line2SI);        \n        //intersections.points.forEach(console.log);    \n        //return new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n    }    \n\n\n    //Return a GeoPoint for where this line intersects the specified GeoArc, GeoEllipticalArc, or GeoSpline.\n    intersectArc( arc, alreadyTweaked ) { \n        //work around a bug where the arc spans 0 deg\n        if (    ( arc instanceof GeoArc )\n             && ( arc.angle1 < 0 ) \n             && ( arc.angle2 > 0 ) \n              ) //not an elliptical\n        {\n            try { \n                const arc1 = new GeoArc( arc.center, arc.radius, 0, arc.angle2 );\n                return this.intersectArc( arc1 );\n            } catch ( e ) {\n                const arc2 = new GeoArc( arc.center, arc.radius, arc.angle1 + 360, 360 );\n                return this.intersectArc( arc2 );\n            }\n        }\n        if (    ( arc.angle1 < 360 ) \n             && ( arc.angle2 > 360 ) \n             && ( arc instanceof GeoArc ) ) //not an elliptical\n        {\n            try { \n                const arc1 = new GeoArc( arc.center, arc.radius, 0, arc.angle2 -360 );\n                return this.intersectArc( arc1 );\n            } catch ( e ) {\n                const arc2 = new GeoArc( arc.center, arc.radius, arc.angle1, 360 );\n                return this.intersectArc( arc2 );\n            }\n        }\n\n        let arcSI,lineSI;\n\n        //nb there is a special case for GeoEllipticalArc where this.p1 == arc.center in \n        //which case a simple formula gives the intersect.\n\n        if (( arc instanceof GeoEllipticalArc ) && ( arc.rotationAngle !== 0 ))\n        {            \n            //console.log(\"elliptical arc \");\n            \n            //create an equivalent arc that is not rotated.\n            //create a new line, rotate the startpoint by -rotationAngle, the new lines angle should also be less by -rotationAngle\n            //finally rotate the intersect point back\n            const nrArc = new GeoEllipticalArc( arc.center,\n                                              arc.radius1,\n                                              arc.radius2, \n                                              arc.angle1, \n                                              arc.angle2,\n                                              0 );\n            const p1rotated = this.p1.rotate( arc.center, -arc.rotationAngle );\n            const bounds = new Bounds();\n            bounds.adjust( p1rotated );\n            arc.adjustBounds( bounds );\n            const maxLineLength = bounds.diagonaglLength() * 1.25;\n            const lineRotated = new GeoLine( p1rotated, p1rotated.pointAtDistanceAndAngleDeg( maxLineLength/*infinite*/, (this.angleDeg() - arc.rotationAngle) ) );\n            lineSI = lineRotated.asShapeInfo();\n            arcSI = nrArc.asShapeInfo();\n        }\n        else\n        {\n            const bounds = new Bounds();\n            bounds.adjust( this.p1 );\n            arc.adjustBounds( bounds );\n            const maxLineLength = bounds.diagonaglLength() * 1.25;\n            \n            //This should be sufficient, extend our line forward enough that it should intersect...\n            //Ensure that the line is long enough to intersect. \n            const extendedLine = new GeoLine( this.p1, this.p1.pointAtDistanceAndAngleRad( maxLineLength, this.angle ));  \n\n            arcSI = arc.asShapeInfo();\n            lineSI = extendedLine.asShapeInfo();    \n        }\n    \n        let intersections = Intersection.intersect(arcSI, lineSI);\n        \n        if ( intersections.points.length === 0 )\n        { \n            if ( ! alreadyTweaked )\n            {\n                //console.log( \"Failed for angle \", this.angle );\n                //console.log( \"PI:\", this.angle/Math.PI );\n                const lineTweaked = new GeoLine( this.p1, this.p1.pointAtDistanceAndAngleRad( this.length, this.angle + (Math.PI/180 * 0.00000001) )); //Adding a billionth of a degree fixes the broken intersection issue.\n\n                try {\n                    //This should be no different, but sometimes this works when arc-line intersect fails\n                    return lineTweaked.intersectArc( arc, true );\n                } catch ( e ) {\n                    //There still appears to be a bug in arc intersection. \n                    if (( arc instanceof GeoArc ) || ( arc instanceof GeoEllipticalArc ))\n                    {\n                        const arcAsSpline = arc.asGeoSpline();\n                        return this.intersectArc( arcAsSpline );\n                    }\n                    else\n                        throw e;\n                }\n            }\n            throw new Error( \"No intersection with arc. \" );\n        }\n\n        let whichPoint = 0;\n        if ( intersections.points.length > 1 )//-1;//0; //0 for G1 in headpattern. //intersections.points.length -1; //TODO do this properly\n        {            \n            //choose the first point we get to along the line. \n            let smallestDistance;\n            for (const i in intersections.points ) \n            {\n                const pi = intersections.points[i];\n                const p1pi = new GeoLine( this.p1, pi );\n                \n                if (    ( smallestDistance === undefined ) \n                        || (    ( Math.abs( p1pi.angle - this.angle ) < 0.0001 ) //rather than 180 deg the other way (allowing for rounding errors)\n                            && ( p1pi.length < smallestDistance ) ) )\n                {\n                    smallestDistance = p1pi.length;\n                    whichPoint = i;\n                }\n            }\n        }\n\n        let intersect = new GeoPoint( intersections.points[whichPoint].x, intersections.points[whichPoint].y );\n\n        if (( arc instanceof GeoEllipticalArc ) && ( arc.rotationAngle !== 0 ))\n        {\n            intersect = intersect.rotate( arc.center, +arc.rotationAngle );\n        }\n\n        return intersect;\n    }\n\n\n    //Return a GeoLine having applied the operationFlip or operationRotate to this GeoLine.\n    applyOperation( pointTransformer ) {\n        const p1Transformed = pointTransformer( this.p1 );\n        const p2Transformed =  pointTransformer( this.p2 );\n        return new GeoLine( p1Transformed, p2Transformed );\n    }    \n\n\n    asShapeInfo() {\n        return ShapeInfo.line( this.p1.x, this.p1.y, this.p2.x, this.p2.y );\n    }\n\n\n    svgPath() \n    {\n        return \"M\" + this.p1.x + \",\" + this.p1.y + \" \" +\n               \"L\" + this.p2.x + \",\" + this.p2.y + \" \";\n    }\n\n\n    angleDeg() {\n\n       return this.angle * 180 / Math.PI;\n    }\n\n\n    angleRad() {\n        return this.angle;\n    }\n\n\n    getLength() {\n        return this.length;\n    }\n\n\n    pointAlongPathFraction( fraction ) {\n        if ( fraction == 0 )\n            return this.p1;\n\n        if ( fraction == 100 )\n            return this.p2;\n\n        return new GeoPoint( ( this.p2.x - this.p1.x ) * fraction + this.p1.x,\n                             ( this.p2.y - this.p1.y ) * fraction + this.p1.y );\n    }\n}\n\n","//(c) Copyright 2019 Jason Dore\n//\n//This library collates the various geometric calclulation requirements\n//of the drawing objects into a small number of primitives. \n//\n//This library then generally uses other libraries to perform those \n//geometric calculations where they are non trivial\n//(e.g. intersection of lines with splines).\n//\n//Source maintained at: https://github.com/MrDoo71/PatternEditor\n\n\n//A point\nclass GeoPoint {\n\n    constructor( x, y ) {\n        this.x = x;\n        this.y = y;\n\n        if ( isNaN( this.x ) )\n            throw new Error( \"GeoPoint x not a number.\" );\n            \n        if ( isNaN( this.y ) )\n            throw new Error( \"GeoPoint y not a number.\" );\n    }\n\n    \n    line( point2 ) {    \n        throw \"this looks broken, two params, not four\";\n        return new GeoLine( this.x, this.y, point2.x, point2.y );\n    }\n\n\n    pointAtDistanceAndAngleRad( length, angle /*radians anti-clockwise from east*/ ) {        \n        const x = this.x + length * Math.cos( -1 * angle ); //TODO this is a guess!\n        const y = this.y + length * Math.sin( -1 * angle );   \n        return new GeoPoint( x, y );\n    }\n\n\n    pointAtDistanceAndAngleDeg( length, angle /*deg anti-clockwise from east*/ ) {        \n        return this.pointAtDistanceAndAngleRad( length, angle * Math.PI / 180 );\n    }\n\n\n    rotate( center, rotateAngleDeg ) {\n        //Convert degrees to radians\n        \n        const centerToSourceLine = new GeoLine( center, this );\n        const distance = centerToSourceLine.getLength();\n        const angle = centerToSourceLine.angleDeg() + rotateAngleDeg;\n\n        const result = center.pointAtDistanceAndAngleDeg( distance, angle );\n        return result;\n    }\n\n\n    asPoint2D() {\n        return new Point2D( this.x, this.y );\n    }\n\n\n    equals( p )\n    {\n        if ( p === this )\n            return true;\n\n        if ( this.x === p.x && this.y === p.y )\n            return true;\n\n        const dx = Math.abs( this.x - p.x );\n        const dy = Math.abs( this.y - p.y );\n        \n        if (( dx < 0.01 ) && ( dy < 0.01 ))\n        {\n            if (( dx < 0.001 ) && ( dy < 0.001 ))\n            {\n                //console.warn(\"EQUALS - CLOSE! \" + Math.max( dx, dy ) + \" MATCHED\");\n                return true;\n            }\n            //else\n            //    console.warn(\"EQUALS - CLOSE! \" + Math.max( dx, dy ) + \" X\");\n        }\n\n        return this.x === p.x && this.y === p.y;\n    }\n\n\n    toString()\n    {\n        return \"(\" + Math.round(this.x*100)/100 + \",\" + Math.round(this.y*100)/100 + \")\";\n    }\n}\n\n","//(c) Copyright 2019 Jason Dore\n//\n//This library collates the various geometric calclulation requirements\n//of the drawing objects into a small number of primitives. \n//\n//This library then generally uses other libraries to perform those \n//geometric calculations where they are non trivial\n//(e.g. intersection of lines with splines).\n//\n//Source maintained at: https://github.com/MrDoo71/PatternEditor\n\nclass GeoSpline {\n\n    //nodeData - an array of\n    //{ \n    //  inAngle  : deg\n    //  inLength : \n    //  point    : \n    //  outAngle : deg\n    //  outLength:  \n    //} \n\n    constructor( nodeData ) {\n        this.nodeData = nodeData;\n\n        for( const n of this.nodeData )\n        {\n            if (( ! n.outControlPoint ) && ( typeof n.outAngle === \"number\" ) && ( typeof n.outLength === \"number\" ))\n            {\n                n.outControlPoint = n.point.pointAtDistanceAndAngleDeg( n.outLength, n.outAngle );\n            }\n            else if (    n.outControlPoint \n                     && ( n.outAngle === undefined || n.outLength === undefined ) )\n            {\n                //using angles in formulas requires that these are set\n                const l = new GeoLine( n.point, n.outControlPoint );\n                n.outAngle = l.angleDeg();\n                n.outLength = l.getLength();\n            }\n\n            if (( ! n.inControlPoint ) && ( typeof n.inAngle === \"number\" ) && ( typeof n.inLength === \"number\" ))\n            {\n                n.inControlPoint = n.point.pointAtDistanceAndAngleDeg( n.inLength, n.inAngle );\n            }\n            else if ( n.inControlPoint\n                      && ( n.inAngle === undefined || n.inLength === null ))\n            {\n                const l = new GeoLine( n.point, n.inControlPoint );\n                n.inAngle = l.angleDeg();\n                n.inLength = l.getLength();\n            }\n        }\n    }\n\n\n    applyOperation( pointTransformer ) { //apply a operationFlip or operationRotate to this GeoSpline\n        const nodeData = [];\n        for ( const node of this.nodeData )\n        {\n            //Need a control point, not a length and angle. \n            let inPoint = node.inControlPoint;\n            let outPoint = node.outControlPoint;\n            \n            if ( ( ! inPoint ) && ( node.inLength !== undefined ) )            \n                inPoint = node.point.pointAtDistanceAndAngleDeg( node.inLength, node.inAngle );\n\n            if ( ( ! outPoint ) && ( node.outLength !== undefined ) )\n                outPoint = node.point.pointAtDistanceAndAngleDeg( node.outLength, node.outAngle );\n    \n            const inPointTransformed = inPoint === undefined ? undefined : pointTransformer( inPoint );\n            const outPointTransformed =  outPoint === undefined ? undefined : pointTransformer( outPoint );\n\n            nodeData.push( {inControlPoint:   inPointTransformed,\n                            point:            pointTransformer( node.point ),\n                            outControlPoint:  outPointTransformed } ) ;\n        }\n        return new GeoSpline( nodeData );\n    }\n\n\n    svgPath( continuePath ) {\n        const nodeData = this.nodeData;\n        let path = continuePath ? continuePath : \"\";\n        for ( let i=0; i<nodeData.length; i++ )\n        {\n            if ( i===0 )\n            {\n                path+= ( continuePath ? \"L\" : \"M\" ) + Math.round( nodeData[i].point.x *1000 )/1000 + \",\" + Math.round( this.nodeData[i].point.y *1000)/1000 ;\n            }\n            else\n            {\n                const controlPoint1 = ( typeof nodeData[i-1].outControlPoint !== \"undefined\" ) ? nodeData[i-1].outControlPoint\n                                                                                             : nodeData[i-1].point.pointAtDistanceAndAngleDeg( nodeData[i-1].outLength, nodeData[i-1].outAngle );\n\n                const controlPoint2 = ( typeof nodeData[i].inControlPoint !== \"undefined\" ) ? nodeData[i].inControlPoint\n                                                                                          : nodeData[i].point.pointAtDistanceAndAngleDeg( nodeData[i].inLength, nodeData[i].inAngle );\n\n                path += \"C\" + Math.round( controlPoint1.x * 1000 ) / 1000 + \",\" + Math.round( controlPoint1.y * 1000 ) / 1000 +\n                        \" \" + Math.round( controlPoint2.x * 1000 ) / 1000 + \",\" + Math.round( controlPoint2.y * 1000 ) / 1000 +\n                        \" \" + Math.round( nodeData[i].point.x * 1000 ) / 1000 + \",\" + Math.round( nodeData[i].point.y * 1000 ) / 1000 + \" \";\n            }\n        }\n        //console.log( \"GeoSpline: \" + path );\n        return path;\n    }\n\n\n    reverse()\n    {\n        const len = this.nodeData.length;\n        const revNodeData = [len];\n        for ( const i in this.nodeData )\n        {\n            const node = this.nodeData[i];\n\n            revNodeData[len-i-1] =  { inControlPoint:   node.outControlPoint,\n                                      point:            node.point,\n                                      outControlPoint:  node.inControlPoint };\n        }\n        return new GeoSpline( revNodeData );\n    }\n\n\n    asShapeInfo() {\n        return ShapeInfo.path( this.svgPath() );\n    }\n    \n\n    pointAlongPathFraction( fraction ) {\n\n        if ( fraction == 0 )\n            return this.nodeData[0].point;\n\n        if ( fraction == 1 )\n            return this.nodeData[ this.nodeData.length-1 ].point;\n\n        const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        const l = path.getTotalLength();\n        const p = path.getPointAtLength( l * fraction );\n\n        //Note, we cannot, even if a single segment use this.getPointForT() because\n        //length is not linear with t.\n        //\n        //If we want to do the calculation ourselves it will by treating the curve\n        //as 50 or so little lines using this.getPointForT() and using the length of\n        //those lines. \n\n        return new GeoPoint( p.x, p.y );\n    }       \n\n\n    pointAlongPath( length ) {\n        const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        const xy = path.getPointAtLength( length );    \n        const p = new GeoPoint( xy.x, xy.y );\n\n        //If we want to do the calculation ourselves: \n        //iterate over the segments, adding their length to the total\n        //if a segment would blow the total, then instead guess a value \n        //of t for the last bit of length required. Return the point appropriate to that t. \n        //t = 0\n        //g = 0.01\n        //lastP = nodeData[0].point;\n        //for( var t=0.0; t<1.0; t+=g )\n        //   nextP = this.getPointForT( t + g );\n        //   lineLength = \n        //   totalLength += lineLength\n        //   if ( totalLength > length )\n        //      return a point along this last line. \n\n        //let's cross check!\n        if ( this.nodeData.length === 2 )\n        {\n            const t = this.findTForPoint( p );\n\n            if ( t === undefined )\n                console.log(\"ERROR: Result of pointAlongPath() is not on path?\" );\n        }\n        else\n        {\n            const cut = this.cutAtPoint( p );\n            if ( cut === undefined )\n                console.log(\"ERROR: Result of pointAlongPath() is not on path?\" );\n        }\n\n        return p;\n    }\n\n\n    pathLengthAtPoint( p ) {\n        //do a binary search on the length of the curve to find out best % along curve that is our intersection point. \n\n        const firstNode = this.nodeData[0].point;\n        if (    ( p.x === firstNode.x )\n             && ( p.y === firstNode.y ) )\n             return 0;\n\n        const lastNode = this.nodeData[ this.nodeData.length -1 ].point;\n        if (    ( p.x === lastNode.x )\n             && ( p.y === lastNode.y ) )\n             return this.pathLength();\n\n        const cutSpline = this.cutAtPoint( p ).beforePoint;\n\n        return cutSpline.pathLength();\n    }\n\n\n    /**\n     * Return the value t for this spline.\n     * If this spline has two nodes, then t is between 0 and 1, or undefined if point p is not on the curve.\n     * If this spline has three+ nodes then t is between 0 and nodes.length-1. \n     * @param {*} p \n     * @returns \n     */\n    findTForPoint(p) {\n\n        //We could do this for each segnment and instantly dismiss any segment where p not in the box bounded by\n        //the polygon nodeDate[0].point, nodeData[0].outControlPoint, nodeData[1].inControlPoint, nodeData[1].point. \n        if ( this.nodeData.length !== 2 )\n        {\n            for ( let i=0; i<(this.nodeData.length-1); i++ )\n            {\n                const node1 = this.nodeData[i];\n                const node2 = this.nodeData[i+1];\n\n                if ( node1.point.equals( p ) )\n                    return i * 1.0;\n\n                if ( node2.point.equals( p ) )\n                    return (i+1) *1.0;\n\n                const segment = new GeoSpline( [ node1, node2 ] );\n                const bounds = new Bounds();\n                segment.adjustBounds( bounds );\n\n                if ( ! bounds.containsPoint(p, 0.0002 ) )\n                    continue;\n\n                //console.log( \"Segment \" + i );\n                const t = segment.findTForPoint(p);\n                if ( t !== undefined )\n                    return t+i\n            }\n\n            //console.warn(\"Point not on curve. not in any segments bounding box\");    \n            return undefined;\n        }\n\n        //only where nodeData.length == 2\n        //sometimes we're testing whether point p is on the arc. \n\n        if ( this.nodeData[0].point.equals( p ) )\n            return 0.0;\n\n        if ( this.nodeData[1].point.equals( p ) )\n            return 1.0;        \n\n        let minT = 0.0,\n            maxT = 1.0,\n            iter = 0;\n\n        const threshold = 0.0001;\n\n        let t;\n        let closestDistance;\n        let closestT;\n        while( iter < 20 ) { //after 20 iterations the interval will be tiny\n            iter++;\n            closestDistance = undefined;\n            closestT = null;\n            const interval = (maxT - minT)/4; //0.25 first time around.\n            for( t = minT; t<=maxT; t+= interval ) //five iterations the first time, 0, 0.25, 0.5, 0.75, 1.0\n            {\n                const pt = this.getPointForT( t );\n                const d = Math.sqrt( Math.pow( pt.x - p.x, 2) + Math.pow( pt.y - p.y, 2) );\n                if (( closestDistance === undefined ) || ( d < closestDistance ))\n                {\n                    closestT = t;\n                    closestDistance = d;\n                }\n\n                if ( d < threshold )\n                {\n                    //console.log( \"findT i:\" + iter + \" t:\" + t + \" d:\" + d + \" FOUND\" );\n                    return t;\n                }\n\n            }\n            minT = Math.max( closestT - (interval*1.001), 0.0 ); //So at the end of iteration 1 we'll be setting up a span next time that is 0.5 wide, which we'll cut into five slots \n            maxT = Math.min( closestT + (interval*1.001), 1.0 );\n            //console.log( \"i:\" + iter + \" minT:\" + minT + \" maxT:\" + maxT + \" closestT:\" + closestT + \" threshold:\" + threshold + \" closestDistance: \" + closestDistance  );\n        }\n        \n        if (   ( closestT >= 0.0 ) \n            && ( closestT <= 1.0 ) )\n        {\n            const pt = this.getPointForT( closestT );\n            const d = Math.sqrt( Math.pow( pt.x - p.x, 2) + Math.pow( pt.y - p.y, 2) );\n\n            if ( d <= (threshold*10) ) //Stocking top appears to need threshold*2\n            {\n                //console.warn(\"Iter max reached. interval:\" + (maxT-minT) + \" d:\" + d + \" threshold:\" + threshold + \" closestT\"+ closestT + \" FOUND\");    \n                return t; \n            }\n\n        }\n\n        //console.warn(\"Point not on curve. interval:\" + (maxT-minT) + \" d:\" + closestDistance + \" threshold:\" + threshold + \" closestT\"+ closestT);    \n\n        return undefined;\n    }\n\n    pathSegment( segment ) {\n        if ( ! segment )\n            return this;\n\n        //Create a shorter path\n        const startNode = this.nodeData[ segment -1 ];\n        const endNode = this.nodeData[ segment ];\n        const shorterPath = new GeoSpline( [ startNode, endNode ] );\n        return shorterPath;\n    }\n\n\n    /**\n     * Return the length of this spline, or the given segment. \n     * @param {*} segment \n     * @returns \n     */\n    pathLength( segment ) {\n\n        if ( segment ) {\n            return this.pathSegment(segment).pathLength();\n        }\n\n        const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        return path.getTotalLength();\n    }\n\n\n    splineBetweenPoints( p1, p2 )\n    {\n        let t1 = this.findTForPoint(p1);\n\n        if ( t1 === undefined )\n            throw new Error( \"p1 is not on spline.\" );\n\n        let t2 = this.findTForPoint(p2);\n\n        if ( t2 === undefined )\n            throw new Error( \"p2 is not on spline.\" );\n\n        if (( t1 === 0 ) && ( t2 === this.nodeData.length ))\n            return this;\n\n        if ( t1 > t2 )\n        {\n            //Swap the parameters\n            const p = p1;\n            p1 = p2;\n            p2 = p;\n            const t = t1;\n            t1 = t2;\n            t2 = t;\n        }\n\n        if (    Number.isInteger( t1 ) \n             && Number.isInteger( t2 ) )\n        {\n            //An easy subset of the curve matching the nodes.\n            const nodeSubset = [];\n            for ( let i= t1; i<=t2; i++ )\n                nodeSubset.push( this.nodeData[i] );\n            return new GeoSpline( nodeSubset );\n        } \n\n        //This alternative doesn't quite work out the way it should, but would be slightly more efficient. \n        //E.g. if t1=0.5 t2=4.5\n        //For each of 0,1,2,3,4,5\n        //0 less than t1, split and add part2 and modified node 1\n        //1 skip as we added a modified node1\n        //2 add\n        //3 add\n        //4 add\n        //5 greater than t2, split and add part1, and modify what we added in 4\n        //1.2 - 1.3\n        //1 less than t1, split and add part 2\n        //2 greater than t2, split and add part 1;\n        try{        \n\n            if (    ( Math.floor(t1) != Math.floor(t2) )\n                 && ( Math.ceil(t1) != Math.ceil(t2) ) ) //e.g. 0.5 and 1 would fail the first test, but match this one. \n            {\n                const nodeSubset = [];\n                for ( let i= Math.floor(t1); i<=Math.ceil(t2); i++ )\n                {\n                    if ( i < t1 )\n                    {\n                        const segment = this.pathSegment( i+1 ); \n                        const splits = segment.cutAtT( t1 - Math.floor(t1) );\n                        const n2 = this.nodeData[i+1];\n                        splits.afterPoint.nodeData[1].outControlPoint = n2.outControlPoint;\n                        splits.afterPoint.nodeData[1].outAngle = n2.outAngle;\n                        splits.afterPoint.nodeData[1].outLength = n2.outLength;\n                        nodeSubset.push( splits.afterPoint.nodeData[0] );\n                        nodeSubset.push( splits.afterPoint.nodeData[1] );\n                        i++; //we've already done i+1\n                    }\n                    else if ( i > t2 )\n                    {\n                        const segment = this.pathSegment( i ); \n                        const splits = segment.cutAtT( t2 - Math.floor(t2) );\n                        const p = nodeSubset.pop();\n                        splits.beforePoint.nodeData[0].inControlPoint = p.inControlPoint;\n                        splits.beforePoint.nodeData[0].inAngle = p.inAngle;\n                        splits.beforePoint.nodeData[0].inLength = p.inLength;\n                        nodeSubset.push( splits.beforePoint.nodeData[0] );\n                        nodeSubset.push( splits.beforePoint.nodeData[1] );\n                    }\n                    else\n                        nodeSubset.push( this.nodeData[i] )\n                }\n                return new GeoSpline( nodeSubset );\n            }\n            \n        } catch ( e ) {\n            console.log(\"Failed fast splineBetweenPoints() \", e );\n        }\n\n        //The older way which works but needs to find t2 afresh\n        const c1 = this.cutAtPoint( p1 );\n\n        if ( c1 === undefined )\n            throw new Error( \"p1 is not on spline.\" );\n\n        const splineAfterPoint = c1.afterPoint;\n        const c3 = splineAfterPoint.cutAtPoint( p2 );\n        if ( ! c3 )\n            console.log(\"c3 not found\"); //this is odd because c1 and c2 were found\n        const cut2 = c3 ? c3.beforePoint : splineAfterPoint;\n        return cut2;\n        //Compare the two approaches\n        // if ( alt )\n        // {\n        //     if ( alt.nodeData.length == cut2.nodeData.length )\n        //     {\n        //         if ( alt.toString() !== cut2.toString() )\n        //         {\n        //             console.log( \"*********** ERROR ********** - same length\" );\n        //             console.log( alt.toString() );\n        //             console.log( cut2.toString() );\n        //         }\n        //     }\n        //     else\n        //     {\n        //         console.log( \"*********** ERROR ********** - different length\" );\n        //     }\n\n        //     if ( alt.svgPath() == cut2.svgPath() )\n        //     {\n        //         console.log(\"******* GREAT *****\" );\n        //     }\n        //     else{\n        //         console.log(\"*********** ERROR **********\" );\n        //         console.log( alt.svgPath() );\n        //         console.log( cut2.svgPath() );\n        //     }            \n        // }\n\n        \n    }\n\n\n    //https://pomax.github.io/bezierinfo/chapters/decasteljau/decasteljau.js\n    getStrutPoints(t) {\n        return this.applyDecasteljau(t).strutPoints;\n    }\n\n\n    getPointForT(t) {\n        return this.applyDecasteljau(t).point;\n    }\n\n    \n    //private\n    applyDecasteljau(t) {\n        //only valid where nodeData.length === 2\n        if ( this.nodeData.length !== 2 )\n            throw( \"applyDecasteljau only valid for a segment\" );\n\n        let points = [ this.nodeData[0].point, this.nodeData[0].outControlPoint, this.nodeData[1].inControlPoint, this.nodeData[1].point ];\n        const strutPoints = [];\n\n        for( const p of points )\n            strutPoints.push( p );\n\n        while( points.length > 1 )\n        {\n            const newPoints = [];\n            for( let i=0; i<points.length-1; i++ )\n            {\n\n                const newPoint = new GeoPoint( (1-t) * points[i].x + t * points[i+1].x,\n                                             (1-t) * points[i].y + t * points[i+1].y );\n                newPoints.push( newPoint );\n                strutPoints.push( newPoint );\n            }\n            points = newPoints;\n        }\n\n        return { strutPoints:strutPoints, point:points[0] };\n    }    \n\n\n    //Returns { beforePoint: a GeoSpline, afterPoint: a GeoSpline } //though either may be null\n    //https://pomax.github.io/bezierinfo/#splitting\n    cutAtPoint( p ) { \n        const nodeData = this.nodeData;\n\n        //The simplest spline with its two control points. \n        if ( nodeData.length === 2 )\n        {\n            if ( ! nodeData[1].point )\n                console.log(\"no point?\");\n\n            if ( nodeData[0].point.equals(p) ) \n                return { beforePoint: null,\n                         afterPoint : this };\n            else if ( nodeData[1].point.equals(p) ) \n                return { beforePoint: this,\n                         afterPoint : null };\n            else {\n                const t = this.findTForPoint(p);\n                if ( t === undefined )\n                    return undefined;\n\n                return this.cutAtT( t );\n            }\n        }\n\n        const nodesBeforeCut = [],\n              nodesAfterCut = [];\n\n        let cutMade = false;\n        for( let i=0; i<nodeData.length; i++ )\n        {\n            const n1 = nodeData[i];\n            const n2 = i+1 < nodeData.length ? nodeData[i+1] : null;\n\n            if ( cutMade ) \n            {\n                nodesAfterCut.push( n1 );\n            }\n            else if ( n1.point.equals(p) )  \n            {\n                cutMade = true;\n                nodesBeforeCut.push( n1 );\n                nodesAfterCut.push( n1 );\n            }\n            else if ( n2?.point.equals(p) )\n            {\n                cutMade = true;\n                nodesBeforeCut.push( n1 );\n                nodesBeforeCut.push( n2 );\n            }\n            else if ( n2 != null )\n            {\n                const segment = this.pathSegment( i+1 ); //so from i to i+1\n\n                const bounds = new Bounds();\n                segment.adjustBounds( bounds );\n\n                const tWithinSegment = bounds.containsPoint(p,0.0002) ? segment.findTForPoint(p) : undefined;\n\n                if ( tWithinSegment === 0 ) //effectively ( n1.point.equals(p) ), it must have been a rounding issue that prevented an exact match.\n                {\n                    cutMade = true;\n                    nodesBeforeCut.push( n1 );\n                    nodesAfterCut.push( n1 );    \n                }\n                else if ( tWithinSegment === 1) //effectively ( n2.point.equals(p) ), it must have been a rounding issue that prevented an exact match.\n                {\n                    cutMade = true;\n                    nodesBeforeCut.push( n1 );\n                    nodesBeforeCut.push( n2 );\n                }\n                else \n                {\n                    const pointLiesInThisSegment = tWithinSegment !== undefined;\n\n                    if ( ! pointLiesInThisSegment )\n                    {\n                        if ( ! cutMade )\n                            nodesBeforeCut.push(n1);\n\n                        if ( cutMade )\n                            nodesAfterCut.push(n1);\n                    }\n                    else //point lies in this segment\n                    {\n                        const splits = segment.cutAtT( tWithinSegment );\n\n                        splits.beforePoint.nodeData[0].inControlPoint = n1.inControlPoint;\n                        splits.beforePoint.nodeData[0].inAngle = n1.inAngle;\n                        splits.beforePoint.nodeData[0].inLength = n1.inLength;\n                        nodesBeforeCut.push( splits.beforePoint.nodeData[0] );\n                        nodesBeforeCut.push( splits.beforePoint.nodeData[1] );\n\n                        splits.afterPoint.nodeData[1].outControlPoint = n2.outControlPoint;\n                        splits.afterPoint.nodeData[1].outAngle = n2.outAngle;\n                        splits.afterPoint.nodeData[1].outLength = n2.outLength;\n                        nodesAfterCut.push( splits.afterPoint.nodeData[0] );\n                        nodesAfterCut.push( splits.afterPoint.nodeData[1] );\n                        i++; //because we've done n2 effectively\n                        cutMade = true;\n                    }\n                }\n            }\n            else if ( n2 == null )\n            {\n                if ( cutMade )\n                    nodesAfterCut.push( n1 )\n                else\n                    nodesBeforeCut.push( n1 );\n            }\n        }\n\n        return { beforePoint: nodesBeforeCut.length < 2 ? null : new GeoSpline(nodesBeforeCut),\n                 afterPoint : nodesAfterCut.length < 2 ? null : new GeoSpline(nodesAfterCut) };\n    }\n\n\n    cutAtT( t )\n    {    \n        if ( t === 0 ) \n            return { beforePoint: null,\n                     afterPoint : this };\n        else if ( t === 1 ) \n            return { beforePoint: this,\n                     afterPoint : null };\n\n        const struts = this.getStrutPoints( t );\n\n        const c1n1 = this.createNodeData( undefined, struts[0], struts[4] );\n        const c1n2 = this.createNodeData( struts[7], struts[9], undefined );\n        const c2n1 = this.createNodeData( undefined, struts[9], struts[8] );\n        const c2n2 = this.createNodeData( struts[6], struts[3], undefined );\n                    \n        return { beforePoint: new GeoSpline( [c1n1,c1n2] ),\n                 afterPoint : new GeoSpline( [c2n1,c2n2] ) };            \n    }    \n\n\n    createNodeData( inControlPoint, point, outControlPoint ) \n    {\n        const c = { inControlPoint:  inControlPoint,\n                    point:           point,\n                    outControlPoint: outControlPoint };\n\n        if ( inControlPoint )\n        {\n            const inControlPointLine = new GeoLine( point, inControlPoint );\n            c.inAngle = inControlPointLine.angleDeg();\n            c.inLength = inControlPointLine.getLength();\n        }\n        if ( outControlPoint )\n        {\n            const outControlPointLine = new GeoLine( point, outControlPoint );    \n            c.outAngle = outControlPointLine.angleDeg();\n            c.outLength = outControlPointLine.getLength();\n        }\n\n        return c;\n    }    \n\n\n    //if offset {mx, my} are specified then add these\n    adjustBounds( bounds, offset ) {\n\n        //It won't be a perfectly tight bounding box, but \n        //it should be ample to encompass the spline loosely. \n        \n        for ( const node of this.nodeData )\n        {\n            bounds.adjust( node.point, offset );\n\n            if ( node.inControlPoint )\n                bounds.adjust( node.inControlPoint, offset );\n\n            if ( node.outControlPoint )\n                bounds.adjust( node.outControlPoint, offset );\n        }\n    }\n\n\n    //The direction we are travelling at the end of this spline\n    exitAngleDeg()\n    {\n        return this.angleLeavingNode( this.nodeData.length-1 );\n    }\n\n\n    entryAngleDeg()\n    {\n        return this.angleEnteringNode( 0 );\n    }\n\n\n    angleEnteringNode( i )\n    {\n        const n = this.nodeData[ i ];\n        let inControlPoint = n.inControlPoint;\n        let outControlPoint = n.outControlPoint;\n        let directionLine;\n\n        if ( inControlPoint && inControlPoint.equals( n.point ) )\n            inControlPoint = undefined;\n\n        if ( outControlPoint && outControlPoint.equals( n.point ) )\n            outControlPoint = undefined;\n\n        if (( ! inControlPoint ) && ( i > 0 ))\n            inControlPoint = this.nodeData[ i-1 ].outControlPoint; \n        else if (( ! outControlPoint )&&( i < this.nodeData.length-1 ))\n            outControlPoint = this.nodeData[ i+1 ].inControlPoint;  \n\n        if ( inControlPoint)\n            directionLine = new GeoLine( inControlPoint, n.point );\n        else if ( outControlPoint )\n            directionLine = new GeoLine( n.point, outControlPoint );\n\n        return directionLine.angleDeg();\n    }\n\n\n    angleLeavingNode( i )\n    {\n        const n = this.nodeData[ i ];\n        let inControlPoint = n.inControlPoint;\n        let outControlPoint = n.outControlPoint;\n        let directionLine;\n\n        //What if length2 == 0, the node's inControlPoint == point\n        if (( i == 0 ) && ( outControlPoint ))\n        {\n            if ( outControlPoint.equals( n.point ) )\n                outControlPoint = undefined;\n            else    \n                directionLine = new GeoLine( n.point, n.outControlPoint );\n        }\n        else if (( i == this.nodeData.length-1 ) && ( inControlPoint ))\n        {\n            if ( inControlPoint.equals( n.point ) )\n                inControlPoint = undefined;\n            else\n                directionLine = new GeoLine( n.inControlPoint, n.point );\n        }\n\n        if ( ! directionLine ) \n        {\n            if (( ! outControlPoint )&&( i < this.nodeData.length-1 ))\n                outControlPoint = this.nodeData[ i+1 ].inControlPoint;  \n            else if (( ! inControlPoint ) && ( i > 0 ))\n                inControlPoint = this.nodeData[ i-1 ].outControlPoint; \n\n            if ( outControlPoint )\n                directionLine = new GeoLine( n.point, outControlPoint );\n            else if ( inControlPoint )\n                directionLine = new GeoLine( inControlPoint, n.point );\n        }\n\n        return directionLine.angleDeg();\n    }\n\n\n    toString()\n    {\n        let s = \"GeoSpline[ \";\n        for ( const node of this.nodeData )\n        {\n            if ( node.inControlPoint )\n                s += \" in:\" + node.inControlPoint.toString();\n\n            if ( node.inAngle )\n                s += \" inAng:\" + node.inAngle;\n\n            if ( node.inLength )\n                s += \" inLen:\" + node.inLength;\n\n            s += \" p:\" + node.point.toString();\n\n            if ( node.outControlPoint )\n                s += \" out:\" + node.outControlPoint.toString();\n\n            if ( node.outAngle )\n                s += \" outAng:\" + node.outAngle;\n\n            if ( node.outLength )\n                s += \" outLen:\" + node.outLength;\n        }\n        s += \"]\";\n        return s;\n    }\n\n\n    parallelCurve( sa, depth )\n    {\n        const debug = false;\n\n        if ( sa === 0 )\n        {\n            return { baseCurve: this, offsetCurve: this }; \n        }\n\n        let newNodeData = [];\n        const len = this.nodeData.length;\n        let prevNode;\n        let prevNewNode;\n        for ( let i=0; i<len; i++ )\n        {\n            const node = this.nodeData[i];\n\n            const newNode = {};\n            newNodeData[i] = newNode;\n            \n            let tangentAfterDeg = this.angleLeavingNode(i) + 90; //TODO we could allow for pointy nodes by using angleArrivingNode for the inControlPoint\n            if ( tangentAfterDeg > 360 )\n                tangentAfterDeg -= 360;\n\n            const tangentBeforeDeg = tangentAfterDeg; //TODO determine this separately?\n\n            newNode.point = node.point.pointAtDistanceAndAngleDeg( sa, tangentAfterDeg );\n            if ( node.inControlPoint )\n                newNode.inControlPoint = node.inControlPoint.pointAtDistanceAndAngleDeg( sa, tangentBeforeDeg );\n            if ( node.outControlPoint )\n                newNode.outControlPoint = node.outControlPoint.pointAtDistanceAndAngleDeg( sa, tangentAfterDeg );\n\n            if ( prevNode )\n            {\n                //We can do slightly better still, for each step/simplespline how much bigger is the new curve (distance between start/end nodes), \n                //and scale the length of the control points accordingly. \n                const distance = (new GeoLine( prevNode.point, node.point )).getLength();\n                const offsetDistance = (new GeoLine( prevNewNode.point, newNode.point )).getLength();\n                if ( ( distance > 0 ) && ( offsetDistance > 0) && ( distance != offsetDistance ) )\n                {\n                    const extension = offsetDistance / distance; //nb this could be <0 or >0.\n                    if ( Math.abs(extension) > 0.001 )\n                    {\n                        //console.log( (extension>1 ? \"Extending\" : \"Reducing\" ) + \" the control point lengths to \" + (Math.round( extension * 1000)/10) + \"%\" );\n                        const outControlPointLine = new GeoLine( prevNewNode.point, prevNewNode.outControlPoint );\n                        prevNewNode.outAngle = outControlPointLine.angleDeg();\n                        prevNewNode.outLength = outControlPointLine.getLength() * extension;\n                        prevNewNode.outControlPoint = prevNewNode.point.pointAtDistanceAndAngleDeg( prevNewNode.outLength, prevNewNode.outAngle );\n                        const inControlPointLine = new GeoLine( newNode.point, newNode.inControlPoint );\n                        newNode.inAngle = inControlPointLine.angleDeg();\n                        newNode.inLength = inControlPointLine.getLength() * extension;                        \n                        newNode.inControlPoint = newNode.point.pointAtDistanceAndAngleDeg( newNode.inLength, newNode.inAngle );\n                    }\n                }\n            }\n\n            prevNode = node;\n            prevNewNode = newNode;\n        }\n        const offsetCurve = new GeoSpline( newNodeData );\n\n        newNodeData = [];\n        let c1, c2, c3;\n        for ( let i=1; i<len; i++ )\n        {\n            const prevNode = this.nodeData[i-1];\n            const node = this.nodeData[i];\n            const thisSegmentAsGeoSpline = new GeoSpline( [ prevNode, node ] );\n            const offsetSegmentAsGeoSpline = new GeoSpline( [ offsetCurve.nodeData[i-1], offsetCurve.nodeData[i]] );\n            const errorAtHalfway = Math.abs( thisSegmentAsGeoSpline.getOffsetBetweenCurves( offsetSegmentAsGeoSpline, 0.5, sa ) - Math.abs(sa) );\n            //console.log( \"Worst:\" + worstError + \" Halfway:\" + errorAtHalfway );\n\n            //depending upon worstError decide if we're splitting this segment, if we're we can just copy it to the one we're creating\n            //if we split any, then recurse. \n            if ( debug )\n                console.log( \"Node \" + i + \" offset variance at t=0.5 \" + Math.round( errorAtHalfway/sa*1000 )/10 + \"%\" );\n\n            if ( ( isNaN( errorAtHalfway ) ) || ( (errorAtHalfway/sa) > 0.005 ) ) //0.01 would be plenty accurate enough for our purposes. \n            {\n                const struts = thisSegmentAsGeoSpline.getStrutPoints( 0.5 );\n\n                if ( c3 )\n                {\n                    c1 = null;\n                    c3.outControlPoint = struts[4];\n                    //nb c3.point should equal struts[0]\n                }\n                else\n                    c1 = this.createNodeData( undefined, struts[0], struts[4] );\n\n                c2 = this.createNodeData( struts[7], struts[9], struts[8] );\n                c3 = this.createNodeData( struts[6], struts[3], undefined );\n                            \n                if ( c1 )\n                    newNodeData.push( c1 );\n\n                c3.outControlPoint = node.outControlPoint;\n\n                newNodeData.push( c2 );\n                newNodeData.push( c3 );\n            }\n            else\n            {\n                if ( i == 1 )\n                    newNodeData.push( this.cloneNode( prevNode ) );\n\n                c3 = this.cloneNode( node ); //we must not change a node that exists on the base curve\n                newNodeData.push( c3 );\n            }\n        }\n\n        if ( newNodeData.length > this.nodeData.length )\n        {\n            if ( debug )\n            for ( const i in newNodeData )\n            {\n                const node = newNodeData[i];\n\n                if (( ! node.inControlPoint ) && ( i>0 ))\n                    console.log(\"Error, node should have inControlPoint\");\n\n                if (( ! node.outControlPoint ) && ( i<(newNodeData.length-1) ))\n                    console.log(\"Error, node should have outControlPoint\");\n\n            }\n    \n            const thisWithMoreControlPoints = new GeoSpline( newNodeData );\n\n            if ( debug )\n                console.log(\"Recursing, now has \" + thisWithMoreControlPoints.nodeData.length + \" nodes...\");\n\n            depth = depth === undefined ? 1 : depth + 1;\n            if (( depth < 8 ) && ( thisWithMoreControlPoints.nodeData.length < 10000))\n                return thisWithMoreControlPoints.parallelCurve( sa, depth );\n        }\n\n        //Also see:\n        //https://raphlinus.github.io/curves/2022/09/09/parallel-beziers.html\n        //http://brunoimbrizi.com/unbox/2015/03/offset-curve/\n\n        return { baseCurve: this, offsetCurve: offsetCurve }; \n    }   \n\n\n    //For two curves that are supposed to be paralled, \n    //what offset has actually been achieved at t?    \n    getOffsetBetweenCurves( otherCurve, t, targetOffset )\n    {\n        const pointOnThisCurve = this.getPointForT( t );\n\n        //NOTE: we cannot simply do  otherCurve.getPointForT( t ) as the two points won't necessarily be tangential.\n\n        //So, calculate a tangent from this curve to intersect the other. \n        const anotherPointATinyBitFurtherOn = this.getPointForT( t + 0.0001 );\n        const angleAtThisPoint = (new GeoLine(pointOnThisCurve,anotherPointATinyBitFurtherOn )).angleDeg();\n        let tangentAngle = angleAtThisPoint + 90;\n        if ( tangentAngle >= 360 ) \n            tangentAngle -= 360;\n        const tangentLineAtThisPoint = new GeoLine(pointOnThisCurve, pointOnThisCurve.pointAtDistanceAndAngleDeg( 10 * targetOffset, tangentAngle ) );\n\n        const otherCurveSI = otherCurve.asShapeInfo();\n        const tangentLineSI = tangentLineAtThisPoint.asShapeInfo();        \n\n        const intersections = Intersection.intersect(otherCurveSI, tangentLineSI);\n        if ( intersections.points.length === 0 )\n            return undefined;\n\n        const pointOnOtherCurve = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n\n        const line = new GeoLine( pointOnThisCurve, pointOnOtherCurve );\n        return line.getLength();\n    }\n\n\n    /**\n     * Create an extended spline with the addition of a point or another curve.  Nb. there may be an acute\n     * angle resulting. \n     */\n    extend( addition )\n    {\n        const extendedNodeData = this.nodeData.slice();\n\n        if ( addition instanceof GeoPoint )\n        {\n            const p = extendedNodeData.pop();\n\n            extendedNodeData.push( {inControlPoint:   p.inControlPoint,\n                                    point:            p.point,\n                                    outControlPoint:  p.outControlPoint ? p.outControlPoint : p.point } );\n\n            extendedNodeData.push( {inControlPoint:   addition,\n                                    point:            addition,\n                                    outControlPoint:  addition } );\n        }\n        else if ( addition instanceof GeoSpline ) \n        {\n            for( const n of addition.nodeData )\n            {\n                extendedNodeData.push( {inControlPoint:   n.inControlPoint ? n.inControlPoint : n.point,\n                                        point:            n.point,\n                                        outControlPoint:  n.outControlPoint ? n.outControlPoint : n.point } );\n            } \n        }\n        else \n            throw new Error( \"Unexpected type of addition. \" );\n            \n        return new GeoSpline( extendedNodeData );\n    }\n\n\n    cloneNode( n )\n    {\n        return { inControlPoint:  n.inControlPoint,\n                 inAngle       :  n.inAngle,\n                 inLength      :  n.inLength,\n                 point         :  n.point,\n                 outControlPoint: n.outControlPoint,\n                 outAngle      :  n.outAngle,\n                 outLength     :  n.outLength };\n    }\n}"]}