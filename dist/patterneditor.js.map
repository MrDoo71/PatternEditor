{"version":3,"sources":["nodefine.js","Expression.js","Geometry.js","drawing/DrawingObject.js","drawing/ArcSimple.js","drawing/CutSpline.js","drawing/Drawing.js","drawing/Line.js","drawing/OperationFlipByAxis.js","drawing/OperationMove.js","drawing/OperationResult.js","drawing/OperationRotate.js","drawing/PerpendicularPointAlongLine.js","drawing/PointAlongBisector.js","drawing/PointAlongLine.js","drawing/PointAlongPerpendicular.js","drawing/PointCutArc.js","drawing/PointCutSplinePath.js","drawing/PointEndLine.js","drawing/PointFromXandYOfTwoOtherPoints.js","drawing/PointIntersectArcAndAxis.js","drawing/PointIntersectArcAndLine.js","drawing/PointIntersectArcs.js","drawing/PointIntersectCircles.js","drawing/PointIntersectCurveAndAxis.js","drawing/PointIntersectCurves.js","drawing/PointIntersectLineAndAxis.js","drawing/PointLineIntersect.js","drawing/PointOfTriangle.js","drawing/PointShoulder.js","drawing/PointSingle.js","drawing/SplinePathInteractive.js","drawing/SplinePathUsingPoints.js","drawing/SplineSimple.js","drawing/SplineUsingControlPoints.js","Pattern.js","PatternPiece.js","PatternEditor.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"patterneditor.js","sourcesContent":["//TODO rename to do imports...\n//and set up a tail file to do the exports...\n\nconsole.log(\"Loading patterneditor.js\" );\n\nimport { Intersection, Point2D, ShapeInfo } from '../node_modules/kld-intersections/dist/index-esm.js';\n\n","class Expression {\n\n    constructor(data, pattern, patternPiece) {\n        this.dataDebug = data;\n        this.operation = data.operationType;\n        this.pattern = pattern;\n        this.patternPiece = patternPiece;\n\n        //divide, multiply etc. and functions too\n        if (typeof data.parameter !== \"undefined\") \n        {\n            this.params = data.parameter;\n            for (var a = 0; a < this.params.length; a++) {\n                var p = this.params[a];\n                this.params[a] = new Expression(p, pattern, patternPiece);\n            }            \n        }\n\n        //integer constant\n        if (typeof data.integerValue !== \"undefined\") \n        {\n            this.constant = data.integerValue;\n            this.value = this.constantValue; //eh?\n        }\n        else if (typeof data.decimalValue !== \"undefined\") \n        {\n            this.constant = data.decimalValue;\n            this.value = this.constantValue; //eh?\n        }\n        else if (data.operationType === \"Variable\") \n        {\n            if (data.variableType === \"Keyword\")\n            {\n                this.variable = data.keyword;\n                this.value = this.keywordValue;\n            }\n            else if (data.variableType === \"Increment\")\n            {\n                this.variable = pattern.getIncrement( data.incrementVar );\n                this.value = this.incrementValue;\n            }\n            else if ( data.measurement )\n            {\n                this.variable = pattern.getMeasurement( data.measurement );\n                this.value = this.measurementValue;\n            }\n            else if ( data.variableType === \"angleOfLine\" )\n            {\n                this.drawingObject1 = patternPiece.getObject( data.drawingObject1 );\n                this.drawingObject2 = patternPiece.getObject( data.drawingObject2 );\n                this.function = data.variableType;\n                this.value = this.functionValue;\n            }\n            else if ( data.variableType === \"lengthOfLine\" )\n            {\n                this.drawingObject1 = patternPiece.getObject( data.drawingObject1 );\n                this.drawingObject2 = patternPiece.getObject( data.drawingObject2 );\n                this.function = data.variableType;\n                this.value = this.functionValue;\n            }\n            else if ( data.variableType === \"lengthOfSplinePath\" )\n            {\n                this.drawingObject = patternPiece.getObject( \"Spl_\" + data.drawingObject1 + \"_\" + data.drawingObject2 );\n                this.function = data.variableType;\n                this.value = this.functionValue;\n            }            \n            else if ( data.variableType === \"lengthOfSpline\" )\n            {\n                //TODO TEST! if this works, combine with the one above as this is an exact copy\n                this.drawingObject = patternPiece.getObject( \"Spl_\" + data.drawingObject1 + \"_\" + data.drawingObject2 );\n                this.function = data.variableType;\n                this.value = this.functionValue;\n            }            \n            else if ( data.variableType === \"lengthOfArc\" )\n            {\n                this.drawingObject = patternPiece.getObject( data.drawingObject1 );\n                this.arcSelection = data.arcSelection;\n                this.function = data.variableType;\n                this.value = this.functionValue;\n            }            \n            else \n                throw \"Unsupported variableType:\" + data.variableType;\n        }\n        else if ( typeof data.functionName !== \"undefined\" )\n        {\n            this.function = data.functionName;\n            this.value = this.functionValue;\n            //having done the parameters earlier. \n        }\n        else if ( this.operationType !== \"undefined\" )\n        {\n            //add, multiply etc.\n            this.value = this.operationValue;\n        }\n        else throw \"Unsupported expression.\" ;\n    }\n\n    incrementValue() {\n        return this.variable.value();\n    }    \n\n    measurementValue() {\n        return this.variable.value();\n    }    \n\n    functionValue(currentLength) {\n        if ( this.function === \"angleOfLine\" )\n        {\n            var point1 = new GeoPoint( this.drawingObject1.p.x, this.drawingObject1.p.y );\n            var point2 = new GeoPoint( this.drawingObject2.p.x, this.drawingObject2.p.y );\n            var line = new GeoLine( point1, point2 );\n            return line.angleDeg();\n        }\n        else if ( this.function === \"lengthOfLine\" )\n        {\n            var point1 = new GeoPoint( this.drawingObject1.p.x, this.drawingObject1.p.y );\n            var point2 = new GeoPoint( this.drawingObject2.p.x, this.drawingObject2.p.y );\n            var line = new GeoLine( point1, point2 );\n            return line.getLength();\n        }\n        else if (    ( this.function === \"lengthOfSplinePath\" )\n                  || ( this.function === \"lengthOfSpline\" ) )\n        {\n            return this.drawingObject.curve.pathLength();\n        }        \n        else if ( this.function === \"lengthOfArc\" )\n        {\n            if ( this.arcSelection === \"wholeArc\")\n                return this.drawingObject.arc.pathLength();\n            else\n            {\n                var arcDrawingObject = this.drawingObject.curve ? this.drawingObject.curve : this.drawingObject.arc;\n\n                //where in the arc is this.drawingObject.curve?\n                var radiusToIntersectLine = new GeoLine( arcDrawingObject.center.p, this.drawingObject.p );\n                var angleToIntersectRad = radiusToIntersectLine.angle;\n                if ( this.arcSelection === \"beforeArcCut\")\n                {\n                    var arcStartAngleRad = arcDrawingObject.angle1.value() / 360 * 2 * Math.PI;\n                    var segmentRad = angleToIntersectRad-arcStartAngleRad;                    \n                    var length = radiusToIntersectLine.length * segmentRad;\n                    //throw \"stop\";\n                    return length;\n                }\n                else\n                {\n                    var arcEndAngleRad = arcDrawingObject.angle2.value() / 360 * 2 * Math.PI;\n                    var segmentRad = arcEndAngleRad - angleToIntersectRad;\n                    var length = radiusToIntersectLine.length * segmentRad;\n                    //throw \"stop\";\n                    return length;\n                }\n            }\n        }        \n        else if  ( this.function === \"sqrt\" )\n        {\n            var p1 = this.params[0].value(currentLength);\n            return Math.sqrt( p1 ); \n        }\n        else throw (\"Unknown function: \" + this.function );\n    }\n    \n    constantValue() {\n        return this.constant;\n    }\n\n    operationValue(currentLength) {\n\n        if (typeof this.params[0].value !== \"function\")\n            alert(\"param1 not known\");\n\n        if ( this.operation !== \"parenthesis\" )    \n        {\n            if (typeof this.params[1].value !== \"function\")\n                alert(\"param2 not known\");\n        }\n\n        if (this.operation === \"add\")\n            return this.params[0].value(currentLength) + this.params[1].value(currentLength);\n\n        else if (this.operation === \"subtract\")\n            return this.params[0].value(currentLength) - this.params[1].value(currentLength);\n\n        else if (this.operation === \"multiply\")\n            return this.params[0].value(currentLength) * this.params[1].value(currentLength);\n\n        else if (this.operation === \"divide\")\n            return this.params[0].value(currentLength) / this.params[1].value(currentLength);\n            \n        else if (this.operation === \"equalTo\")\n            return this.params[0].value(currentLength) == this.params[1].value(currentLength);\n\n        else if (this.operation === \"notEqualTo\")\n            return this.params[0].value(currentLength) != this.params[1].value(currentLength);\n\n        else if (this.operation === \"lessThan\")\n            return this.params[0].value(currentLength) < this.params[1].value(currentLength);\n\n        else if (this.operation === \"lessThanOrEqualTo\")\n            return this.params[0].value(currentLength) <= this.params[1].value(currentLength);\n            \n        else if (this.operation === \"greaterThan\")\n            return this.params[0].value(currentLength) > this.params[1].value(currentLength);\n\n        else if (this.operation === \"greaterThanOrEqualTo\")\n            return this.params[0].value(currentLength) >= this.params[1].value(currentLength);\n\n        else if (this.operation === \"parenthesis\")\n            return this.params[0].value(currentLength);\n\n        else if  ( this.operation === \"power\" )\n        {\n            var p1 = this.params[0].value(currentLength);\n            var p2 = this.params[1].value(currentLength);\n            return Math.pow( p1, p2 );\n        }    \n        else if (this.operation === \"ternary\")\n        {\n            var conditionTestResult = this.params[0].value(currentLength);\n            if ( conditionTestResult )\n                return this.params[1].value(currentLength);\n            else\n                return this.params[2].value(currentLength);\n        }\n\n\n        throw (\"Unknown operation: \" + this.operation);\n    }\n\n    keywordValue(currentLength) {\n        if (this.variable === \"CurrentLength\")\n            return currentLength;\n        throw (\"Unknown keyword: \" + this.variable);\n    }\n\n    html() {\n\n        if ( this.variable )\n            return this.variable;\n\n        if ( this.constant )\n            return this.constant;\n\n        if ( this.operation )\n        {\n            var t = this.operation + \"(\";\n            var first = true;\n            for ( var p in this.params )\n            {\n                if ( ! first )\n                    t += \",\";\n                t += this.params[p].html();\n                first = false;\n            }\n            t += \")\";\n            return t;\n        }\n\n        return \"EXPRESSION\";\n    }\n\n\n    addDependencies( source, dependencies ) {\n        if ( typeof this.drawingObject1 !== \"undefined\" )\n            dependencies.add( source, this.drawingObject1 );\n        if ( typeof this.drawingObject2 !== \"undefined\" )\n            dependencies.add( source, this.drawingObject2 );\n\n        if ( this.params )\n        {       \n            for (var a = 0; a < this.params.length; a++) {\n                var p = this.params[a];\n                p.addDependencies( source, dependencies );\n            }\n        }\n    }\n}\n\n\n","//(c) Copyright 2019 Jason Dore\n//Inspired by the excellent seamly2D/Valentina (XXX ref) developed by Roman/Susan etc.\n//this is a ground up implementation in Javascript intended to be compatible with, but\n//not based on, the seamly2D/Valentina pattern making systen in order to support community\n//pattern sharing website. \n\n\n//A point\nclass GeoPoint {\n\n    //x;\n    //y;\n\n    constructor( x, y ) {\n        this.x = x;\n        this.y = y;\n\n        if ( isNaN( this.x ) )\n            throw \"GeoPoint x not a number.\";\n            \n        if ( isNaN( this.y ) )\n            throw \"GeoPoint y not a number.\";\n    }\n\n    line( point2 ) {    \n        return new GeoLine( this.x, this.y, point2.x, point2.y );\n    }\n\n    pointAtDistanceAndAngle( length, angle /*radians anti-clockwise from east*/ ) {        \n        var x = this.x + length * Math.cos( -1 * angle ); //TODO this is a guess!\n        var y = this.y + length * Math.sin( -1 * angle );   \n        return new GeoPoint( x, y );\n    }\n\n    asPoint2D()\n    {\n        return new Point2D( this.x, this.y );\n    }\n}\n\n\n//A line\nclass GeoLine {\n\n    //p1;\n    //p2;\n\n    constructor( p1, p2 ) {\n        this.p1 = p1;//new GeoPoint( x1, y1 );\n        this.p2 = p2;//new GeoPoint( x2, y2 );\n    \n        this.deltaX = ( this.p2.x - this.p1.x ); //nb. +ve to the east from p1 to p2\n        this.deltaY = ( this.p2.y - this.p1.y ); //nb +ve to the south from p1 to p2\n    \n        this.length = Math.sqrt( Math.pow(this.deltaX,2) + Math.pow(this.deltaY,2) );\n\n        //angle is anti-clockwise starting east in radians\n        this.angle = Math.atan2( -this.deltaY, this.deltaX );\n\n        if ( this.angle < 0 )\n            this.angle = this.angle + (2 * Math.PI);          \n    \n        //alert( \"Line angle:\" + this.angle + \" (\" + ( this.angle / (2*Math.PI) * 360) + \"deg anti clockwise from east\" );\n    \n        this.slope  = ( this.deltaY / this.deltaX );\n        this.offset = this.p1.y - ( this.p1.x * this.slope ); //the y values where x = 0; the intersection of the line with the y-axis\n        //this line is generically: y = offset + ( x * slope )\n    }\n\n    intersect( line2 ) {    \n        //intersection\n        //  // offset - line2.offset / ( line2.slope - slope ) = x\n\n        var swap = Math.abs( this.deltaX ) > Math.abs( line2.deltaX );\n        var line1s = swap ? this : line2; //this.p1.x < this.p2.x ? this : new GeoLine( this.p2, this.p1 );\n        var line2s = swap ? line2 : this; //line2.p1.x < line2.p2.x ? line2 : new GeoLine( line2.p2, line2.p1 );\n\n\n        var x, y;\n\n        if (    ( line2s.slope === Infinity ) \n             || ( line2s.slope === -Infinity )  )\n            x = line2s.p1.x;\n        else\n            x = ( line1s.offset - line2s.offset ) / ( line2s.slope - line1s.slope );\n\n        if ( line1s.slope === 0 )\n            y = line1s.p1.y;\n        else\n            y = line1s.p1.y + ( line1s.slope * ( x - line1s.p1.x ) );\n\n        return new GeoPoint(x,y);\n\n        //Using the Intersection libary requires that the finite lines intersect, rather than\n        //their infinite versions. \n        //var line1SI = this.asShapeInfo();\n        //var line2SI = line2.asShapeInfo();\n        //var intersections = Intersection.intersect(line1SI, line2SI);        \n        //intersections.points.forEach(console.log);    \n        //return new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n    }    \n\n    intersectArc( arc )\n    {\n        //var path = ShapeInfo.path(\"M40,70 Q50,150 90,90 T135,130 L160,70 C180,180 280,55 280,140 S400,110 290,100\");\n        var arcSI = arc.asShapeInfo();\n        var lineSI = this.asShapeInfo();\n        var intersections = Intersection.intersect(arcSI, lineSI);\n        \n        intersections.points.forEach(console.log);    \n        return new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n    }\n\n    asShapeInfo()\n    {\n        return ShapeInfo.line( this.p1.x, this.p1.y, this.p2.x, this.p2.y );\n    }\n\n\n    angleDeg() {\n        var deltaX = (this.p2.x - this.p1.x);\n        var deltaY = -1 * (this.p2.y - this.p1.y); //-1 because SVG has y going downwards\n\n        //if ( deltaX === 0 )\n        //    return deltaY > 0 ? 90 : 270;\n\n        return Math.atan2( deltaY, deltaX ) * 180 / Math.PI;\n    }\n\n\n    getLength() {\n        return this.length;\n    }\n}\n\n\nclass GeoArc {\n\n    //center\n    //radius\n    //amgle1\n    //angle2\n\n    constructor( center, radius, angle1, angle2 ) {\n        this.center = center;\n        this.radius = radius;\n        this.angle1 = angle1;\n        this.angle2 = angle2;\n\n        //Correct 180-0 to 180-360\n        if ( this.angle2 < this.angle1 )\n        this.angle2+=360;\n    }\n\n    //TODO based on SVG book \n    centeredToSVG( cx, cy, rx, ry, theta/*arcStart*/, delta/*arcExtent*/, phi/*x axis rotation*/ )\n    {\n        var endTheta, phiRad;\n        var x0, y0, x1, y1, largeArc, sweep;\n        theta = theta * Math.PI / 180;\n        endTheta = ( theta + delta ) * Math.PI / 180;\n        phiRad = phi * Math.PI / 180;\n\n        x0 = cx + Math.cos( phiRad ) * rx * Math.cos(theta) +\n                  Math.sin( -phiRad ) * ry * Math.sin(theta);\n    \n        y0 = cy + Math.sin( phiRad ) * rx * Math.cos(theta) +\n                  Math.cos( phiRad ) * ry * Math.sin(theta);\n    \n        x1 = cx + Math.cos( phiRad ) * rx * Math.cos(endTheta) +\n                  Math.sin( -phiRad ) * ry * Math.sin(endTheta);\n    \n        y1 = cy + Math.sin( phiRad ) * rx * Math.cos(endTheta) +\n                  Math.cos( phiRad ) * ry * Math.sin(endTheta);\n    \n        largeArc = ( delta > 180 ) ? 1 : 0;\n        sweep = ( delta > 0 ) ? 1 : 0;\n         \n        return { x: x0,\n                 y: y0,\n                rx: rx,\n                ry: ry,\n                xAxisAngle: phi,\n                largeArc: largeArc,\n                sweep: sweep,\n                x1: x1,\n                y1: y1 };\n    }    \n\n\n    svgPath()\n    {\n        var arcPath = d3.path();\n        arcPath.arc( this.center.x, this.center.y, \n                     this.radius, \n                     -this.angle1 * Math.PI / 180, -this.angle2 * Math.PI / 180, true );        \n        console.log( \"Could have used d3:\", arcPath.toString() );\n        return arcPath.toString();\n\n        //var a2 = this.angle2;\n        //if ( this.angle2 < this.angle1 )\n        //    a2 = a2 + 360;\n\n        //THIS NOT WORKING\n        //var svgParams = this.centeredToSVG( this.center.x, this.center.y, this.radius, this.radius, -this.angle1, a2-this.angle1, 0 );\n        //var path = \"M\" + svgParams.x + \",\" + svgParams.y \n        //     + \"A\" + svgParams.rx + \",\" + svgParams.ry \n        //     + \",\" + svgParams.xAxisAngle + \",\" + svgParams.largeArc + \",\" + svgParams.sweep + \",\"\n        //     + svgParams.x1 + \",\" + svgParams.y1 \n        //\n        //console.log( \"svgPath() - \", path );\n\n        //return path;\n    }    \n\n    \n    pointAlongPath( length ) {\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        if ( length > path.getTotalLength() )\n            length = path.getTotalLength();\n        var p = path.getPointAtLength( length );\n        console.log(p);      \n        return new GeoPoint( p.x, p.y );\n    }        \n\n    \n    pointAlongPathFraction( fraction ) {\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        var l = path.getTotalLength();\n        var p = path.getPointAtLength( l * fraction );\n        console.log(p);      \n        return new GeoPoint( p.x, p.y );\n    }         \n    \n    \n    pathLength() {\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        return path.getTotalLength();\n    }             \n\n\n    asShapeInfo()\n    {        \n        var angle1, angle2;\n        if ( this.angle1 > this.angle2 )\n        {\n            angle1 = this.angle1;\n            angle2 = this.angle2;\n        }\n        else\n        {\n            angle1 = this.angle2;\n            angle2 = this.angle1;\n        }\n        //create(ShapeInfo.ARC, args, [\"center\", \"radiusX\", \"radiusY\", \"startRadians\", \"endRadians\"]);\n        return ShapeInfo.arc( this.center.asPoint2D(), this.radius, this.radius, angle1 * Math.PI/180, angle2 * Math.PI/180 );\n    }    \n}\n\n\nclass GeoSpline {\n\n    //nodeData - an array of\n    //{ \n    //  inAngle  : \n    //  inLength : \n    //  point    : \n    //  outAngle : \n    //  outLength:  \n    //} \n\n    constructor( nodeData ) {\n        this.nodeData = nodeData;\n    }\n\n    svgPath()\n    {\n        var nodeData = this.nodeData;\n        var path;\n        for ( var i=0; i<nodeData.length; i++ )\n        {\n            if ( i===0 )\n            {\n                path = \"M\" + nodeData[i].point.x + \",\" + this.nodeData[i].point.y ;\n            }\n            else\n            {\n                var controlPoint1 = ( typeof nodeData[i-1].outControlPoint !== \"undefined\" ) ? nodeData[i-1].outControlPoint\n                                                                                             : nodeData[i-1].point.pointAtDistanceAndAngle( nodeData[i-1].outLength, nodeData[i-1].outAngle / 360 * 2 * Math.PI );\n\n                var controlPoint2 = ( typeof nodeData[i].inControlPoint !== \"undefined\" ) ? nodeData[i].inControlPoint\n                                                                                          : nodeData[i].point.pointAtDistanceAndAngle( nodeData[i].inLength, nodeData[i].inAngle / 360 * 2 * Math.PI );\n                path += \"C\" + controlPoint1.x + \" \" + controlPoint1.y +\n                        \" \" + controlPoint2.x + \" \" + controlPoint2.y +\n                        \" \" + nodeData[i].point.x + \" \" + nodeData[i].point.y;\n            }\n        }\n\n        console.log( \"GeoSpline: \" + path );\n\n        return path;\n    }\n\n    asShapeInfo()\n    {        \n        return ShapeInfo.path( this.svgPath() );\n    }\n    \n    pointAlongPathFraction( fraction ) {\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        var l = path.getTotalLength();\n        var p = path.getPointAtLength( l * fraction );\n        console.log(p);      \n        return new GeoPoint( p.x, p.y );\n    }       \n\n    pointAlongPath( length ) {\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        var p = path.getPointAtLength( length );\n        console.log(p);      \n        return new GeoPoint( p.x, p.y );\n    }       \n\n\n    pathLength() {\n        var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute( \"d\", this.svgPath() );\n        return path.getTotalLength();\n    }             \n\n}\n\n","class DrawingObject /*abstract*/ {\n    \n    constructor(data) {\n        this.data = data;\n    }\n\n    drawLabel(g, o) {\n        //g - the svg group we want to add the text to\n        //o - the drawing object\n        var d = o.data; //the original json data\n        if (typeof o.p.x !== \"number\")\n            return;\n        g.append(\"text\")\n            .attr(\"x\", o.p.x + (typeof d.mx === \"undefined\" ? 0 : d.mx))\n            .attr(\"y\", o.p.y + (typeof d.my === \"undefined\" ? 0 : d.my))\n            .text(d.name)\n            .attr(\"font-size\", (10 / scale) + \"px\");\n    }\n\n    drawDot(g, o) {\n        var d = o.data; //the original json data\n        g.attr(\"class\", \"j-point\");\n        g.append(\"circle\")\n            .attr(\"cx\", o.p.x)\n            .attr(\"cy\", o.p.y)\n            .attr(\"r\", 4 / scale);\n    }\n\n    drawLine(g, o) {\n        if ( this.lineVisible() )\n            g.append(\"line\")\n                .attr(\"x1\", this.line.p1.x)\n                .attr(\"y1\", this.line.p1.y)\n                .attr(\"x2\", this.line.p2.x)\n                .attr(\"y2\", this.line.p2.y)\n                .attr(\"stroke-width\", 1 / scale)\n                .attr(\"stroke\", this.getColor() );\n    }\n\n    getColor() {\n        return this.data.color;\n    }\n\n    lineVisible() {\n        return this.data.lineStyle !== \"none\";\n    }\n\n    pointEndLine(data) {\n        data.objectType = \"pointEndLine\";\n        data.basePoint = this;\n        return this.patternPiece.add(data);\n    }\n\n    pointAlongLine(data) {\n        data.objectType = \"pointAlongLine\";\n        data.firstPoint = this;\n        return this.patternPiece.add(data);\n    }\n\n    lineTo(data) {\n        data.objectType = \"line\";\n        data.firstPoint = this;\n        return this.patternPiece.add(data);\n    }\n\n    pointLineIntersect(data) {\n        data.objectType = \"pointLineIntersect\";\n        data.p1Line1 = this;\n        return this.patternPiece.add(data);\n    }\n}\n","//define(function (require) {\n//    require('./DrawingObject');\n//    require('../geometry');\n//});\n\nclass ArcSimple extends DrawingObject {\n\n    //center\n    //angle1\n    //angle2\n    //radius \n\n    constructor(data) {\n        super(data);\n\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = data.derivedName;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.center === \"undefined\")\n            this.center = this.patternPiece.getObject(d.center);\n        if (typeof this.angle1 === \"undefined\")\n            this.angle1 = this.patternPiece.newFormula(d.angle1);\n        if (typeof this.angle2 === \"undefined\")\n            this.angle2 = this.patternPiece.newFormula(d.angle2);\n        if (typeof this.radius === \"undefined\")\n            this.radius = this.patternPiece.newFormula(d.radius);\n\n        this.arc = new GeoArc( this.center.p, this.radius.value(), this.angle1.value(), this.angle2.value() );\n\n        this.p = this.arc.pointAlongPathFraction( 0.5 );\n        bounds.adjust( this.p );\n        bounds.adjust( this.arc.pointAlongPathFraction( 0 ) );\n        bounds.adjust( this.arc.pointAlongPathFraction( 1 ) );\n        /*\n        var arcData = this.arc.centeredToSVG( this.center.p.x, this.center.p.y, \n            this.radius.value(), this.radius.value(), \n            -this.angle1.value(), -(this.angle1.value() + this.angle2.value()) /2, 0 ); \n\n        this.p = new GeoPoint( arcData.x1, arcData.y1 );\n\n        //This bound setting is inaccurate. Really we should look at the bounds set\n        //by the start and end points, and by the intersection of the x and y axis with the curve\n        //(which may be multiple)\n        let east  = this.center.p.pointAtDistanceAndAngle( this.radius.value(), 0   *Math.PI / 180);\n        let north = this.center.p.pointAtDistanceAndAngle( this.radius.value(), 90  *Math.PI / 180);\n        let west  = this.center.p.pointAtDistanceAndAngle( this.radius.value(), 180 *Math.PI / 180);\n        let south = this.center.p.pointAtDistanceAndAngle( this.radius.value(), 270 *Math.PI / 180);\n\n        bounds.adjust( east );\n        bounds.adjust( north );\n        bounds.adjust( west );\n        bounds.adjust( south );\n        */\n    }\n\n\n    pointAlongPath( length )\n    {\n        return this.arc.pointAlongPath( length );\n    }\n    \n\n    asShapeInfo()\n    {\n        return this.arc.asShapeInfo();\n    }\n\n\n    draw(g) {\n        var d = this.data;\n        var arcPath = d3.path();\n        var a2 = this.angle2.value();\n        if ( a2 < this.angle1.value() )\n            a2 += 360;\n        arcPath.arc( this.center.p.x, this.center.p.y, \n                     this.radius.value(), \n                     -this.angle1.value() * Math.PI / 180, -a2 * Math.PI / 180, true );\n        \n        console.log( \"ArcSimple d3 path \", arcPath );\n\n        g.append(\"path\")\n              .attr(\"d\", arcPath )\n              .attr(\"fill\", \"none\")\n              .attr(\"stroke-width\", 1 / scale)\n              .attr(\"stroke\", this.getColor() );\n\n        //Where should we draw the label? half way along the arc?\n        //this.drawDot(g, this);\n        this.drawLabel(g, this);\n    }\n\n\n    html() {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: arc with center ' + this.data.center + \" radius \" + this.data.radius.html() + \" from angle \" + this.data.angle1.html() + \" to \" + this.data.angle2.html();\n    }\n\n    \n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.center );\n        dependencies.add( this, this.angle1 );\n        dependencies.add( this, this.angle2 );\n        dependencies.add( this, this.radius );\n    }    \n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass CutSpline extends DrawingObject { //TODO for consistency should be PointCutSpline ???\n\n    //curve\n    //length\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.curve === \"undefined\")\n            this.curve = this.patternPiece.getObject(d.spline);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n\n        this.p = this.curve.pointAlongPath( this.length.value() );\n        \n        bounds.adjust(this.p);\n    }\n\n    draw(g) {\n        //this.drawLine( g, this );\n        this.drawDot( g, this );\n        this.drawLabel( g, this );\n    }\n\n\n    html() {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' + this.data.length.html() + \" along curve \" + this.curve.data.name;\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.curve );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","//(c) Copyright 2019 Jason Dore\n//Inspired by the excellent seamly2D/Valentina (XXX ref) developed by Roman/Susan etc.\n//this is a ground up implementation in Javascript intended to be compatible with, but\n//not based on, the seamly2D/Valentina pattern making systen in order to support community\n//pattern sharing website. \n\n//var Point2D = require('kld-affine/Point2D');\n/*\ndefine(function (require) {\n    require('../expression');\n    require('./DrawingObject');\n    require('./ArcSimple');\n    require('./Line');\n    require('./PointAlongLine');\n    require('./PointAlongPerpendicular');\n    require('./PointAlongBisector');\n    require('./PointIntersectLineAndAxis');    \n    require('./PointIntersectArcAndAxis');\n    require('./PointIntersectArcAndLine');\n    require('./PointEndLine');\n    require('./PointLineIntersect');\n    require('./PointSingle');\n    require('./PointFromXandYOfTwoOtherPoints');   \n    require('./PerpendicularPointAlongLine');        \n    require('./PointOfTriangle'); \n    require('./PointShoulder'); \n    require('./SplineSimple');    \n    require('./SplineUsingControlPoints');    \n    require('./SplinePathInteractive');        \n    require('./SplinePathUsingPoints');            \n    require('./CutSpline');    \n    require('./PointCutSplinePath');    \n    require('./PointCutArc');        \n    require('./PointIntersectCurves');        \n    require('./PointIntersectCurveAndAxis');        \n    require('./PointIntersectArcs');            \n    require('./PointIntersectCircles');            \n});*/\n\n\nvar scale;\n\n\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass Line extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.firstPoint);\n            \n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.secondPoint);\n\n        this.line = new GeoLine(this.firstPoint.p, this.secondPoint.p);\n        bounds.adjustForLine(this.line);\n    }\n\n\n    draw(g) {\n        var d = this.data;\n        this.drawLine( g, this );\n        \n        //TODO we could display the derived name Line_A1_A2 at the mid-point along the line?       \n\n        //TODO for all lines we could draw a thicker invisible line do make it easier to click on the line.\n    }\n\n\n    html() {\n        return 'line ' + '<span class=\"ps-name\">' + this.firstPoint.data.name + '</span>' + \" - \" + '<span class=\"ps-name\">' + this.secondPoint.data.name + '</span>';\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n    }    \n}\n","\n\nclass OperationFlipByAxis extends DrawingObject {\n\n    //operationName\n    //suffix\n    //center\n    //axis\n\n    constructor(data) {\n        super(data);\n        this.data.name = data.operationName;\n        this.axis = data.axis;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.center === \"undefined\")\n            this.center = this.patternPiece.getObject(d.center);\n    }\n\n\n    draw(g) {\n        //g is the svg group\n        //this.drawLine( g, this ); //TODO put an arrow head on this!\n        //this.drawDot( g, this );\n        //this.drawLabel( g, this );\n    }\n\n\n    html() {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: Flip operation: axis:' + this.axis + \n                        \" around \" + this.center.data.name +\n                         //\" angle:\" + this.data.angle.value() +\n                         \" suffix:\" + this.data.suffix;\n    }\n\n\n    applyOperationToPoint( source )\n    {\n        var result = new GeoPoint( source.p.x, source.p.y );\n\n        if (    ( this.axis === \"Vertical\" ) \n             || ( this.axis === \"vertical\" )) //just in case.\n            result.x = this.center.p.y - ( source.p.x - this.center.p.x );\n        else\n            result.y = this.center.p.y - ( source.p.y - this.center.p.y );\n\n        console.log(\"Axis:\" + this.axis );\n        console.log( \"Center y \" + this.center.p.y );\n        console.log( \"Source y \" + source.p.y );\n        console.log( \"Result y \" + result.y );\n\n        return result;\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.center );\n    }    \n\n}\n","\n\nclass OperationMove extends DrawingObject {\n\n    //operationName\n    //suffix\n    //angle\n    //length\n\n    constructor(data) {\n        super(data);\n        this.data.name = data.operationName;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        //if (typeof this.basePoint === \"undefined\")\n        //    this.basePoint = this.patternPiece.getObject(d.basePoint);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n            \n        if (typeof this.angle === \"undefined\")\n            this.angle = this.patternPiece.newFormula(d.angle);\n            \n        //Convert degrees to radians\n        //this.p = this.basePoint.p.pointAtDistanceAndAngle(this.length.value(), Math.PI * 2 * this.angle.value() / 360);\n        //this.line = new GeoLine(this.basePoint.p, this.p);\n        //bounds.adjustForLine(this.line);\n    }\n\n\n    draw(g) {\n        //g is the svg group\n        //this.drawLine( g, this ); //TODO put an arrow head on this!\n        //this.drawDot( g, this );\n        //this.drawLabel( g, this );\n    }\n\n\n    html() {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: Move operation: ' + this.data.length.value() + \n                        //\" from \" + this.basePoint.data.name +\n                         \" angle:\" + this.data.angle.value() +\n                         \" suffix:\" + this.data.suffix;\n    }\n\n\n    applyOperationToPoint( source )\n    {\n        //Convert degrees to radians\n        var result = source.p.pointAtDistanceAndAngle(this.length.value(), Math.PI * 2 * this.angle.value() / 360);\n        //var line = new GeoLine( source.p, result.p );\n        return result;\n    }\n\n\n    setDependencies( dependencies )\n    {\n        //dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.length );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","\n\nclass OperationResult extends DrawingObject {\n\n    //basePoint\n    //fromOperation\n\n    constructor(data) {\n        super(data);\n        this.data.name = data.derivedName;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.patternPiece.getObject(d.basePoint);\n\n        if (typeof this.fromOperation === \"undefined\")\n            this.fromOperation = this.patternPiece.getObject(d.fromOperation);\n\n        //Convert degrees to radians\n        this.p = this.fromOperation.applyOperationToPoint( this.basePoint );\n        this.line = new GeoLine(this.basePoint.p, this.p);\n        bounds.adjust( this.p );\n    }\n\n\n    draw(g) {\n        //g is the svg group\n        this.drawLine( g, this ); //TODO put an arrow head on this!\n        this.drawDot( g, this );\n        this.drawLabel( g, this );\n    }\n\n\n    html() {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: Operation result: ';\n         //+ this.data.length.value() + \n           //             \" from \" + this.basePoint.data.name +\n             //            \" angle:\" + this.data.angle.value() +\n               //          \" suffix:\" + this.data.suffix;\n    }\n\n\n    applyOperationToPoint( source )\n    {\n        //Convert degrees to radians\n        var result = source.p.pointAtDistanceAndAngle(this.length.value(), Math.PI * 2 * this.angle.value() / 360);\n        //var line = new GeoLine( source.p, result.p );\n        return result;\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.fromOperation );\n    }    \n\n}\n","\n\nclass OperationRotate extends DrawingObject {\n\n    //operationName\n    //suffix\n    //angle\n    //center\n\n    constructor(data) {\n        super(data);\n        this.data.name = data.operationName;\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.center === \"undefined\")\n            this.center = this.patternPiece.getObject(d.center);\n            \n        if (typeof this.angle === \"undefined\")\n            this.angle = this.patternPiece.newFormula(d.angle);            \n    }\n\n\n    draw(g) {\n        //g is the svg group\n        //this.drawLine( g, this ); //TODO put an arrow head on this!\n        //this.drawDot( g, this );\n        //this.drawLabel( g, this );\n    }\n\n\n    html() {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: Move rotate: ' +\n                         \" center: \" + this.center.data.name +\n                         \" angle:\" + this.data.angle.value() +\n                         \" suffix:\" + this.data.suffix;\n    }\n\n\n    applyOperationToPoint( source )\n    {\n        //Convert degrees to radians\n        \n        var centerToSourceLine = new GeoLine( this.center.p, source.p );\n        var distance = centerToSourceLine.getLength();\n        var angle =  ( Math.PI * 2 * ( centerToSourceLine.angleDeg() + this.angle.value() ) / 360 );\n\n        var result = this.center.p.pointAtDistanceAndAngle( distance, angle );\n        //var line = new GeoLine( source.p, result.p );\n        return result;\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.center );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass PerpendicularPointAlongLine extends DrawingObject {\n\n    //basePoint\n    //firstPoint\n    //secondPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.patternPiece.getObject(d.basePoint);\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.p1Line1);\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.p2Line1);\n\n        var line = new GeoLine(this.firstPoint.p, this.secondPoint.p);\n        \n        var baseLine = new GeoLine( this.basePoint.p, this.basePoint.p.pointAtDistanceAndAngle( 1, (line.angleDeg() + 90 )/360*Math.PI*2 ) );\n\n        this.p = line.intersect(baseLine);\n        this.line = new GeoLine( this.basePoint.p, this.p );\n\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g) {\n        //g is the svg group\n        this.drawLine( g, this );\n        this.drawDot( g, this );\n        this.drawLabel( g, this );\n    }\n\n\n    html() {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ';// + this.data.length.value() + \" from \" + this.firstPoint.data.name + \" perpendicular to the line to \" + this.secondPoint.data.name + \" additional angle:\" + this.data.angle.value();\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.basePoint );\n    }    \n\n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass PointAlongBisector extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n    //thirdPoint\n    //length\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.firstPoint);\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.secondPoint);\n        if (typeof this.thirdPoint === \"undefined\")\n            this.thirdPoint = this.patternPiece.getObject(d.thirdPoint);\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n            \n        var line1 = new GeoLine( this.secondPoint.p, this.firstPoint.p );    \n        var line2 = new GeoLine( this.secondPoint.p, this.thirdPoint.p );    \n\n        //TODO test what happens when this crosses the equator! i.e. one point is just below the equator and one just above (and in either direction)\n        var bisectingAngle = ( line1.angleDeg() + line2.angleDeg() ) /2;\n\n        //Convert degrees to radians\n        this.p = this.secondPoint.p.pointAtDistanceAndAngle( this.length.value(), Math.PI * 2 * bisectingAngle / 360 );\n        this.line = new GeoLine(this.secondPoint.p, this.p);\n        bounds.adjustForLine(this.line);\n    }\n\n\n    draw(g) {\n        //g is the svg group\n        this.drawLine( g, this );\n        this.drawDot( g, this );\n        this.drawLabel( g, this );\n    }\n\n\n    html() {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' + this.data.length.value() + \" along line bisecting \" \n             + this.secondPoint.data.name + \"-\" + this.firstPoint.data.name + \" and \" + this.secondPoint.data.name + \"-\" + this.thirdPoint.data.name;\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.thirdPoint );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass PointAlongLine extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n    //length\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.firstPoint);\n\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.secondPoint);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n\n        this.baseLine = new GeoLine(this.firstPoint.p, this.secondPoint.p);\n        this.p = this.firstPoint.p.pointAtDistanceAndAngle(this.length.value(this.baseLine.length), this.baseLine.angle);\n        this.line = new GeoLine(this.firstPoint.p, this.p);\n        \n        bounds.adjustForLine(this.line);\n    }\n\n    draw(g) {\n        this.drawLine( g, this );\n        this.drawDot( g, this );\n        this.drawLabel( g, this );\n    }\n\n\n    html() {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' + this.data.length.html() + \" along line from \" + this.firstPoint.data.name + \" to \" + this.secondPoint.data.name;\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass PointAlongPerpendicular extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n    //length\n    //angle\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.firstPoint);\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.secondPoint);\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n        if (typeof this.angle === \"undefined\")\n            this.angle = this.patternPiece.newFormula(d.angle);\n            \n        var baseLine = new GeoLine( this.firstPoint.p, this.secondPoint.p );    \n        var totalAngle = this.angle.value() + 90 + baseLine.angleDeg();\n        //Convert degrees to radians\n        this.p = this.firstPoint.p.pointAtDistanceAndAngle( this.length.value(), Math.PI * 2 * totalAngle / 360 );\n        this.line = new GeoLine(this.firstPoint.p, this.p);\n        bounds.adjustForLine(this.line);\n    }\n\n\n    draw(g) {\n        //g is the svg group\n        this.drawLine( g, this );\n        this.drawDot( g, this );\n        this.drawLabel( g, this );\n    }\n\n\n    html() {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' + this.data.length.value() + \" from \" + this.firstPoint.data.name + \" perpendicular to the line to \" + this.secondPoint.data.name + \" additional angle:\" + this.data.angle.value();\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.length );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass PointCutArc extends DrawingObject {\n\n    //arc\n    //length\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.arc === \"undefined\")\n            this.arc = this.patternPiece.getObject(d.arc);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n\n        this.p = this.arc.pointAlongPath( this.length.value() );\n        \n        bounds.adjust(this.p);\n    }\n\n    draw(g) {\n        this.drawDot( g, this );\n        this.drawLabel( g, this );\n    }\n\n\n    html() {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' + this.data.length.html() + \" along arc \" + this.arc.data.name;\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.arc );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass PointCutSplinePath extends DrawingObject {\n\n    //splinePath\n    //length\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.splinePath === \"undefined\")\n            this.splinePath = this.patternPiece.getObject(d.splinePath);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n\n        this.p = this.splinePath.pointAlongPath( this.length.value() );\n        \n        bounds.adjust(this.p);\n    }\n\n    draw(g) {\n        this.drawDot( g, this );\n        this.drawLabel( g, this );\n    }\n\n\n    html() {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' + this.data.length.html() + \" along path \" + this.splinePath.data.name;\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.splinePath );\n        dependencies.add( this, this.length );\n    }    \n\n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass PointEndLine extends DrawingObject {\n\n    //basePoint\n    //length\n    //angle\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.patternPiece.getObject(d.basePoint);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n            \n        if (typeof this.angle === \"undefined\")\n            this.angle = this.patternPiece.newFormula(d.angle);\n            \n        //Convert degrees to radians\n        this.p = this.basePoint.p.pointAtDistanceAndAngle(this.length.value(), Math.PI * 2 * this.angle.value() / 360);\n        this.line = new GeoLine(this.basePoint.p, this.p);\n        bounds.adjustForLine(this.line);\n    }\n\n\n    draw(g) {\n        //g is the svg group\n        this.drawLine( g, this );\n        this.drawDot( g, this );\n        this.drawLabel( g, this );\n    }\n\n\n    html() {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' + this.data.length.value() + \" from \" + this.basePoint.data.name + \" angle:\" + this.data.angle.value();\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.length );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass PointFromXandYOfTwoOtherPoints extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.firstPoint);\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.secondPoint);\n\n        this.p = new GeoPoint( this.firstPoint.p.x, this.secondPoint.p.y );\n        //this.line = new GeoLine(this.firstPoint.p, this.secondPoint.p);\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g) {\n        //TODO check that there is no option to draw a line as part of this tool. \n        this.drawDot( g, this );\n        this.drawLabel( g, this );\n    }\n\n\n    html() {\n        return 'line ' + '<span class=\"ps-name\">' + this.firstPoint.data.name + '</span>' + \" - \" + '<span class=\"ps-name\">' + this.secondPoint.data.name + '</span>';\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n    }    \n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\n\nclass PointIntersectArcAndAxis extends DrawingObject {\n\n    //arc (provided as \"curve\"), and may be an arc or a spline (ob observation)\n    //basePoint\n    //angle\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.patternPiece.getObject(d.basePoint);\n\n        if (typeof this.arc === \"undefined\")\n            this.arc = this.patternPiece.getObject(d.curve); //An anomaly, would be better if this were arc.\n\n        if (typeof this.angle === \"undefined\")\n            this.angle = this.patternPiece.newFormula(d.angle);\n\n            //TODO replace 1000 with a calculation of the longest line that may be needed\n        let otherPoint = this.basePoint.p.pointAtDistanceAndAngle( 1000/*infinite*/, Math.PI * this.angle.value() / 180 );\n\n        var longLine = new GeoLine( this.basePoint.p, otherPoint );\n\n        if ( this.arc.arc )\n            this.p = longLine.intersectArc( this.arc.arc );\n        else\n            this.p = longLine.intersectArc( this.arc.curve );\n\n        this.line = new GeoLine( this.basePoint.p, this.p );\n\n        bounds.adjust(this.p);\n    }\n\n    draw(g) {\n        //g is the svg group\n        this.drawLine(g, this);\n        this.drawDot(g, this);\n        this.drawLabel(g, this);\n    }\n\n\n    html() {\n        //TODO use a better name for this.curve, e.g. Arc_A_nn\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: intersect arc ' + this.arc.data.derivedName + \" with line from \" + this.basePoint.data.name + \" at angle \" + this.angle.value();\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.arc );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\n\nclass PointIntersectArcAndLine extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n    //center\n    //radius\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.firstPoint);\n            \n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.secondPoint);\n\n        if (typeof this.center === \"undefined\")\n            this.center = this.patternPiece.getObject(d.center);\n\n        if (typeof this.radius === \"undefined\")\n            this.radius = this.patternPiece.newFormula(d.radius);\n\n        var line = new GeoLine( this.firstPoint.p, this.secondPoint.p );\n        var arc  = new GeoArc( this.center.p, this.radius.value(), 0, 2*Math.PI );\n\n        this.p = line.intersectArc( arc );\n\n        bounds.adjust(this.p);\n    }\n\n    draw(g) {\n\n        //TODO draw the line between basePoint and p\n\n        //g is the svg group\n        var d = this.data; //the original json data\n        this.drawDot(g, this);\n        this.drawLabel(g, this);\n    }\n\n\n    html() {\n        //TODO use a better name for this.arc, e.g. Arc_A_nn\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: intersect arc with center ' + this.center.data.name + \", radius \" + this.radius.value() +  \" with line \" + this.firstPoint.data.name + \"-\" + this.secondPoint.data.name;\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.center );\n        dependencies.add( this, this.radius );\n    }    \n\n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\n\nclass PointIntersectArcs extends DrawingObject {\n\n    //firstArc\n    //secondArc\n    //crossPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstArc === \"undefined\")\n            this.firstArc = this.patternPiece.getObject(d.firstArc);\n            \n        if (typeof this.secondArc === \"undefined\")\n            this.secondArc = this.patternPiece.getObject(d.secondArc);\n\n        //Also this.data.crossPoint    \n\n        var arc1SI = this.firstArc.asShapeInfo();\n        var arc2SI = this.secondArc.asShapeInfo();\n\n        var intersections = Intersection.intersect(arc1SI, arc2SI);\n        \n        intersections.points.forEach(console.log);    \n        \n        if ( intersections.points.length === 1 )\n        {\n            this.p = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n        }\n        else\n        {\n            //TODO A5 in the test should be (0,0) as the point of intersection is not during the specified angle of the arcs.\n            //For each intersection point\n            //TODO check that GeoLine( this.firstArc.center.p, p1)).angleDeg() between this.firstArc.arc.angle1 and this.firstArc.arc.angle2\n            //and similar for secondArc\n\n            //What is the angle in the first arc of the intersection point?\n            //One = smallest angle in the first arc.\n            //Two = largest angle in the first arc.\n            var p1 = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n            var p2 = new GeoPoint( intersections.points[1].x, intersections.points[1].y );\n            var angle1 = (new GeoLine( this.firstArc.center.p, p1)).angle;\n            var angle2 = (new GeoLine( this.firstArc.center.p, p2)).angle;\n\n            if ( this.data.crossPoint === \"One\" )\n            {\n                if ( angle1 < angle2 )\n                    this.p = p1;\n                else\n                    this.p = p2;\n            }            \n            else \n            {\n                if ( angle1 < angle2 )\n                    this.p = p2;\n                else\n                    this.p = p1;\n            }\n        }\n\n        bounds.adjust(this.p);\n    }\n\n    draw(g) {\n        //g is the svg group\n        var d = this.data; //the original json data\n        this.drawDot(g, this);\n        this.drawLabel(g, this);\n    }\n\n\n    html() {\n        //TODO use a better name for this.arc, e.g. Arc_A_nn\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: intersect arcs ' + this.firstArc.data.name + \" and \" + this.secondArc.data.name\n           + ( this.data.crossPoint === \"One\" ? \"\" : \" - second point\");\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.firstArc );\n        dependencies.add( this, this.secondArc );\n    }    \n\n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\n\nclass PointIntersectCircles extends DrawingObject {\n\n    //center1     ??? Confirm\n    //radiu1   ??? Confirm\n    //center2   ??? Confirm\n    //radius2  ??? Confirm\n    //crossPoint    ??? Confirm\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.center1 === \"undefined\")\n            this.center1 = this.patternPiece.getObject(d.center1);\n            \n        if (typeof this.center2 === \"undefined\")\n            this.center2 = this.patternPiece.getObject(d.center2);\n\n        if (typeof this.radius1 === \"undefined\")\n            this.radius1 = this.patternPiece.newFormula(d.radius1);\n\n        if (typeof this.radius2 === \"undefined\")\n            this.radius2 = this.patternPiece.newFormula(d.radius2);\n\n        //Also this.data.crossPoint    \n        var circle1 = new GeoArc( this.center1.p, this.radius1.value(), 0, 2*Math.PI );\n        var circle2 = new GeoArc( this.center2.p, this.radius2.value(), 0, 2*Math.PI );\n\n        var arc1SI = circle1.asShapeInfo();\n        var arc2SI = circle2.asShapeInfo();\n\n        var intersections = Intersection.intersect(arc1SI, arc2SI);\n        \n        intersections.points.forEach(console.log);    \n        \n        if ( intersections.points.length === 0 )\n        {\n            this.p = new GeoPoint(0,0);\n        }\n        else if ( intersections.points.length === 1 )\n        {\n            this.p = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n        }\n        else\n        {\n            //NB: this is a subset of the logic that applies to PointIntersectArcs.\n            //What is the angle in the first arc of the intersection point?\n            //One = smallest angle in the first arc.\n            //Two = largest angle in the first arc.\n            var p1 = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n            var p2 = new GeoPoint( intersections.points[1].x, intersections.points[1].y );\n            var angle1 = (new GeoLine( circle1.center, p1)).angle;\n            var angle2 = (new GeoLine( circle1.center, p2)).angle;\n\n            if ( this.data.crossPoint === \"One\" )\n            {\n                if ( angle1 < angle2 )\n                    this.p = p1;\n                else\n                    this.p = p2;\n            }            \n            else \n            {\n                if ( angle1 < angle2 )\n                    this.p = p2;\n                else\n                    this.p = p1;\n            }\n        }\n\n        bounds.adjust(this.p);\n    }\n\n    draw(g) {\n        //g is the svg group\n        var d = this.data; //the original json data\n        this.drawDot(g, this);\n        this.drawLabel(g, this);\n    }\n\n\n    html() {\n        //TODO use a better name for this.arc, e.g. Arc_A_nn\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: intersect circles ' + this.center1.data.name + \" radius \" + this.radius1.html() \n                + \" and \" + this.center2.data.name + \" radius \" + this.radius2.html()\n           + ( this.data.crossPoint === \"One\" ? \"\" : \" - second point\");\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.center1 );\n        dependencies.add( this, this.center2 );\n        dependencies.add( this, this.radius1 );\n        dependencies.add( this, this.radius2 );\n    }    \n\n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\n\nclass PointIntersectCurveAndAxis extends DrawingObject {\n\n    //basePoint\n    //curve\n    //angle\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.patternPiece.getObject(d.basePoint);\n\n        if (typeof this.curve === \"undefined\")\n            this.curve = this.patternPiece.getObject(d.curve);\n\n        if (typeof this.angle === \"undefined\")\n            this.angle = this.patternPiece.newFormula(d.angle);\n\n        let otherPoint = this.basePoint.p.pointAtDistanceAndAngle( 1000/*infinite TODO*/, Math.PI * this.angle.value() / 180 );\n\n        var line = new GeoLine( this.basePoint.p, otherPoint );\n\n        var lineSI = line.asShapeInfo();\n        var curveSI = this.curve.asShapeInfo();\n\n        var intersections = Intersection.intersect(lineSI, curveSI);        \n        intersections.points.forEach(console.log);    \n        this.p = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n        this.line = new GeoLine( this.basePoint.p, this.p );\n        bounds.adjust(this.p);\n    }\n\n    draw(g) {\n        //g is the svg group\n        this.drawLine(g, this); \n        this.drawDot(g, this);\n        this.drawLabel(g, this);\n    }\n\n\n    html() {\n        //TODO use a better name for this.curve, e.g. Arc_A_nn\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: intersect curve ' + this.curve.data.name + \" with line from \" + this.basePoint.data.name + \" at angle \" + this.angle.value();\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.curve );\n        dependencies.add( this, this.angle );\n    }    \n\n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\n\nclass PointIntersectCurves extends DrawingObject {\n\n    //curve1\n    //curve2\n    //verticalCrossPoint\n    //horizontalCrossPoint\n\n    constructor(data) {\n        super(data);\n    }\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.curve1 === \"undefined\")\n            this.curve1 = this.patternPiece.getObject(d.curve1);\n            \n        if (typeof this.curve2 === \"undefined\")\n            this.curve2 = this.patternPiece.getObject(d.curve2);\n\n        var curve1SI = this.curve1.asShapeInfo();\n        var curve2SI = this.curve2.asShapeInfo();\n\n        var intersections = Intersection.intersect(curve1SI, curve2SI);\n        \n        intersections.points.forEach(console.log);    \n        if ( intersections.points.length === 1 )\n            this.p = new GeoPoint( intersections.points[0].x, intersections.points[0].y );\n        else if ( intersections.points.length > 1 )    \n        {\n            //Vertical correction has first dibs. verticalCrossPoint==\"One\" means highest point; horizontalCrossPoint==\"One\" means leftmost point\n            var minXPnt, maxXPnt, minYPnt, maxYPnt;\n            for ( var i = 0; i<intersections.points.length; i++ )\n            {\n                var intersect = intersections.points[i];\n                if (( ! minXPnt ) || ( intersect.x < minXPnt.x ))\n                    minXPnt = intersect;\n                if (( ! maxXPnt ) || ( intersect.x > maxXPnt.x ))\n                    maxXPnt = intersect;\n                if (( ! minYPnt ) || ( intersect.y < minYPnt.y ))\n                    minYPnt = intersect;\n                if (( ! maxYPnt ) || ( intersect.y > maxYPnt.y ))\n                    maxYPnt = intersect;\n            }\n            if ( minYPnt !== maxYPnt )\n            {\n                if ( this.data.verticalCrossPoint === \"One\" )\n                    this.p = minYPnt;\n                else\n                    this.p = maxYPnt;\n            }\n            else\n            {\n                if ( this.data.horizontalCrossPoint === \"One\" )\n                    this.p = minXPnt;\n                else\n                    this.p = maxXPnt;\n            }\n        }\n\n        bounds.adjust(this.p);\n    }\n\n    draw(g) {\n\n        //TODO draw the line between basePoint and p\n\n        //g is the svg group\n        var d = this.data; //the original json data\n        this.drawDot(g, this);\n        this.drawLabel(g, this);\n    }\n\n\n    html() {\n        //TODO use a better name for this.curve, e.g. Arc_A_nn\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: intersect curve ' + this.curve1.data.name + \" with \" + this.curve2.data.name;\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.curve1 );\n        dependencies.add( this, this.curve2 );\n    }    \n\n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass PointIntersectLineAndAxis extends DrawingObject {\n\n    //basePoint\n    //p1Line1\n    //p2Line1\n    //angle\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.basePoint === \"undefined\")\n            this.basePoint = this.patternPiece.getObject(d.basePoint);\n\n        if (typeof this.p1Line1 === \"undefined\")\n            this.p1Line1 = this.patternPiece.getObject(d.p1Line1);\n\n        if (typeof this.p2Line1 === \"undefined\")\n            this.p2Line1 = this.patternPiece.getObject(d.p2Line1);\n\n        if (typeof this.angle === \"undefined\")\n            this.angle = this.patternPiece.newFormula(d.angle);\n\n\n        var line1 = new GeoLine(this.p1Line1.p, this.p2Line1.p);\n\n        var otherPoint = this.basePoint.p.pointAtDistanceAndAngle( 1, Math.PI * 2 * this.angle.value() / 360 );\n\n        var line2 = new GeoLine(this.basePoint.p, otherPoint );\n\n        this.p = line1.intersect(line2);\n        this.line = new GeoLine( this.basePoint.p, this.p );\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g) {\n        //g is the svg group\n        this.drawLine( g, this );\n        this.drawDot( g, this );\n        this.drawLabel( g, this );\n    }\n\n\n    html() {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: intersection of ' + this.p1Line1.data.name + \"-\" + this.p2Line1.data.name + \" with line from \" + this.basePoint.data.name + \" at angle \" + this.angle.html();\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.p1Line1 );\n        dependencies.add( this, this.p2Line1 );\n        dependencies.add( this, this.basePoint );\n        dependencies.add( this, this.angle );\n    }    \n\n\n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass PointLineIntersect extends DrawingObject {\n\n    //p1Line1\n    //p2Line1\n    //p1Line2\n    //p2Line2\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.p1Line1 === \"undefined\")\n            this.p1Line1 = this.patternPiece.getObject(d.p1Line1);\n        if (typeof this.p2Line1 === \"undefined\")\n            this.p2Line1 = this.patternPiece.getObject(d.p2Line1);\n        if (typeof this.p1Line2 === \"undefined\")\n            this.p1Line2 = this.patternPiece.getObject(d.p1Line2);\n        if (typeof this.p2Line2 === \"undefined\")\n            this.p2Line2 = this.patternPiece.getObject(d.p2Line2);\n\n        this.line1 = new GeoLine(this.p1Line1.p, this.p2Line1.p);\n        this.line2 = new GeoLine(this.p1Line2.p, this.p2Line2.p);\n        this.p = this.line1.intersect(this.line2);\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g) {\n        //g is the svg group\n        var d = this.data; //the original json data\n        this.drawDot(g, this);\n        this.drawLabel(g, this);\n    }\n\n\n    html() {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: intersect ' + this.p1Line1.data.name + \"-\" + this.p2Line1.data.name + \" with \" + this.p1Line2.data.name + \"-\" + this.p2Line2.data.name;\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.p1Line1 );\n        dependencies.add( this, this.p1Line2 );\n        dependencies.add( this, this.p2Line1 );\n        dependencies.add( this, this.p2Line2 );\n    }    \n\n\n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass PointOfTriangle extends DrawingObject {\n\n    //firstPoint\n    //secondPoint\n    //p1Line1\n    //p2Line1\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.firstPoint === \"undefined\")\n            this.firstPoint = this.patternPiece.getObject(d.firstPoint);\n        if (typeof this.secondPoint === \"undefined\")\n            this.secondPoint = this.patternPiece.getObject(d.secondPoint);\n\n        if (typeof this.p1Line1 === \"undefined\")\n            this.p1Line1 = this.patternPiece.getObject(d.p1Line1);\n        if (typeof this.p2Line1 === \"undefined\")\n            this.p2Line1 = this.patternPiece.getObject(d.p2Line1);\n\n            \n        var axisLine = new GeoLine( this.p1Line1.p, this.p2Line1.p );    \n        var otherLine = new GeoLine( this.firstPoint.p, this.secondPoint.p );\n\n        //Now we work out another point along the axis line that forms the right angle triangle \n        //with the otherLine.\n        //\n        //The trick here is to observe that all these points, for any axisLine will form an arc\n        //centered on the midpoint of otherLine with radiu of half length of otherLine\n        var intersectionPoint = axisLine.intersect( otherLine );\n        var midpoint = this.firstPoint.p.pointAtDistanceAndAngle( otherLine.length/2, otherLine.angle );\n        var arc = new GeoArc( midpoint, otherLine.length/2, 0, 2*Math.PI  );    \n        var extendedAxis = new GeoLine( intersectionPoint, intersectionPoint.pointAtDistanceAndAngle( otherLine.length*2, axisLine.angle ) );\n        this.p = extendedAxis.intersectArc( arc );\n\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g) {\n        //g is the svg group\n        //this.drawLine( g, this );\n        this.drawDot( g, this );\n        this.drawLabel( g, this );\n    }\n\n\n    html() {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' + \" Point along \" + this.p1Line1.data.name + \"-\" + this.p2Line1.data.name + \" that forms a right angle triangle with line  \" + this.firstPoint.data.name + \"-\" + this.secondPoint.data.name ;\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.firstPoint );\n        dependencies.add( this, this.secondPoint );\n        dependencies.add( this, this.p1Line1 );\n        dependencies.add( this, this.p2Line1 );\n    }    \n\n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass PointShoulder extends DrawingObject {\n\n    //pShoulder\n    //p1Line1\n    //p2Line1\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.shoulderPoint === \"undefined\")\n            this.shoulderPoint = this.patternPiece.getObject(d.shoulderPoint);\n\n        if (typeof this.p1Line1 === \"undefined\")\n            this.p1Line1 = this.patternPiece.getObject(d.p1Line1);\n\n        if (typeof this.p2Line1 === \"undefined\")\n            this.p2Line1 = this.patternPiece.getObject(d.p2Line1);\n\n        if (typeof this.length === \"undefined\")\n            this.length = this.patternPiece.newFormula(d.length);\n\n        //Find the point that is length away from the shoulderPoint along\n        //the line p1Line1-p2line1.\n            \n        var axisLine = new GeoLine( this.p1Line1.p, this.p2Line1.p );    \n        var arc = new GeoArc( this.shoulderPoint.p, this.length.value(), 0, 2*Math.PI  );      \n        var offset = new GeoLine( this.shoulderPoint.p, this.p1Line1.p );\n        var extendedAxisLength = this.length.value() + offset.length;\n        var extendedAxis = new GeoLine( this.p1Line1.p, this.p1Line1.p.pointAtDistanceAndAngle( 100, axisLine.angle ) );\n        this.p = extendedAxis.intersectArc( arc );\n        this.line = new GeoLine( this.p1Line1.p, this.p );\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g) {\n        //g is the svg group\n        this.drawLine( g, this );\n        this.drawDot( g, this );\n        this.drawLabel( g, this );\n    }\n\n\n    html() {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: ' + \" Point along \" + this.p1Line1.data.name + \"-\" + this.p2Line1.data.name + \" being \" + this.length.html() + \" from \" + this.shoulderPoint.data.name;\n    }\n\n\n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.shoulderPoint );\n        dependencies.add( this, this.p1Line1 );\n        dependencies.add( this, this.p2Line1 );\n    }    \n\n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\n\nclass PointSingle extends DrawingObject {\n\n    constructor(data) {\n        super(data);\n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n        this.p = new GeoPoint(d.x, d.y);\n        bounds.adjust(this.p);\n    }\n\n\n    draw(g) {\n        //g is the svg group\n        var d = this.data; //the original json data\n        this.drawDot(g, this);\n        this.drawLabel(g, this);\n    }\n\n\n    html() {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>:' + \" point at x:\" + this.data.x + \", y:\" + this.data.y + \" from origin\";\n    }\n\n\n    setDependencies( dependencies )\n    {\n    }    \n\n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass SplinePathInteractive extends DrawingObject {\n\n    constructor(data) {\n        super(data);\n\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = this.data.derivedName;        \n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if ( typeof this.nodes === \"undefined\" )\n        {\n            this.nodes = [];\n            for( var i=0; i< d.pathNode.length; i++ )\n            {\n                var pathNode = this.data.pathNode[i];\n\n                pathNode.point   = this.patternPiece.getObject( pathNode.point );\n                pathNode.angle1  = this.patternPiece.newFormula( pathNode.angle1 ); \n                pathNode.length1 = this.patternPiece.newFormula( pathNode.length1 ); \n                pathNode.angle2  = this.patternPiece.newFormula( pathNode.angle2 ); \n                pathNode.length2 = this.patternPiece.newFormula( pathNode.length2 );\n\n                this.nodes.push( { inAngle:   pathNode.angle1.value(),\n                                   inLength:  pathNode.length1.value(),\n                                   point:     pathNode.point.p,\n                                   outAngle:  pathNode.angle2.value(),\n                                   outLength: pathNode.length2.value() } );\n            }\n        }\n\n        this.curve = new GeoSpline( this.nodes );\n\n        this.midPoint = this.curve.pointAlongPathFraction( 0.5 );        \n        this.p = this.midPoint;\n        bounds.adjust( this.p );\n\n        //Bounds will already have been adjusted for each node\n    }\n\n    \n    asShapeInfo()\n    {\n        return this.curve.asShapeInfo();\n    }\n\n\n    draw(g) {\n        var d = this.data;\n        var p = g.append(\"path\")\n              .attr(\"d\", this.curve.svgPath() )\n              .attr(\"fill\", \"none\")\n              .attr(\"stroke-width\", 1 / scale)\n              .attr(\"stroke\", this.getColor() );\n\n        //Where should we draw the label? half way along the curve? \n        this.drawLabel(g, this);\n    }\n\n\n    pointAlongPath( length ) {\n        return this.curve.pointAlongPath( length );\n    }   \n\n\n    html() {\n        var html = '<span class=\"ps-name\">' + this.data.name + '</span>: curved path:';// from ' + this.startPoint.data.name + \" angle \" + this.angle1.value() + \" length \" + this.length1.value()\n            //+ \" to \" + this.endPoint.data.name + \" angle \" + this.angle2.value() + \" length \" + this.length2.html();\n\n        var d = this.data;\n        for( var i=0; i< d.pathNode.length; i++ )\n        {\n            if ( i>0 )\n                html+= \"; \";\n         \n            html += \"<br />\";    \n            html += d.pathNode[i].point.data.name + \" \" + \n                    d.pathNode[i].angle1.html() + \" \" + \n                    d.pathNode[i].length1.html() + \" \" + \n                    d.pathNode[i].angle2.html() + \" \" + \n                    d.pathNode[i].length2.html();\n        }\n\n        return html;\n    }\n\n    \n    setDependencies( dependencies )\n    {\n        for( var i=0; i< this.data.pathNode.length; i++ )\n        {\n            var pathNode = this.data.pathNode[i];\n            dependencies.add( this, pathNode.point );\n            dependencies.add( this, pathNode.angle1 );\n            dependencies.add( this, pathNode.angle2 );\n            dependencies.add( this, pathNode.length1 );\n            dependencies.add( this, pathNode.length2 );\n        }        \n    }    \n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass SplinePathUsingPoints extends DrawingObject {\n\n    constructor(data) {\n        super(data);\n\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = this.data.derivedName;        \n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if ( typeof this.nodes === \"undefined\" )\n        {\n            this.nodes = [];\n\n            for( var i=0; i< d.pathNode.length; i++ )\n            {\n                this.data.pathNode[i].point = this.patternPiece.getObject( this.data.pathNode[i].point );\n            }\n\n            for( var i=0; i< d.pathNode.length; i+=3 )\n            {\n                this.nodes.push( { \n                                   inControlPoint:   (i-1)>0 ? this.data.pathNode[i-1].point.p : undefined,\n                                   point:            this.data.pathNode[i].point.p,\n                                   outControlPoint:  (i+1) < this.data.pathNode.length ? this.data.pathNode[i+1].point.p : undefined,\n                                   } );\n            }\n        }\n\n        this.curve = new GeoSpline( this.nodes );\n\n        this.midPoint = this.curve.pointAlongPathFraction( 0.5 );        \n        this.p = this.midPoint;\n        bounds.adjust( this.p );\n\n        //Bounds will already have been adjusted for each node\n    }\n\n    \n    asShapeInfo()\n    {\n        return this.curve.asShapeInfo();\n    }\n\n\n    draw(g) {\n        var d = this.data;\n        var p = g.append(\"path\")\n              .attr(\"d\", this.curve.svgPath() )\n              .attr(\"fill\", \"none\")\n              .attr(\"stroke-width\", 1 / scale)\n              .attr(\"stroke\", this.getColor() );\n\n        //Where should we draw the label? half way along the curve? \n        this.drawLabel(g, this);\n    }\n\n\n    pointAlongPath( length ) {\n        return this.curve.pointAlongPath( length );\n    }   \n\n\n    html() {\n        var html = '<span class=\"ps-name\">' + this.data.name + '</span>: curved path: ';\n\n        var d = this.data;\n\n        for( var i=0; i< d.pathNode.length; i+=3 )\n        {\n            if ( (i-1)>0 )\n                html += '<span class=\"control-point\">' + this.data.pathNode[i-1].point.data.name + '</span> ';\n\n            html += d.pathNode[i].point.data.name + \" \";            \n\n            if ( (i+1) < this.data.pathNode.length )\n                html += '<span class=\"control-point\">' + this.data.pathNode[i+1].point.data.name + '</span> ';\n        }\n\n        return html;\n    }\n\n    \n    setDependencies( dependencies )\n    {\n        for( var i=0; i< this.data.pathNode.length; i++ )\n        {\n            dependencies.add( this, this.data.pathNode[i].point );\n        }        \n    }    \n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass SplineSimple extends DrawingObject {\n\n    //startPoint - the spline start\n    //endPoint - the spline end\n    //angle1\n    //angle2 \n    //length1\n    //length2\n\n    constructor(data) {\n        super(data);\n\n        //TODO output a useful spline ID\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = this.data.derivedName;        \n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.startPoint === \"undefined\")\n            this.startPoint = this.patternPiece.getObject(d.point1);\n\n        if (typeof this.endPoint === \"undefined\")\n            this.endPoint = this.patternPiece.getObject(d.point4);\n\n        if (typeof this.angle1 === \"undefined\")\n            this.angle1 = this.patternPiece.newFormula(d.angle1);\n\n        if (typeof this.angle2 === \"undefined\")\n            this.angle2 = this.patternPiece.newFormula(d.angle2);\n\n        if (typeof this.length1 === \"undefined\")\n            this.length1 = this.patternPiece.newFormula(d.length1);\n\n        if (typeof this.length2 === \"undefined\")\n            this.length2 = this.patternPiece.newFormula(d.length2);\n\n        this.curve = new GeoSpline( [ { inAngle: undefined, inLength: undefined, point: this.startPoint.p, outAngle: this.angle1.value(), outLength: this.length1.value() },\n                                       { inAngle: this.angle2.value(), inLength: this.length2.value(), point: this.endPoint.p, outAngle: undefined, outLength: undefined } ] );\n\n        this.midPoint = this.curve.pointAlongPathFraction( 0.5 );        \n        this.p = this.midPoint;\n\n        bounds.adjust( this.startPoint );\n        bounds.adjust( this.endPoint );\n        bounds.adjust( this.midPoint ); \n    }\n\n    \n    asShapeInfo()\n    {\n        return this.curve.asShapeInfo();\n    }\n\n\n    draw(g) {\n        var d = this.data;\n        var p = g.append(\"path\")\n              .attr(\"d\", this.curve.svgPath() )\n              .attr(\"fill\", \"none\")\n              .attr(\"stroke-width\", 1 / scale)\n              .attr(\"stroke\", this.getColor() );\n\n        //Where should we draw the label? half way along the curve?\n        //this.drawDot(g, this);\n        this.drawLabel(g, this);\n    }\n\n\n    pointAlongPath( length ) {\n        return this.curve.pointAlongPath( length );\n    }   \n\n\n    html() {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: spline from ' + this.startPoint.data.name + \" angle \" + this.angle1.value() + \" length \" + this.length1.value()\n            + \" to \" + this.endPoint.data.name + \" angle \" + this.angle2.value() + \" length \" + this.length2.html();\n    }\n\n    \n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.startPoint );\n        dependencies.add( this, this.endPoint );\n        dependencies.add( this, this.angle1 );\n        dependencies.add( this, this.angle2 );\n        dependencies.add( this, this.length1 );\n        dependencies.add( this, this.length2 );\n    }    \n}\n","/*define(function (require) {\n    require('./DrawingObject');\n    require('../geometry');\n});*/\n\nclass SplineUsingControlPoints extends DrawingObject {\n\n    //startPoint - the spline start\n    //startControlPoint\n    //endPoint - the spline end\n    //endControlPoint\n\n    constructor(data) {\n        super(data);\n\n        if ( typeof this.data.name === \"undefined\" )\n            this.data.name = this.data.derivedName;        \n    }\n\n\n    calculate(bounds) {\n        var d = this.data;\n\n        if (typeof this.startPoint === \"undefined\")\n            this.startPoint = this.patternPiece.getObject(d.point1);\n\n        if (typeof this.startControlPoint === \"undefined\")\n            this.startControlPoint = this.patternPiece.getObject(d.point2);\n\n        if (typeof this.endControlPoint === \"undefined\")\n            this.endControlPoint = this.patternPiece.getObject(d.point3);\n\n        if (typeof this.endPoint === \"undefined\")\n            this.endPoint = this.patternPiece.getObject(d.point4);\n\n        this.curve = new GeoSpline( [ { point: this.startPoint.p, outControlPoint: this.startControlPoint.p },\n                                      { inControlPoint: this.endControlPoint.p,  point: this.endPoint.p } ] );\n\n        this.midPoint = this.curve.pointAlongPathFraction( 0.5 );        \n        this.p = this.midPoint;\n\n        bounds.adjust( this.startPoint );\n        bounds.adjust( this.endPoint );\n        bounds.adjust( this.midPoint ); \n    }\n\n    \n    asShapeInfo()\n    {\n        return this.curve.asShapeInfo();\n    }\n\n\n    draw(g) {\n        var d = this.data;\n        var p = g.append(\"path\")\n              .attr(\"d\", this.curve.svgPath() )\n              .attr(\"fill\", \"none\")\n              .attr(\"stroke-width\", 1 / scale)\n              .attr(\"stroke\", this.getColor() );\n\n        //Where should we draw the label? half way along the curve?\n        //this.drawDot(g, this);\n        this.drawLabel(g, this);\n    }\n\n\n    pointAlongPath( length ) {\n        return this.curve.pointAlongPath( length );\n    }   \n\n\n    html() {\n        return '<span class=\"ps-name\">' + this.data.name + '</span>: spline from ' + this.startPoint.data.name + \" using control point \" + this.startControlPoint.data.name\n            + \" to \" + this.endPoint.data.name + \" using control point \" + this.endControlPoint.data.name;\n    }\n\n    \n    setDependencies( dependencies )\n    {\n        dependencies.add( this, this.startPoint );\n        dependencies.add( this, this.startControlPoint );\n        dependencies.add( this, this.endPoint );\n        dependencies.add( this, this.endControlPoint );\n    }    \n}\n","class Pattern {\n\n    constructor (data, options ) {\n        this.data = data;\n        this.options = options;\n        this.patternData = data.pattern;\n        this.increment = {};\n        this.measurement = {};\n\n        if ( typeof this.patternData.measurement !== \"undefined\" )\n        {\n            for (var a = 0; a < this.patternData.measurement.length; a++) {\n                var m = this.patternData.measurement[a];\n\n                //TODO test this increment that is a simple value...            \n                if (typeof m.value !== \"undefined\") \n                {\n                    m.constant = m.value;\n                    m.value = function () {\n                        return this.constant;\n                    };\n                    m.html = function() {\n                        return this.constant;\n                    };\n                }\n                else\n                {\n                    m.expression = new Expression( m.expression, this, null );\n                    m.value = function () {\n                        return this.expression.value();\n                    };\n                    m.html = function() {\n                        return this.expression.html();\n                    };\n                }\n                this.measurement[ m.name ] = m;\n            }\n        }        \n        \n        if ( typeof this.patternData.increment !== \"undefined\" )\n        {\n            for (var a = 0; a < this.patternData.increment.length; a++) {\n                var inc = this.patternData.increment[a];\n\n                //TODO test this increment that is a simple value...            \n                if (typeof inc.constant !== \"undefined\") \n                {\n                    inc.value = function () {\n                        return this.constant;\n                    };\n                    inc.html = function() {\n                        return this.constant;\n                    };\n                }\n                else\n                {\n                    inc.expression = new Expression( inc.expression, this, null );\n                    inc.value = function () {\n                        return this.expression.value();\n                    };\n                    inc.html = function() {\n                        return this.expression.html();\n                    };\n                }\n                this.increment[ inc.name ] = inc;\n            }\n        }        \n\n        //TODO support multiple pattern pieces\n        this.patternPiece1 = new PatternPiece( this.patternData.patternPiece[0], this );        \n    }\n\n    getIncrement(name) {\n        if (typeof name === \"object\")\n            return name;\n        return this.increment[name];\n    }\n\n    getMeasurement(name) {\n        if (typeof name === \"object\")\n            return name;\n        var m = this.measurement[name];\n\n        if ( !m )\n            throw \"Measurment not found:\" + name;\n\n        return m;\n    }\n\n\n}","class PatternPiece {\n\n    constructor (data, pattern) {\n        this.data = data;\n        this.drawing = {};\n        this.pattern = pattern;\n\n        if (data) {\n            this.name = data.name;\n            this.drawingObjects = data.drawingObject;\n        }\n        else {\n            this.drawingObjects = [];\n        }\n        this.bounds = {\n            minX: undefined,\n            maxX: undefined,\n            minY: undefined,\n            maxY: undefined\n        };\n        this.init();\n    }\n    \n    init() {\n        this.bounds = {\n            minX: undefined,\n            maxX: undefined,\n            minY: undefined,\n            maxY: undefined,\n            adjust: function (p) {\n                var x = p.x;\n                var y = p.y;\n                if (x !== undefined) {\n                    if ((this.minX === undefined) || (x < this.minX))\n                        this.minX = x;\n                    if ((this.maxX === undefined) || (x > this.maxX))\n                        this.maxX = x;\n                }\n                if (y !== undefined) {\n                    if ((this.minY === undefined) || (y < this.minY))\n                        this.minY = y;\n                    if ((this.maxY === undefined) || (y > this.maxY))\n                        this.maxY = y;\n                }\n            },\n            adjustForLine: function (line) {\n                this.adjust(line.p1);\n                this.adjust(line.p2);\n            }\n        };\n        if (!this.data)\n            return;\n        //Take each drawingObject in the JSON and convert to the appropriate \n        //type of object.\n        for (var a = 0; a < this.drawingObjects.length; a++) {\n            var dObj = this.drawingObjects[a];\n            dObj = this.newDrawingObj(dObj);\n            if (dObj === null)\n                continue;\n            //    throw( \"Unknown objectType:\" + dObj.objectType );\n            this.drawingObjects[a] = dObj; //these are now the objects with methods\n            this.registerObj(dObj);\n        }\n        this.analyseDependencies();\n    }\n\n    analyseDependencies()\n    {\n        //Now build up dependency links\n        this.dependencies = { \n            dependencies: [], \n            add: function ( source, target ) { \n                if ( typeof target.expression === \"object\" )\n                    target.expression.addDependencies( source, this );\n                else if ( target instanceof DrawingObject )\n                    this.dependencies.push( { source: source, target: target } ); \n            }  \n        };\n        for (var a = 0; a < this.drawingObjects.length; a++) {\n            var dObj = this.drawingObjects[a];\n            dObj.setDependencies( this.dependencies );\n        }\n        //TODO use a d3.map of a d3.set when we build up the data and then convert it to an array\n        //so that we can remove duplicates.\n    }\n\n    getObject(name) {\n        if (typeof name === \"object\")\n            return name;\n        return this.drawing[name];\n    }\n\n    //TODO make this a static method of DrawingObject\n    newDrawingObj(dObj) {\n        if (dObj.objectType === \"pointSingle\")\n            return new PointSingle(dObj);\n        else if (dObj.objectType === \"pointEndLine\")\n            return new PointEndLine(dObj);\n        else if (dObj.objectType === \"pointAlongLine\")\n            return new PointAlongLine(dObj);\n        else if (dObj.objectType === \"pointAlongPerpendicular\")\n            return new PointAlongPerpendicular(dObj);\n        else if (dObj.objectType === \"pointAlongBisector\")\n            return new PointAlongBisector(dObj);            \n        else if (dObj.objectType === \"pointFromXandYOfTwoOtherPoints\")\n            return new PointFromXandYOfTwoOtherPoints(dObj);\n        else if (dObj.objectType === \"pointIntersectLineAndAxis\")\n            return new PointIntersectLineAndAxis(dObj);\n        else if (dObj.objectType === \"line\")\n            return new Line(dObj);\n        else if (dObj.objectType === \"pointLineIntersect\")\n            return new PointLineIntersect(dObj);\n        else if (dObj.objectType === \"pointIntersectArcAndAxis\")\n            return new PointIntersectArcAndAxis(dObj);\n        else if (dObj.objectType === \"pointIntersectArcAndLine\")\n            return new PointIntersectArcAndLine(dObj);\n        else if (dObj.objectType === \"perpendicularPointAlongLine\")\n            return new PerpendicularPointAlongLine(dObj);\n        else if (dObj.objectType === \"pointOfTriangle\")\n            return new PointOfTriangle(dObj);            \n        else if (dObj.objectType === \"pointShoulder\")\n            return new PointShoulder(dObj);            \n        else if (dObj.objectType === \"arcSimple\")\n            return new ArcSimple(dObj);\n        else if (dObj.objectType === \"splineSimple\")\n            return new SplineSimple(dObj);\n        else if (dObj.objectType === \"splineUsingPoints\")\n            return new SplineUsingControlPoints(dObj);\n        else if (dObj.objectType === \"splinePathInteractive\")\n            return new SplinePathInteractive(dObj);\n        else if (dObj.objectType === \"splinePathUsingPoints\")\n            return new SplinePathUsingPoints(dObj);\n        else if (dObj.objectType === \"cutSpline\")   //SHOULD THIS BE pointCutSpline for consistency?\n            return new CutSpline(dObj);\n        else if (dObj.objectType === \"pointCutSplinePath\")\n            return new PointCutSplinePath(dObj);      \n        else if (dObj.objectType === \"pointCutArc\")\n            return new PointCutArc(dObj);                              \n        else if (dObj.objectType === \"pointIntersectCurves\")\n            return new PointIntersectCurves(dObj);      \n        else if (dObj.objectType === \"pointIntersectCurveAndAxis\")\n            return new PointIntersectCurveAndAxis(dObj);      \n        else if (dObj.objectType === \"pointIntersectArcs\")\n            return new PointIntersectArcs(dObj);      \n        else if (dObj.objectType === \"pointIntersectCircles\")\n            return new PointIntersectCircles(dObj);                  \n        else if (dObj.objectType === \"operationMove\")\n            return new OperationMove(dObj);                  \n        else if (dObj.objectType === \"operationRotate\")\n            return new OperationRotate(dObj);                  \n        else if (dObj.objectType === \"operationFlipByAxis\")\n            return new OperationFlipByAxis(dObj);                  \n        else if (dObj.objectType === \"operationResult\")\n            return new OperationResult(dObj);                  \n            \n\n        throw( \"Unsupported drawing object type:\" + dObj.objectType );\n\n        return null;\n    }\n\n    newFormula(formula) {\n\n        //f.value()\n        //f.html()\n\n        var f = formula;\n        if (typeof formula.constant !== \"undefined\") {\n            f.value = function () {\n                return this.constant;\n            };\n            f.html = function() {\n                return this.constant;\n            };\n        }\n        else if (typeof formula.expression === \"object\") {\n            f.expression = new Expression( f.expression, this.pattern, this );\n            f.value = function (currentLength) {\n                return f.expression.value(currentLength);\n            };\n            f.html = function() {\n                return f.expression.html();\n            };\n        }\n        return f;\n    }\n\n    registerObj(dObj) {\n        this.drawing[dObj.data.name] = dObj;\n        dObj.patternPiece = this;\n        if (typeof dObj.calculate !== \"undefined\") {\n            //var getObject = this.getObject();\n            dObj.calculate(this.bounds);\n        }\n    }\n\n    pointSingle(data) {\n        data.objectType = \"pointSingle\";\n        var dObj = this.add( data );\n        //var dObj = new PointSingle(data);\n        //this.drawingObjects.push(dObj);\n        //this.registerObj(dObj);\n        return dObj;\n    }\n\n    add(data) {\n        if (this.defaults) {\n            for (var d in this.defaults) {\n                if (typeof data[d] === \"undefined\")\n                    data[d] = this.defaults[d];\n            }\n        }\n        var dObj = this.newDrawingObj(data);\n        this.drawingObjects.push(dObj);\n        this.registerObj(dObj);\n        return dObj;\n    }\n\n    setDefaults(defaults) {\n        this.defaults = defaults;\n    }\n}\n\n","//(c) Copyright 2019 Jason Dore\n//Inspired by the excellent seamly2D/Valentina (XXX ref) developed by Roman/Susan etc.\n//this is a ground up implementation in Javascript intended to be compatible with, but\n//not based on, the seamly2D/Valentina pattern making systen in order to support community\n//pattern sharing website. \n\n\n\n\n//var gInteractionPrefix; \nvar selectedObject;\nvar linksGroup;\n\nfunction drawPattern( dataAndConfig, ptarget, options ) \n{\n    //Remove the svg if called by graph_kill\n    if ( dataAndConfig === null )\n    {\n        var parent = document.getElementById(ptarget).parentNode;\n        var child = document.getElementById(ptarget);\n        parent.removeChild(child);\n        return ;\n    } \n\n    //This is a graph initialisation\n\n    var pattern = new Pattern( dataAndConfig, options );\n      \n    pattern.gInteractionPrefix = options.interactionPrefix;    \n    \n    function newkvpSet(noRefresh)\n    {\n        var kvp = { } ;\n        kvp.kvps = new Array() ;\n\n        kvp.add = function (k, v)\n        {\n            this.kvps.push ( {k: k, v: v} ) ;\n        } ;\n\n        kvp.toString = function (p)\n        {\n            var r = '' ;\n\n            for (var i = 0 ; i < this.kvps.length ; i++)\n            {\n                r += '&' + p + this.kvps[i].k + '=' + this.kvps[i].v ;\n            }\n\n            return r ;\n        } ;\n\n        if (noRefresh)\n            kvp.add(\"_noRefresh\", -1) ;\n\n        return kvp ;\n    }\n    \n    // show menu on right-click.\n    var contextMenu = function(d) {\n   \t\td3.event.preventDefault() ;\n    \tvar v = newkvpSet(false) ;\n    \tv.add(\"x\", d.x) ;   \n    \tv.add(\"y\", d.y) ;    \n    \tgoGraph( gInteractionPrefix + ':' + d.data.contextMenu ,\n    \t\t\t d3.event, \n    \t\t\t v ) ;\n    }      \n    \n    var targetdiv = d3.select( \"#\" + ptarget );\n    \n    doDrawing( targetdiv, pattern.patternPiece1, contextMenu );\n    \n    doTable( targetdiv, pattern.patternPiece1, contextMenu );\n}\n\n\n//Do the drawing... (we've added draw() to each drawing object.\nfunction doDrawing( graphdiv, patternPiece1, contextMenu )\n{\n    var margin = 25; \n    var width = 400;\n    var height = 600;\n\n    var svg = graphdiv.append(\"svg\")\n                       .attr(\"width\", width + ( 2 * margin ) )\n                       .attr(\"height\", height + ( 2 * margin ));\n\n    var transformGroup = svg.append(\"g\")\n                            .attr(\"transform\", \"translate(\" + ( margin ) + \",\" + ( margin ) + \")\");\n\n    var scaleX = width / ( patternPiece1.bounds.maxX - patternPiece1.bounds.minX );                   \n    var scaleY = height / ( patternPiece1.bounds.maxY - patternPiece1.bounds.minY );           \n    \n    if ( ( isFinite( scaleX ) ) && ( isFinite( scaleY ) ) )\n        scale = scaleX > scaleY ? scaleY : scaleX;\n    else if ( isFinite( scaleX ) )\n        scale = scaleX;\n    else\n        scale = 1;\n\n    var transformGroup = transformGroup.append(\"g\")\n                               .attr(\"transform\", \"scale(\" + scale + \",\" + scale + \")\");\n\n    var transformGroup = transformGroup.append(\"g\")\n                               .attr(\"transform\", \"translate(\" + ( ( -1.0 * patternPiece1.bounds.minX ) ) + \",\" + ( ( -1.0 * patternPiece1.bounds.minY ) ) + \")\");\n\n    //TODO also need to be able to click on a line / curve/ arc\n\n    var onclick = function(d) {\n        d3.event.preventDefault() ;\n        console.log( \"Click! \" );\n        $( \".j-active\" ).removeClass(\"j-active\");\n        $( \".j-item.source\" ).removeClass(\"source\");\n        $( \".j-item.target\" ).removeClass(\"target\");\n        $(this).addClass(\"j-active\");\n        d.tableSvg.each( function(d,i) {\n            $(this).addClass(\"j-active\");\n        });\n        selectedObject = d;\n        //drawLinks( patternPiece1 );\n\n        linksGroup.selectAll(\"path.link\") //rename .link to .dependency\n            .attr(\"class\", function( d ) {                         \n                if ( d.source == selectedObject ) \n                {\n                    d.target.tableSvg.each( function() { $(this).addClass(\"source\"); } );\n                    return \"source link\";\n                }\n                if ( d.target == selectedObject ) \n                {\n                    d.source.tableSvg.each( function() { $(this).addClass(\"target\"); } );\n                    return \"target link\";\n                }\n                return \"link\"; \n            } );\n    }\n\n    var a = transformGroup.selectAll(\"g\");    \n    a = a.data( patternPiece1.drawingObjects );\n    a.enter()\n     .append(\"g\")\n     .each( function(d,i) {\n        var g = d3.select( this );\n        //d.calculate();\n\n        d.drawingSvg = g;\n\n        g.on(\"contextmenu\", contextMenu);\n        g.on(\"click\", onclick);\n\n        if ( typeof d.draw === \"function\" )\n            d.draw( g );\n    });\n\n    //Enable Pan and Zoom\n    //https://observablehq.com/@d3/zoom\n    //TODO if a point is selected then zoom with it as the focus\n    //SEE https://bl.ocks.org/mbostock/a980aba1197350ff2d5a5d0f5244d8d1\n    /*\n    function zoomed() {\n        transformGroup.attr(\"transform\", d3.event.transform);\n    }; this doesn't quite work well enough\n    svg.call(d3.zoom()\n        .extent([[0, 0], [width, height]])\n        .scaleExtent([1, 8])\n        .on(\"zoom\", zoomed));\n    */\n}\n\n\nfunction doTable( graphdiv, patternPiece1, contextMenu )\n{\n    var margin = 25; \n    var width = 400;\n    var height = 600;\n    var minItemHeight = 30; //should not be required\n    var itemMargin = 8;\n    var itemWidth = 300;\n    var ypos = 0;\n    var seq = 1; //TODO get these in the XML as data?\n\n    var svg = graphdiv.append(\"svg\")\n                       .attr(\"width\", width + ( 2 * margin ) )\n                       .attr(\"height\", height + ( 2 * margin ));    \n\n    var a = svg.selectAll(\"g\");\n    a = a.data( patternPiece1.drawingObjects );\n    a.enter()        \n     .append(\"g\")\n     .each( function(d,i) {\n\n        var divHeight = function(that) {\n\n            //this - the dom svg element\n            //that - the data object\n\n            //console.log( \"divHeight() of this:\" + this + \" that:\" + that );\n\n            //var div = $(this).find( \"div.nodedesc\" );\n            var h = $(this).find( \"div.outer\" ).height();\n            \n            if ( h < minItemHeight )\n                return minItemHeight;\n            return h;\n            \n        };\n\n        var g = d3.select( this );\n\n        g.attr( \"class\", \"j-item\") ;\n\n        d.tableSvg = g;\n        d.tableSvgX = itemWidth;\n        d.tableSvgY = ypos + ( 0.5 * minItemHeight );\n\n        var fo = g.append( \"foreignObject\" )\n         .attr( \"x\", 0 )\n         .attr( \"y\", function (d) { \n             return ypos;\n         } )\n         .attr( \"width\", itemWidth  );\n\n         var div = fo.append( \"xhtml:div\" )\n           .attr(\"class\",\"outer\")\n           .append( \"xhtml:div\" )\n           .attr(\"class\",\"desc\")\n           .html( d.html() );\n\n        fo.attr( \"height\", 1 ); //required by firefox otherwise bounding rects returns nonsense\n        fo.attr( \"height\", divHeight );\n\n        g.attr( \"height\", divHeight )\n         .attr( \"y\", function (d) { \n                                    //Get the height of the foreignObject.\n                                    var h = this.childNodes[0].getBoundingClientRect().height;\n                                    ypos += h + itemMargin; \n                                    //console.log(\"y: \" + ypos );\n                                    return ypos } )\n\n        g.on(\"contextmenu\", contextMenu);\n    });                   \n    \n    linksGroup = svg.append(\"g\")\n                    .attr(\"class\", \"links\");\n\n    drawLinks( patternPiece1 );\n}\n\n\nfunction drawLinks( patternPiece )\n{\n    var linkData = patternPiece.dependencies.dependencies;\n\n    linksGroup.selectAll(\"path.link\") //rename .link to .dependency\n                    .data(linkData)\n                    .enter().append(\"path\")\n                    .attr(\"class\", \"link\" )\n                    .attr(\"d\", curve);\n}\n\n\n/*\n * Curve that connects items in the table.\n */\nfunction curve(link) {\n    var x0 = link.source.tableSvgX, y0 = link.source.tableSvgY,\n        x1 = link.target.tableSvgX, y1 = link.target.tableSvgY;\n\n    var dx = x0 - x1,\n        dy = y0 - y1,\n        l = Math.log( Math.abs(dy /30 ) ) * 50;\n\n    var path = d3.path();\n    path.moveTo( x0, y0 );\n    path.bezierCurveTo( x0+l , y0, x1+l, y1, x1, y1 );\n    return path;                      \n}\n\n\nexport{ PatternPiece, doDrawing, doTable, drawPattern  };"]}